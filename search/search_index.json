{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PyORlib","text":"<p>Documentation: https://dapensoft.github.io/pyorlib</p> <p>Source Code: https://github.com/dapensoft/pyorlib</p> <p>     \u2003\u2003PyORlib is a powerful Python library for operations research and optimization. It provides a set of      abstractions to easily define, solve, and interact with mathematical models in a standardized manner across      different optimization packages. With PyORlib, you can easily implement mathematical models using a user-friendly      interface, while seamlessly identifying the ideal solver or optimization package, such as CPLEX, Gurobi,      OR-Tools, or PuLP, that perfectly aligns with your specific requirements. </p>"},{"location":"#key-features","title":"Key Features","text":"<p>     PyORlib offers a powerful yet easy-to-use set of tools for mathematical modeling and optimization: </p> <ul> <li>Intuitive API \u2500  PyORlib provides a user-friendly API that allows you to define, solve, and interact with mathematical models in a  standardized manner across different optimization packages. </li> <li>Seamless Solver Integration \u2500  Optimize models across different solvers, including custom ones, without modifying the model's definition. Tailor the  behavior and capabilities of the solvers to perfectly align with your unique requirements. </li> <li>Simplified Mathematical Modeling \u2500  Define mathematical models effortlessly using PyORlib's comprehensive set of abstractions and classes. Focus on the  problem at hand instead of getting lost in implementation details. </li> <li>Scalability and Maintainability \u2500  Keep your code organized, readable, and maintainable over time with the PyORlib's workflow. Structure your variables, parameters, constraints, and objective functions in a clean and extensible manner. </li> <li>No Overhead \u2500  PyORlib ensures full compatibility between models and different solvers by seamlessly translating models to each  solver's native format, acting as a standardized communication interface. </li> <li>Data Validation \u2500  PyORlib offers comprehensive format and content validations to ensure the integrity of your model data. These  validation features help identify errors early and maintain consistent, error-free model data for robust optimization. </li> <li>Comprehensive Documentation \u2500  PyORlib provides a comprehensive documentation suite that includes API references and usage examples, to effectively leverage all the features and capabilities of the library. </li> </ul>"},{"location":"#a-simple-example","title":"A Simple Example","text":"<p>     \u2003\u2003Experience the power of PyORlib through a simple example that illustrates the core concepts and basic      usage of the package by formulating and solving a mixed integer programming (MIP) problem from the      OR-Tools documentation.     This example will provide you with a clear and concise introduction to the package's functionalities and its      application in real-world optimization challenges. </p>"},{"location":"#problem-formulation","title":"Problem Formulation","text":"<p>     \u2003\u2003In this example, we will find the highest integer coordinates (x, y) on the Y-axis within      a defined shape. Our objective is to maximize the value of an objective function while satisfying linear      constraints, as shown below with a mathematical formulation: </p> \\[ \\begin{align} \\text{Maximize:} \\quad &amp; x + 10y \\\\ \\text{Subject to:} \\quad &amp; x + 7y = 17.5 \\\\ &amp; 0 \\leq x \\leq 3.5 \\\\ &amp; 0 \\leq y \\leq 2.5 \\\\ \\end{align} \\] <p>     \u2003\u2003Since the constraints are linear, we can classify this problem as a linear optimization problem in      which the solutions are required to be integers. The feasible region and integer points for this problem are      shown below: </p> <p> </p>"},{"location":"#solution-using-pyorlib","title":"Solution Using PyORlib","text":"<p>     \u2003\u2003In order to model and solve this problem, we'll be using the PyORlib package. In this example, we'll      utilize the OR-Tools optimization package, which is one of the built-in integrations provided by PyORlib. However,     you can also choose to use other integration options described in the Optional Dependencies     section, or even implement your own custom integration. Before proceeding, make sure you have installed the OR-Tools     integration. Once that is done, let's get started: </p> Solving a MIP Problem with PyORlib<pre><code>from math import inf\n\nfrom pyorlib import Model\nfrom pyorlib.engines.ortools import ORToolsEngine\nfrom pyorlib.enums import ValueType, OptimizationType\n\n# Create a Model instance using the ORTools engine\nmodel: Model = Model(engine=ORToolsEngine())\n\n# Add two integer variables for coordinates x and y\nx = model.add_variable(\"x\", ValueType.INTEGER, 0, inf)\ny = model.add_variable(\"y\", ValueType.INTEGER, 0, inf)\n\n# Define problem constraints\nmodel.add_constraint(x + 7 * y &lt;= 17.5)\nmodel.add_constraint(x &lt;= 3.5)\n\n# Set objective to maximize x + 10y\nmodel.set_objective(OptimizationType.MAXIMIZE, x + 10 * y)\n\n# Solve model\nmodel.solve()\n\n# Print solution\nmodel.print_solution()\n</code></pre> <p>     \u2003\u2003As we can see from the previous example, PyORlib follows a simple and user-friendly workflow for      defining, solving, and interacting with mathematical models. Let's review the key steps: </p> <ol> <li> Import necessary modules: We first imported the required modules from PyORlib, including the <code>Model</code>  class, <code>ORToolsEngine</code> class, and necessary enums (<code>ValueType</code> and <code>OptimizationType</code>). </li> <li> Create a new model: Then we created a new <code>Model</code> object and specified that we want to use the  OR-Tools engine for solving the optimization problem. </li> <li> Define the variables: We added 2 integer variables, x and y, to represent the coordinates on the Y-axis within the defined shape. </li> <li> Define the constraints: We added linear constraints to the model to restrict the feasible region of the  optimization problem and ensure the coordinates (x, y) satisfy specific conditions. </li> <li> Define the objective function: We set the objective of the model using the <code>set_objective</code> method to  maximize the objective function x + 10 * y. </li> <li> Solve the model: We invoked the solve method on the model to find the optimal values for variables (x, y) that satisfy the constraints and maximize the objective function. </li> <li> Display the solution: Finally, we called the print_solution method to showcase the optimal values of variables  (x, y) and the corresponding value of the objective function. </li> </ol> <p>     \u2003\u2003Having gained a clear understanding of the workflow showcased in the Simple Example, you are now      well-equipped to explore more intricate optimization scenarios and fully harness the capabilities of PyORlib in      your own projects. </p> Next steps... <p>     \u2003\u2003Feel free to experiment and build upon this example to explore the full potential of PyORlib in your      projects. With PyORlib, you can define and implement complex mathematical models and algorithms, test multiple      optimization packages to identify the ideal one that perfectly aligns with your unique requirements, define      and organize the vital components of your optimization model, and much more! </p>"},{"location":"#a-practical-example","title":"A Practical Example","text":"<p>     \u2003\u2003To demonstrate PyORlib in a realistic scenario, we will implement a transportation problem from the      GAMS Tutorial by Richard E. Rosenthal,      which provides a comprehensive case study for testing PyORlib's optimization capabilities and features. </p>"},{"location":"#problem-formulation_1","title":"Problem Formulation","text":"<p>     \u2003\u2003The transportation problem we will address is a classic instance of linear programming's transportation     problem, which has historically served as a testing ground for the development of optimization technology. This      transportation problem involves determining the optimal flow of a product from multiple sources (plants) to      destinations (markets) to minimize costs while satisfying demands. </p> \\[ \\begin{align} \\text{Minimize:} \\quad &amp; \\sum_{i=1}^{n} \\sum_{j=1}^{m} c_{ij} x_{ij} \\\\ \\\\ \\text{Subject to:} \\quad &amp; \\sum_{j=1}^{m} x_{ij} \\leq a_{i} \\quad \\forall_{i} \\\\ &amp; \\sum_{i=1}^{n} x_{ij} \\geq b_{j} \\quad \\forall_{j} \\\\ &amp; x_{ij} \\geq 0 \\quad \\forall_{ij}, \\thinspace integer \\\\ &amp; i=1,...,n; \\quad j=1,...,m \\\\ \\end{align} \\] <p>     \u2003\u2003Before diving into the implementation, let's take a moment to familiarize ourselves with the key      components of the model. This brief exploration will provide a better understanding of how these components      work together. </p> <ul> <li> <p>Indices:</p> <p> \\(i=\\) plants; \\(\\quad j=\\) markets.</p> </li> <li> <p>Parameters (Given Data):</p> <p> \\(a_{i}=\\) supply of commodity of plant \\(i\\) (in cases).</p> <p> \\(b_{j}=\\) demand for commodity at market \\(j\\) (cases).</p> <p> \\(c_{ij}=\\) cost per unit shipment between plan \\(i\\) and market \\(j\\) ($/case).</p> </li> <li> <p>Decision Variables:</p> <p> \\(x_{ij}=\\) amount of commodity to ship from plant \\(i\\) to market \\(j\\) (cases).</p> </li> <li> <p>Constraints:</p> <p>\u2003Observe supply limit at plant \\(i\\): \\(\\sum_{j=1}^{m} x_{ij} \\leq a_{i} \\quad \\forall_{i}\\)</p> <p>\u2003Satisfy demand at market \\(j\\): \\(\\sum_{i=1}^{n} x_{ij} \\geq b_{j} \\quad \\forall_{j}\\)</p> </li> </ul> <p>     \u2003\u2003The GAMS tutorial describes a scenario with two canning plants and three markets. It provides sample      supply, demand and cost data. We will use this same data to define our model. </p> New York Chicago Topeka Supply Seattle 2.5 1.7 1.8 350 San Diego 2.5 1.8 1.4 600 Demand 325 300 275 <p>     \u2003\u2003To model and solve the problem in Python, we will use PyORlib and its CPLEX integration. However, it\u2019s      important to note that you can choose any of the supported optimization engine integrations described in the      Optional Dependencies      or even use your own custom implementations. </p>"},{"location":"#solution-using-pyorlib_1","title":"Solution Using PyORlib","text":"<p>     \u2003\u2003Before proceeding, ensure that PyORlib is installed, along with its integration for the CPLEX engine.      Once everything is set up, let's build our transportation model: </p> Solving a Transportation Problem with PyORlib<pre><code>from math import inf\n\nfrom pyorlib import Model\nfrom pyorlib.engines.cplex import CplexEngine\nfrom pyorlib.enums import ValueType, OptimizationType\n\n# Create a transportation model using the CplexEngine.\nmodel = Model(engine=CplexEngine(), name=\"A Transportation Model\")  # (1)!\n\n# Define the dimensions of the problem\nn = 2  # Number of plants\nm = 3  # Number of markets\nn_range = range(1, n + 1)  # Range of plant indices\nm_range = range(1, m + 1)  # Range of market indices\n\n# Define the parameters of the model\na_i = [350, 600]  # Supply limit at each plant\nb_j = [325, 300, 275]  # Demand at each market\nc_i_j = [  # Transportation costs\n    2.5, 1.7, 1.8,\n    2.5, 1.8, 1.4,\n]\n\n# Define the decision variables\nx_i_j = {\n    (i, j): model.add_variable(\n        name=f\"x_{i}_{j}\",\n        value_type=ValueType.INTEGER,\n        lower_bound=0,\n        upper_bound=inf\n    )\n    for i in n_range\n    for j in m_range\n}\n\n# Add supply limit at plants constraints\nfor i in n_range:\n    model.add_constraint(\n        expression=sum(\n            x_i_j[i, j]\n            for j in m_range\n        ) &lt;= a_i[i - 1]\n    )\n\n# Add satisfy demand at markets constraints\nfor j in m_range:\n    model.add_constraint(\n        expression=sum(\n            x_i_j[i, j]\n            for i in n_range\n        ) &gt;= b_j[j - 1]\n    )\n\n# Set the objective function to minimize the total transportation cost\nmodel.set_objective(\n    opt_type=OptimizationType.MINIMIZE,\n    expression=sum(\n        c_i_j[(i - 1) * m + (j - 1)] * x_i_j[i, j]\n        for i in n_range\n        for j in m_range\n    )\n)\n\n# Solve the model and print the solution\nmodel.solve()\nmodel.print_solution()\n</code></pre> <ol> <li>Runtime Flexibility &amp; Customization    \u2003\u2003As previously mentioned, we have the ability to solve this model using multiple optimization engines     without making any changes to the underlying definition. For instance, we can employ various optimization engines,     such as:     Gurobi Engine: <pre><code>from pyorlib.engines.gurobi import GurobiEngine\n\nmodel = Model(\n    engine=GurobiEngine(),\n    name=\"A Transportation Model\",\n)\n</code></pre> OR-Tools Engine: <pre><code>from pyorlib.engines.ortools import ORToolsEngine\n\nmodel = Model(\n    engine=ORToolsEngine(),\n    name=\"A Transportation Model\",\n)\n</code></pre> PuLP Engine: <pre><code>from pyorlib.engines.pulp import PuLPEngine\n\nmodel = Model(\n   engine=PuLPEngine(), \n   name=\"A Transportation Model\",\n)\n</code></pre></li> </ol> <p>     \u2003\u2003As we can see from this practical example, PyORlib enables us to easily build a transportation model,      define its necessary components, optimize the model, and obtain the optimal solution. The simple yet powerful      syntax of PyORlib allows us to focus on the problem at hand without getting lost in implementation details. </p>"},{"location":"#organized-readable-workflow","title":"Organized &amp; Readable Workflow","text":"<p>     \u2003\u2003PyORlib goes beyond the optimization process and offers a powerful modeling workflow that emphasizes      code organization, readability, and maintainability over time. This workflow is built upon a set of abstractions      and classes from the structures module, that allows you to centralize and standardize the definition of your      model's components, such as dimensions, parameters, decision variables, and constant properties. </p> <p>     \u2003\u2003One significant advantage of PyORlib's workflow is the ability to easily rename and modify components      throughout your codebase. Instead of manually searching and replacing strings, you can make changes in one place,      ensuring consistency and reducing errors. </p> <pre><code>from abc import ABC\nfrom dataclasses import dataclass\n\nfrom pyorlib.enums import ParameterType, ValueType\nfrom pyorlib.structures import DimensionDefinition, ParameterDefinition, TermDefinition\n\n\nclass GenericModelDefinition(ABC):\n\n    @dataclass(frozen=True)\n    class Dimensions(ABC):\n        n = DimensionDefinition(name=\"n\", display_name=\"Total number of 'i' indices\", min=1)\n        m = DimensionDefinition(name=\"m\", display_name=\"Total number of 'j' indices\", min=1)\n\n    @dataclass(frozen=True)\n    class Parameters(ABC):\n        c_i_j = ParameterDefinition(\n            set_name=\"c_i_j\",\n            name=lambda i, j: f\"c_{i}_{j}\",\n            display_name=\"Cost per unit shipment between 'i' and 'j'\",\n            parameter_types={ParameterType.FIXED, ParameterType.BOUNDED},\n            value_types={ValueType.CONTINUOUS},\n            min=0,\n        )\n\n    @dataclass(frozen=True)\n    class DecisionVariables(ABC):\n        x_i_j = TermDefinition(\n            set_name=\"x_i_j\",\n            name=lambda i, j: f\"x_{i}_{j}\",\n            display_name=\"Amount of commodity to ship from 'i' to 'j'\",\n        )\n\n\n# Usage within a model\nprint(GenericModelDefinition.Dimensions.n.min)  # Access the minimum value for dimension 'n'\nprint(GenericModelDefinition.Parameters.c_i_j.name(1, 1))  # Generate the name for parameter 'c_1_1'\nprint(GenericModelDefinition.DecisionVariables.x_i_j.display_name)  # Access the display name for the decision variable 'x_i_j'\n</code></pre> <p>     \u2003\u2003By leveraging PyORlib's structured approach, you can improve the maintainability and scalability of      your models. The clean and organized codebase makes for easy navigation, understanding, and modification, making     it easier to collaborate with other team members and adapt your models to changing requirements. </p>"},{"location":"#ensuring-model-integrity","title":"Ensuring Model Integrity","text":"<p>     \u2003\u2003In addition to PyORlib's workflow capabilities, this package provides a set of abstractions      designed to apply validations and ensure the integrity of your model data. These validation features play a      crucial role in identifying errors early on and maintaining consistent, error-free model data, resulting in     more robust optimization. </p> <ol> <li>Defining Validation Rules \u2500  PyORlib utilizes Python <code>descriptors</code> and <code>dataclasses</code> to define validation rules for model  schemas. Attributes like <code>DimensionField</code> and <code>ParameterField</code> allow specifying requirements  like minimum/maximum values.  <pre><code>from dataclasses import dataclass\n\nfrom pyorlib.enums import ParameterType, ValueType\nfrom pyorlib.structures import MultiValueParameter\nfrom pyorlib.validators import DimensionField, ParameterField\n\n\n@dataclass\nclass ExampleSchema:\n    n: int = DimensionField(min=1)  # Specifies the minimum value allowed for 'n'\n    a_i: MultiValueParameter = ParameterField(\n        parameter_types={ParameterType.FIXED},  # Specifies the allowed param types for 'a_i'\n        value_types={ValueType.INTEGER},  # Specifies the allowed value types for 'a_i'\n        min=0,  # Specifies the minimum value allowed for 'a_i'\n    )\n</code></pre> </li> <li>Putting it into Practice \u2500  To apply validations, instantiate the <code>ExampleSchema</code> class with the model data. If initialization succeeds without errors, the data passed all validations and can be used safely for optimization. However, if the data is  invalid, an error will be raised immediately upon initialization, before the invalid data can be optimized.  <pre><code>schema = ExampleSchema(\n    n=2,\n    a_i=MultiValueParameter(\n        value_type=ValueType.INTEGER,\n        parameter_type=ParameterType.FIXED,\n        values=(1, 2),\n    ),\n) # succeeds\n\nschema = ExampleSchema(\n    n=0,\n    a_i=MultiValueParameter(\n        value_type=ValueType.INTEGER,\n        parameter_type=ParameterType.FIXED,\n        values=(1, 2.6),\n    ),\n) # raises ValueError\n</code></pre> </li> </ol> <p>     \u2003\u2003By validating data upon instantiation, any issues are caught immediately before the model is optimized.     This helps maintain data integrity and prevents errors downstream in the optimization process. </p>"},{"location":"#runtime-flexibility-customization","title":"Runtime Flexibility &amp; Customization","text":"<p>     \u2003\u2003At its core, PyORlib provides a modular optimization design that allows you to seamlessly switch between     different built-in or custom optimization engine implementations on the fly. Whether you opt for official      optimization package integrations or decide to create your own custom ones, PyORlib allows you to tailor      the behavior and capabilities of the optimization engine to perfectly align with your unique requirements. </p> <p>     \u2003\u2003By leveraging the principles of dependency inversion and open-closed design, PyORlib decouples the      model's optimization from the underlying implementation, allowing you to optimize models across different      optimization engines, including custom ones, without modifying the model definition or employing complex logic. </p>"},{"location":"#seeing-it-in-action","title":"Seeing it in Action","text":"<p>     \u2003\u2003To showcase the flexibility of PyORlib, let's revisit the Simple Example     we discussed earlier and use it as our foundation. After copying the example, we will make some modifications to      decouple the dependency from a specific optimization engine to its interface, and encapsulate the model definition     and resolution within a function to ensure reusability across different optimization engines, as shown below: </p> <pre><code>from math import inf\n\nfrom pyorlib import Model, Engine\nfrom pyorlib.engines.gurobi import GurobiEngine\nfrom pyorlib.engines.ortools import ORToolsEngine\nfrom pyorlib.enums import ValueType, OptimizationType\n\n\ndef mip_problem(engine: Engine):\n    # Create a Model instance\n    model: Model = Model(engine)\n\n    # Add two integer variables for coordinates x and y\n    x = model.add_variable(\"x\", ValueType.INTEGER, 0, inf)\n    y = model.add_variable(\"y\", ValueType.INTEGER, 0, inf)\n\n    # Define problem constraints\n    model.add_constraint(x + 7 * y &lt;= 17.5)\n    model.add_constraint(x &lt;= 3.5)\n\n    # Set objective to maximize x + 10y\n    model.set_objective(OptimizationType.MAXIMIZE, x + 10 * y)\n\n    # Solve model\n    model.solve()\n\n    # Print solution\n    model.print_solution()\n\n\n# Solving the MIP problem using the ORTools engine\nmip_problem(engine=ORToolsEngine())\n\n# Solving the MIP problem using the Gurobi engine\nmip_problem(engine=GurobiEngine())\n</code></pre> <p>     \u2003\u2003As we can see from the example, by just depending on the engine interface instead of a concrete      implementation and applying dependency injection, we were able to solve the same MIP problem from the Simple      Example across multiple optimization engines, including custom ones, without modifying the underlying model      definition and optimization. </p>"},{"location":"#built-in-custom-integrations","title":"Built-in &amp; Custom Integrations","text":"<p>     \u2003\u2003Out of the box, PyORlib provides integrations for popular solvers like CPLEX, Gurobi, OR-Tools and PuLP,     leveraging their proven algorithms to optimize models reliably. These integrations give you access to top-tier      solvers without additional work. However, the options are not limited only to built-in integrations. </p> <p>     \u2003\u2003PyORlib also supports custom engine implementations through its extensible and flexible architecture.      You can create your own optimization engines by subclassing the base <code>Engine</code> class and implementing the      necessary methods, whether using third-party or custom algorithms. </p>"},{"location":"#continuous-evolution","title":"Continuous Evolution","text":"<p>     \u2003\u2003PyORlib continuously adapts to support developers across various technological and programming domains.      Its primary goal is to remain a useful tool for learning about operations research, mathematical model optimization,     and testing different optimization packages with ease. </p> <p>     \u2003\u2003While future development may introduce some changes to enhance and expand certain current      functionalities, the highest priority remains providing a simple yet powerful platform for students, researchers,     and practitioners to explore optimization concepts, test algorithms, and further their own knowledge. Large-scale     changes that could introduce significant complexity are less likely in order to maintain accessibility as the core     focus. </p> Driving Innovation Through Collaboration <p>     \u2003\u2003PyORlib is an open source project that welcomes community involvement. If you wish to contribute     additional optimization suites, improvements, or bug fixes, please check the Contributing      section for guidelines on collaborating. </p>"},{"location":"#get-started-today","title":"Get Started Today!","text":"<p>     \u2003\u2003Are you ready to dive into the operation research and optimization modeling world with PyORlib? Follow these      steps to integrate PyORlib into your project and start leveraging its powerful modeling tools. Click the button     below to navigate to the PyORlib Getting Started page and explore detailed instructions, examples, and more: </p> <p> \u2003Getting Started\u2003 </p>"},{"location":"#license","title":"License","text":"<p>     \u2003\u2003PyORlib is distributed as open source software and is released under the MIT License.      You can view the full text of the license in the <code>LICENSE</code>      file located in the PyORlib repository. </p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contribution-guidelines","title":"Contribution Guidelines","text":"<p>     Thank you for being interested in contributing to PyORlib! Your involvement is greatly appreciated \u2764\ufe0f </p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<p>     \u2003\u2003Before creating an issue or pull request, please make sure to check if a similar discussion already     exists. We encourage you to actively participate by engaging in existing issues. </p>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>     \u2003\u2003If you have any questions, bug reports, or feature requests, please open a new issue or discussion.      When reporting issues, be sure to provide clear steps to reproduce the problem. For security vulnerabilities,      please refer to our security policy. </p>"},{"location":"contributing/#submitting-changes","title":"Submitting Changes","text":"<p>     \u2003\u2003We greatly appreciate your contributions and want to ensure they align with the project's goals and      quality standards. Unless your proposed change is trivial, such as fixing a typo or tweaking documentation, we     recommend creating an issue or discussion to talk about the proposed change before submitting a pull request.      This allows us to provide feedback, clarify requirements, and ensure your efforts are focused in the right      direction. To make a contribution, please follow these steps: </p> <ol> <li>Fork the repository and create a new branch.</li> <li>Implement your changes in the branch.</li> <li>Ensure that formatting, linting, and tests pass.</li> <li>Whenever possible, include tests to cover the lines of code you added or modified.</li> <li>Commit your changes and submit a pull request with a clear, detailed message.</li> </ol> <p>     \u2003\u2003We'll review your pull request to ensure it meets our quality standards before merging it into the main     codebase. Please feel free to ask any questions along the way! </p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<p>     \u2003\u2003We recommend developing in a virtual environment to      isolate project dependencies. To set up your development environment, follow these steps: </p> <ol> <li> <p>Create a virtual environment:</p> <pre><code>python -m venv env\n</code></pre> </li> <li> <p>Activate the virtual environment:</p> Linux, macOSWindows PowerShellWindows Bash <pre><code>source ./env/bin/activate\n</code></pre> <pre><code>.\\env\\Scripts\\Activate.ps1\n</code></pre> <pre><code>source ./env/Scripts/activate\n</code></pre> </li> <li> <p>Install development dependencies:</p> <pre><code>pip install -e .[dev]\n</code></pre> </li> </ol>"},{"location":"contributing/#running-the-tests","title":"Running the Tests","text":"<p>     During development, you have two options to run the test suite: </p> ManualUsing Hatch <pre><code>pytest -v\n</code></pre> <pre><code>hatch run tests:test\n</code></pre>"},{"location":"contributing/#checking-types","title":"Checking Types","text":"<p>     You can use the mypy tool to check the static typing of your code. Simply run the     following command: </p> ManualUsing Hatch <pre><code>mypy\n</code></pre> <pre><code>hatch run tests:typing\n</code></pre>"},{"location":"contributing/#code-coverage","title":"Code Coverage","text":"<p>     To check the code coverage of your changes, run the following command: </p> ManualUsing Hatch <pre><code>coverage run -m pytest -v\n</code></pre> <pre><code>hatch run tests:cov\n</code></pre>"},{"location":"contributing/#pyorlib-documentation","title":"PyORlib Documentation","text":"<p>     \u2003\u2003The documentation for our project is written in Markdown and built using Material for MkDocs.     Additionally, the API documentation is generated from the docstrings using mkdocstrings.     To begin working on the documentation in a development environment, simply execute the following command: </p> ManualUsing Hatch <pre><code>mkdocs serve --dev-addr localhost:8000\n</code></pre> <pre><code>hatch run docs:serve\n</code></pre>"},{"location":"contributing/#project-structure-and-conventions","title":"Project Structure and Conventions","text":"<p>     \u2003\u2003This project follows the src-layout convention     for Python packages. This convention improves code organization, facilitates easy testing and usage, and allows      developers to install the package in editable mode.     By adhering to this convention, we can validate the package thoroughly in a realistic environment, leading to a      higher quality and user-friendly product. </p>"},{"location":"contributing/#code-standards","title":"Code Standards","text":"<p>     We strive for a high-quality and maintainable codebase. To achieve this, we have established the following code      standards: </p> <ul> <li>PEP-8 Compliance \u2500  Please follow the guidelines outlined in PEP-8 for consistent code formatting.  Adhering to these standards ensures readability and maintainability across our codebase. </li> <li>Black Formatter \u2500  We recommend using the Black code formatter to ensure consistent style and formatting. By automatically enforcing a standard style, the Black formatter saves you time and effort in manual formatting. </li> <li>Meaningful Naming \u2500  Use descriptive and meaningful names for variables, functions, and classes. Clear and intuitive naming enhances code  comprehension, making it easier for everyone to understand and work with the code. </li> <li>Modularity and Reusability \u2500  Encourage the development of modular and reusable code. Breaking down complex tasks into smaller, self-contained  components promotes maintainability, reduces complexity, and allows for scalability and extensibility. </li> <li>Optimization and Efficiency \u2500  Strive for efficient code by considering algorithmic complexity and optimizing where necessary. Writing code that is both correct and performant ensures responsive and scalable applications. </li> </ul>"},{"location":"contributing/#documentation-style","title":"Documentation Style","text":"<p>     \u2003\u2003Clear and comprehensive documentation facilitates collaboration and understanding. When contributing     to this project, please ensure that you document the following items using properly formatted docstrings: </p> <ul> <li>Modules.</li> <li>Class definitions.</li> <li>Function definitions.</li> <li>Module-level variables.</li> </ul> <p>     \u2003\u2003PyORlib uses Sphinx docstrings formatted according to     PEP 257 guidelines. For more examples and detailed guidance on using Sphinx-style docstrings, we encourage     you to consult the official Sphinx documentation. </p>"},{"location":"contributing/#pre-submission-testing-and-validation","title":"Pre-Submission Testing and Validation","text":"<p>     \u2003\u2003Before submitting your pull request, it is crucial to ensure that your changes pass all the necessary     checks. To do so, simply run the following command: </p> <pre><code>hatch run tests:all\n</code></pre> <p>     \u2003\u2003The above command will trigger the Hatch project manager to initiate the comprehensive testing process     across all supported Python versions. It will run tests, perform typing checks, ensure code formatting, and measure     code coverage. This ensures that your changes meet the required quality standards. </p> <p>Testing for Individual Python Versions</p> <p><p>     If you want to test for specific Python versions, you can do so by specifying the desired versions in the      command, as follows: </p></p> Python 3.10Python 3.11 <pre><code>hatch run +py=3.10 tests:all\n</code></pre> <pre><code>hatch run +py=3.11 tests:all\n</code></pre> <p>Troubleshooting Hatch Environment Errors</p> <p><p>     If commands run successfully when executed manually but produce unexpected errors or misbehavior when run      within a Hatch environment, even though the dependencies are declared correctly, this could indicate an      issue with the Hatch environment cache. To resolve potential cache-related issues, you can remove the      environment and clear its cache by running: </p></p> <pre><code>hatch env remove [ENV_NAME]\n</code></pre> <p><p>     Alternatively, you can remove all environments and their cache by running the following command: </p></p> <pre><code>hatch env prune\n</code></pre>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>     \u2003\u2003This project and everyone participating in it is governed by the PyORlib Code of Conduct.      By participating, you are expected to uphold this code. Please report unacceptable behavior. </p>"},{"location":"contributing/#thanks-in-advance","title":"Thanks in Advance!","text":"<p>     \u2003\u2003Thank you for considering contributing to this project. Your contributions are valuable      and greatly appreciated. If you have any questions or need further clarification, please don't      hesitate to reach out. We look forward to collaborating with you to enhance this project! </p> <p></p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>     \u2003\u2003Welcome to the Getting Started section! This guide will help you install and configure PyORlib in your     optimization project. For more detailed information about the library, you can refer to the PyORlib      examples or API Reference. </p>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<p>     \u2003\u2003By default, PyORlib's core functionalities and optimization utilities only require Python 3.10+.      However, additional optional dependencies may be needed to work with optimization models and solver      integrations based on your use case. For more information on supported integrations, see the      Optional Dependencies section below. </p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>     \u2003\u2003PyORlib is available as a Python package and can be easily installed using <code>pip</code>. To install the core      functionalities, open your terminal and execute the following command: </p> <pre><code>pip install pyorlib\n</code></pre>"},{"location":"getting-started/#optional-dependencies","title":"Optional Dependencies","text":"<p>     \u2003\u2003While PyORlib's core functionality relies primarily on Python's standard library, the package is      designed from the ground up to seamlessly integrate with popular solvers through a modular and unified API. </p> Solver License Notice <p>     \u2003\u2003PyORlib integrates with solvers through their Python APIs but does not bundle the solvers      themselves. Access to solvers is governed by individual licenses and requirements set by each provider.      Please check the solver documentation for details on installation, configuration and licensing. </p>"},{"location":"getting-started/#supported-solver-integrations","title":"Supported Solver Integrations","text":"<ul> <li> CPLEX \u2500  PyORlib integrates with the powerful CPLEX solver through the <code>CplexEngine</code>  interface. This integration allows you to optimize models using CPLEX's advanced algorithms and features. To install  PyORlib with CPLEX support, please use the following command:  <pre><code>pip install pyorlib[cplex]\n</code></pre> </li> <li> Gurobi \u2500  PyORlib integrates with Gurobi, a powerful solver renowned for its high-performance optimization capabilities, through the <code>GurobiEngine</code> interface. This integration enables efficient optimization of models using Gurobi's advanced algorithms and features. To install PyORlib with Gurobi support, use the following command:  <pre><code>pip install pyorlib[gurobi]\n</code></pre> </li> <li> OR-Tools \u2500  PyORlib integrates with OR-Tools through the <code>ORToolsEngine</code> interface. This enables efficient optimization of linear and integer programming models using OR-Tools' advanced algorithms. To install  PyORlib with OR-Tools support, use:  <pre><code>pip install pyorlib[ortools]\n</code></pre> </li> <li> PuLP \u2500  PyORlib integrates with PuLP through the <code>PuLPEngine</code> interface. This enables optimization of models using PuLP's Python modeling language and interface to various solvers. To install PyORlib with PuLP support, use:  <pre><code>pip install pyorlib[pulp]\n</code></pre> </li> </ul> <p>You can install all of them with:</p> <pre><code>pip install pyorlib[all]\n</code></pre> <p></p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#0.1.3","title":"v0.1.3 July 30, 2025","text":""},{"location":"release-notes/#changed","title":"Changed","text":"<ul> <li>Updated the lower bound variable definition in <code>pulp_engine</code> to set it to <code>None</code> when <code>-inf</code> is specified as the lower bound.</li> </ul>"},{"location":"release-notes/#fixed","title":"Fixed","text":"<ul> <li>Updated deprecated <code>_pytest.python_api.raises</code> imports in several tests.</li> </ul>"},{"location":"release-notes/#0.1.2","title":"v0.1.2 April 9, 2024","text":""},{"location":"release-notes/#changed_1","title":"Changed","text":"<ul> <li>Upgraded the <code>Setup-Python</code> GitHub Action from version 4 to version 5 in all workflows.</li> <li>Updated the <code>index.md</code> page with a welcome title.</li> <li>Updated the <code>mkdocs.yml</code> config file with the <code>mkdocs social cards</code> plugin.</li> <li>Updated the <code>pyproject.toml</code> config file with the necessary dependencies for the <code>mkdocs social cards</code> plugin.</li> </ul>"},{"location":"release-notes/#fixed_1","title":"Fixed","text":"<ul> <li>Resolved the <code>mathjax.js</code> config file path error in the documentation.</li> </ul>"},{"location":"release-notes/#0.1.1","title":"v0.1.1 March 2, 2024","text":""},{"location":"release-notes/#changed_2","title":"Changed","text":"<ul> <li>The <code>print_info</code> and <code>print_solution</code> methods in the <code>Model</code> class have been enhanced to improve visibility and   provide deeper insights.</li> <li>The <code>get_pretty_string</code> method in the <code>Term</code> class has been refactored as an <code>@abstractmethod</code> for subclass   customization.</li> <li>Badges on the main page of the documentation and the readme file have been updated to improve visibility and align   with the package's color palette.</li> <li>The <code>git-committers</code> plugin in the <code>mkdocs.yml</code> file has been updated to exclude the <code>index.md</code>, <code>examples/index.md</code>,   and <code>api/index.md</code> files for consistency in the current configuration with the <code>git-revision-date-localized</code> plugin.</li> </ul>"},{"location":"release-notes/#0.1.0","title":"v0.1.0 March 2, 2024","text":""},{"location":"release-notes/#initial-implementation","title":"Initial Implementation","text":"<p>\u2003\u2003This release introduces the initial version of PyORlib, a powerful Python library for operations research and optimization. PyORlib provides a set of abstractions to easily define, solve, and interact with mathematical models in a standardized manner across different optimization packages. It serves as a user-friendly and powerful platform for students, researchers, and practitioners to explore optimization concepts, experiment with algorithms, and expand their knowledge.</p> <ul> <li>Implementation Details: The first implementation includes all the core functionalities of the package,   encompassing built-in optimization package integrations, algebraic modeling, validators, and more.</li> <li>Testing and Coverage: This release includes a test suite that verifies the correctness of the package   implementation. It also integrates code coverage, achieving 100% test coverage. The tests are configured to run   automatically via GitHub Actions on both push and pull requests to the master branch.</li> <li>Formatter and Lint Configuration: A formatter and lint configuration have been added to the project. This ensures   consistent code style, maintainability, and adherence to the established coding standards defined in the project   documentation.</li> <li>Documentation: Additionally, this release includes comprehensive documentation for the package. The documentation   covers the main page, a detailed getting started guide, examples, API reference, and release notes.</li> </ul> <p></p>"},{"location":"api/","title":"API Reference","text":"<p>     \u2003\u2003Welcome to the PyORlib API Reference, a comprehensive guide that provides detailed information about     the classes, functions, parameters, attributes, and other components available in PyORlib. </p> <p>     \u2003\u2003In the API Reference, you will find detailed documentation for each component, including clear explanations,     parameter details, return values, and usage examples. You can navigate through the reference using the search     functionality or by browsing the different sections and categories to find the specific information you need. </p> <p> </p> <p> Let's explore the PyORlib API Reference! </p> <p></p>"},{"location":"api/algebra/","title":"<code>Algebra</code> module","text":"<p>The Algebra module in PyORlib provides a set of classes and functions for algebraic operations and mathematical expressions used in optimization models.</p> <p></p>"},{"location":"api/algebra/element/","title":"<code>Element</code> class","text":"<p>               Bases: <code>ABC</code></p> <p>Base class representing a mathematical element.</p> <p>The <code>Element</code> class serves as the global interface for mathematical entities. Subclasses should inherit from this class and implement the required methods.</p> <p>Note: The supported mathematical operations on an <code>Element</code> instance depend on the specific entity being represented. These operations can include arithmetic operations, functions, and any other operations defined by the underlying mathematical element.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>class Element(ABC):\n    \"\"\"\n    Base class representing a mathematical element.\n\n    The `Element` class serves as the global interface for mathematical entities.\n    Subclasses should inherit from this class and implement the required methods.\n\n    **Note**: The supported mathematical operations on an `Element` instance depend on the\n    specific entity being represented. These operations can include arithmetic operations,\n    functions, and any other operations defined by the underlying mathematical element.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def raw(self) -&gt; Any:\n        \"\"\"\n        Returns the raw representation of the mathematical element.\n\n        The `raw` method, when implemented by subclasses, returns the mathematical element in its raw format.\n        The raw format can take various forms, such as an expression used by solvers or engines, or a\n        mathematical expression that represents the entity itself.\n        :return: The raw representation of the mathematical element.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _build_expression(self, expression: Any) -&gt; \"Element\":\n        \"\"\"\n        Abstract method to build an Element object based on the given expression.\n\n        This method is used to implement how an `Element` object is built based on the result of a Python magic\n        method operation. It handles the construction of a new `Element` instance using the given expression,\n        which represents the result of the operation. This method is used in the normal magic methods for\n        mathematical operations, as well as the `right` methods and comparison methods. However, it\n        excludes the in-place methods, as their behavior depends on whether they build another\n        expression or modify the same expression.\n\n        :param expression: The expression representing the result of the Python magic method operation.\n        :return: A new `Element` instance representing the built expression.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the element.\n        :return: A string representation of the element.\n        \"\"\"\n        pass\n\n    # Addition\n    def __add__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Addition operation.\n        :param other: The `number` or `Element` instance to be added.\n        :return: A new `Element` instance representing the addition.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw + other.raw)\n        else:\n            return self._build_expression(expression=self.raw + other)\n\n    def __radd__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Right addition operation.\n        :param other: The `number` or `Element` instance to be added.\n        :return: A new `Element` instance representing the addition.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=other.raw + self.raw)\n        else:\n            return self._build_expression(expression=other + self.raw)\n\n    @abstractmethod\n    def __iadd__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        In-place addition operation.\n        :param other: The `number` or `Element` instance to be added.\n        :return: The updated Element instance after addition.\n        \"\"\"\n        pass\n\n    # Subtraction\n    def __sub__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Subtraction operation.\n        :param other: The `number` or `Element` instance to be subtracted.\n        :return: A new `Element` instance representing the subtraction.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw - other.raw)\n        else:\n            return self._build_expression(expression=self.raw - other)\n\n    def __rsub__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Right subtraction operation.\n        :param other: The `number` or `Element` instance to be subtracted.\n        :return: A new `Element` instance representing the subtraction.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=other.raw - self.raw)\n        else:\n            return self._build_expression(expression=other - self.raw)\n\n    @abstractmethod\n    def __isub__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        In-place subtraction operation.\n        :param other: The `number` or `Element` instance to be subtracted.\n        :return: The new/updated `Element` instance after subtraction.\n        \"\"\"\n        pass\n\n    # Multiplication\n    def __mul__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Multiplication operation.\n        :param other: The `number` or `Element` instance to be multiplied.\n        :return: A new `Element` instance representing the multiplication.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw * other.raw)\n        else:\n            return self._build_expression(expression=self.raw * other)\n\n    def __rmul__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Right multiplication operation.\n        :param other: The `number` or `Element` instance to be multiplied.\n        :return: A new `Element` instance representing the multiplication.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=other.raw * self.raw)\n        else:\n            return self._build_expression(expression=other * self.raw)\n\n    @abstractmethod\n    def __imul__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        In-place multiplication operation.\n        :param other: The `number` or `Element` instance to be multiplied.\n        :return: The new/updated `Element` instance after multiplication.\n        \"\"\"\n        pass\n\n    # Division\n    def __truediv__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Division operation.\n        :param other: The `number` or `Element` instance to be divided.\n        :return: A new `Element` instance representing the division.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw / other.raw)\n        else:\n            return self._build_expression(expression=self.raw / other)\n\n    def __rtruediv__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Right division operation.\n        :param other: The `number` or `Element` instance to be divided.\n        :return: A new `Element` instance representing the division.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=other.raw / self.raw)\n        else:\n            return self._build_expression(expression=other / self.raw)\n\n    @abstractmethod\n    def __itruediv__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        In-place division operation.\n        :param other: The `number` or `Element` instance to be divided.\n        :return: The new/updated `Element` instance after division.\n        \"\"\"\n        pass\n\n    # Floor Division\n    def __floordiv__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Floor division operation.\n        :param other: The `number` or `Element` instance to be floor divided.\n        :return: A new `Element` instance representing the floor division.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw // other.raw)\n        else:\n            return self._build_expression(expression=self.raw // other)\n\n    def __rfloordiv__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Right floor division operation.\n        :param other: The `number` or `Element` instance to be floor divided.\n        :return: A new `Element` instance representing the floor division.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=other.raw // self.raw)\n        else:\n            return self._build_expression(expression=other // self.raw)\n\n    @abstractmethod\n    def __ifloordiv__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        In-place floor division operation.\n        :param other: The `number` or `Element` instance to be floor divided.\n        :return: The new/updated `Element` instance after floor division.\n        \"\"\"\n        pass\n\n    # Modulo\n    def __mod__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Modulo operation.\n        :param other: The `number` or `Element` instance to be used for modulo.\n        :return: A new `Element` instance representing the modulo operation.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw % other.raw)\n        else:\n            return self._build_expression(expression=self.raw % other)\n\n    def __rmod__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Right modulo operation.\n        :param other: The `number` or `Element` instance to be used for modulo.\n        :return: A new `Element` instance representing the modulo operation.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=other.raw % self.raw)\n        else:\n            return self._build_expression(expression=other % self.raw)\n\n    @abstractmethod\n    def __imod__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        In-place modulo operation.\n        :param other: The `number` or `Element` instance to be used for modulo.\n        :return: The new/updated `Element` instance after modulo operation.\n        \"\"\"\n        pass\n\n    # Exponentiation\n    def __pow__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Exponentiation operation.\n        :param other: The `number` or `Element` instance to be used as the exponent.\n        :return: A new `Element` instance representing the exponentiation.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw**other.raw)\n        else:\n            return self._build_expression(expression=self.raw**other)\n\n    def __rpow__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Right exponentiation operation.\n        :param other: The `number` or `Element` instance to be used as the base.\n        :return: A new `Element` instance representing the exponentiation.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=other.raw**self.raw)\n        else:\n            return self._build_expression(expression=other**self.raw)\n\n    @abstractmethod\n    def __ipow__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        In-place exponentiation operation.\n        :param other: The `number` or `Element` instance to be used as the exponent.\n        :return: The new/updated `Element` instance after exponentiation.\n        \"\"\"\n        pass\n\n    # Unary Operators\n    def __neg__(self) -&gt; \"Element\":\n        \"\"\"\n        Negation operation.\n        :return: A new `Element` instance representing the negation.\n        \"\"\"\n        return self._build_expression(expression=-self.raw)\n\n    def __pos__(self) -&gt; \"Element\":\n        \"\"\"\n        Positive operation.\n        :return: A new `Element` instance representing the positive value.\n        \"\"\"\n        return self._build_expression(expression=+self.raw)\n\n    def __abs__(self) -&gt; \"Element\":\n        \"\"\"\n        Absolute value operation.\n        :return: A new `Element` instance representing the absolute value.\n        \"\"\"\n        return self._build_expression(expression=abs(self.raw))\n\n    # Comparison Methods\n    def __eq__(self, other: Any) -&gt; \"Element\":  # type: ignore[override]\n        \"\"\"\n        Equal to comparison.\n        :param other: The `number` or `Element` instance to be compared.\n        :return: A new `Element` instance representing the comparison result.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw == other.raw)\n        else:\n            return self._build_expression(expression=self.raw == other)\n\n    def __ne__(self, other: Any) -&gt; \"Element\":  # type: ignore[override]\n        \"\"\"\n        Not equal to comparison.\n        :param other: The `number` or `Element` instance to be compared.\n        :return: A new `Element` instance representing the comparison result.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw != other.raw)\n        else:\n            return self._build_expression(expression=self.raw != other)\n\n    def __lt__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Less than comparison.\n        :param other: The `number` or `Element` instance to be compared.\n        :return: A new `Element` instance representing the comparison result.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw &lt; other.raw)\n        else:\n            return self._build_expression(expression=self.raw &lt; other)\n\n    def __le__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Less than or equal to comparison.\n        :param other: The `number` or `Element` instance to be compared.\n        :return: A new `Element` instance representing the comparison result.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw &lt;= other.raw)\n        else:\n            return self._build_expression(expression=self.raw &lt;= other)\n\n    def __gt__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Greater than comparison.\n        :param other: The `number` or `Element` instance to be compared.\n        :return: A new `Element` instance representing the comparison result.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw &gt; other.raw)\n        else:\n            return self._build_expression(expression=self.raw &gt; other)\n\n    def __ge__(self, other: Any) -&gt; \"Element\":\n        \"\"\"\n        Greater than or equal to comparison.\n        :param other: The `number` or `Element` instance to be compared.\n        :return: A new `Element` instance representing the comparison result.\n        \"\"\"\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw &gt;= other.raw)\n        else:\n            return self._build_expression(expression=self.raw &gt;= other)\n</code></pre> <p></p>"},{"location":"api/algebra/element/#pyorlib.algebra.Element-attributes","title":"Attributes","text":""},{"location":"api/algebra/element/#pyorlib.algebra.Element.raw","title":"raw  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>raw: Any\n</code></pre> <p>Returns the raw representation of the mathematical element.</p> <p>The <code>raw</code> method, when implemented by subclasses, returns the mathematical element in its raw format. The raw format can take various forms, such as an expression used by solvers or engines, or a mathematical expression that represents the entity itself.</p> RETURNS DESCRIPTION <code>Any</code> <p>The raw representation of the mathematical element.</p>"},{"location":"api/algebra/element/#pyorlib.algebra.Element-functions","title":"Functions","text":""},{"location":"api/algebra/element/#pyorlib.algebra.Element.__add__","title":"__add__","text":"<pre><code>__add__(other: Any) -&gt; Element\n</code></pre> <p>Addition operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be added.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the addition.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __add__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Addition operation.\n    :param other: The `number` or `Element` instance to be added.\n    :return: A new `Element` instance representing the addition.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw + other.raw)\n    else:\n        return self._build_expression(expression=self.raw + other)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__radd__","title":"__radd__","text":"<pre><code>__radd__(other: Any) -&gt; Element\n</code></pre> <p>Right addition operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be added.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the addition.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __radd__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right addition operation.\n    :param other: The `number` or `Element` instance to be added.\n    :return: A new `Element` instance representing the addition.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw + self.raw)\n    else:\n        return self._build_expression(expression=other + self.raw)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__iadd__","title":"__iadd__  <code>abstractmethod</code>","text":"<pre><code>__iadd__(other: Any) -&gt; Element\n</code></pre> <p>In-place addition operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be added.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>The updated Element instance after addition.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>@abstractmethod\ndef __iadd__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    In-place addition operation.\n    :param other: The `number` or `Element` instance to be added.\n    :return: The updated Element instance after addition.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Any) -&gt; Element\n</code></pre> <p>Subtraction operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be subtracted.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the subtraction.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __sub__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Subtraction operation.\n    :param other: The `number` or `Element` instance to be subtracted.\n    :return: A new `Element` instance representing the subtraction.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw - other.raw)\n    else:\n        return self._build_expression(expression=self.raw - other)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other: Any) -&gt; Element\n</code></pre> <p>Right subtraction operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be subtracted.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the subtraction.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rsub__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right subtraction operation.\n    :param other: The `number` or `Element` instance to be subtracted.\n    :return: A new `Element` instance representing the subtraction.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw - self.raw)\n    else:\n        return self._build_expression(expression=other - self.raw)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__isub__","title":"__isub__  <code>abstractmethod</code>","text":"<pre><code>__isub__(other: Any) -&gt; Element\n</code></pre> <p>In-place subtraction operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be subtracted.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>The new/updated <code>Element</code> instance after subtraction.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>@abstractmethod\ndef __isub__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    In-place subtraction operation.\n    :param other: The `number` or `Element` instance to be subtracted.\n    :return: The new/updated `Element` instance after subtraction.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: Any) -&gt; Element\n</code></pre> <p>Multiplication operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be multiplied.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the multiplication.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __mul__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Multiplication operation.\n    :param other: The `number` or `Element` instance to be multiplied.\n    :return: A new `Element` instance representing the multiplication.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw * other.raw)\n    else:\n        return self._build_expression(expression=self.raw * other)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other: Any) -&gt; Element\n</code></pre> <p>Right multiplication operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be multiplied.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the multiplication.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rmul__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right multiplication operation.\n    :param other: The `number` or `Element` instance to be multiplied.\n    :return: A new `Element` instance representing the multiplication.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw * self.raw)\n    else:\n        return self._build_expression(expression=other * self.raw)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__imul__","title":"__imul__  <code>abstractmethod</code>","text":"<pre><code>__imul__(other: Any) -&gt; Element\n</code></pre> <p>In-place multiplication operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be multiplied.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>The new/updated <code>Element</code> instance after multiplication.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>@abstractmethod\ndef __imul__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    In-place multiplication operation.\n    :param other: The `number` or `Element` instance to be multiplied.\n    :return: The new/updated `Element` instance after multiplication.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: Any) -&gt; Element\n</code></pre> <p>Division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __truediv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Division operation.\n    :param other: The `number` or `Element` instance to be divided.\n    :return: A new `Element` instance representing the division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw / other.raw)\n    else:\n        return self._build_expression(expression=self.raw / other)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__rtruediv__","title":"__rtruediv__","text":"<pre><code>__rtruediv__(other: Any) -&gt; Element\n</code></pre> <p>Right division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rtruediv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right division operation.\n    :param other: The `number` or `Element` instance to be divided.\n    :return: A new `Element` instance representing the division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw / self.raw)\n    else:\n        return self._build_expression(expression=other / self.raw)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__itruediv__","title":"__itruediv__  <code>abstractmethod</code>","text":"<pre><code>__itruediv__(other: Any) -&gt; Element\n</code></pre> <p>In-place division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>The new/updated <code>Element</code> instance after division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>@abstractmethod\ndef __itruediv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    In-place division operation.\n    :param other: The `number` or `Element` instance to be divided.\n    :return: The new/updated `Element` instance after division.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__floordiv__","title":"__floordiv__","text":"<pre><code>__floordiv__(other: Any) -&gt; Element\n</code></pre> <p>Floor division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be floor divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the floor division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __floordiv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Floor division operation.\n    :param other: The `number` or `Element` instance to be floor divided.\n    :return: A new `Element` instance representing the floor division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw // other.raw)\n    else:\n        return self._build_expression(expression=self.raw // other)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__rfloordiv__","title":"__rfloordiv__","text":"<pre><code>__rfloordiv__(other: Any) -&gt; Element\n</code></pre> <p>Right floor division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be floor divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the floor division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rfloordiv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right floor division operation.\n    :param other: The `number` or `Element` instance to be floor divided.\n    :return: A new `Element` instance representing the floor division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw // self.raw)\n    else:\n        return self._build_expression(expression=other // self.raw)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__ifloordiv__","title":"__ifloordiv__  <code>abstractmethod</code>","text":"<pre><code>__ifloordiv__(other: Any) -&gt; Element\n</code></pre> <p>In-place floor division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be floor divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>The new/updated <code>Element</code> instance after floor division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>@abstractmethod\ndef __ifloordiv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    In-place floor division operation.\n    :param other: The `number` or `Element` instance to be floor divided.\n    :return: The new/updated `Element` instance after floor division.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: Any) -&gt; Element\n</code></pre> <p>Modulo operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used for modulo.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the modulo operation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __mod__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Modulo operation.\n    :param other: The `number` or `Element` instance to be used for modulo.\n    :return: A new `Element` instance representing the modulo operation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw % other.raw)\n    else:\n        return self._build_expression(expression=self.raw % other)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__rmod__","title":"__rmod__","text":"<pre><code>__rmod__(other: Any) -&gt; Element\n</code></pre> <p>Right modulo operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used for modulo.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the modulo operation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rmod__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right modulo operation.\n    :param other: The `number` or `Element` instance to be used for modulo.\n    :return: A new `Element` instance representing the modulo operation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw % self.raw)\n    else:\n        return self._build_expression(expression=other % self.raw)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__imod__","title":"__imod__  <code>abstractmethod</code>","text":"<pre><code>__imod__(other: Any) -&gt; Element\n</code></pre> <p>In-place modulo operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used for modulo.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>The new/updated <code>Element</code> instance after modulo operation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>@abstractmethod\ndef __imod__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    In-place modulo operation.\n    :param other: The `number` or `Element` instance to be used for modulo.\n    :return: The new/updated `Element` instance after modulo operation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__pow__","title":"__pow__","text":"<pre><code>__pow__(other: Any) -&gt; Element\n</code></pre> <p>Exponentiation operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used as the exponent.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the exponentiation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __pow__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Exponentiation operation.\n    :param other: The `number` or `Element` instance to be used as the exponent.\n    :return: A new `Element` instance representing the exponentiation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw**other.raw)\n    else:\n        return self._build_expression(expression=self.raw**other)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__rpow__","title":"__rpow__","text":"<pre><code>__rpow__(other: Any) -&gt; Element\n</code></pre> <p>Right exponentiation operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used as the base.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the exponentiation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rpow__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right exponentiation operation.\n    :param other: The `number` or `Element` instance to be used as the base.\n    :return: A new `Element` instance representing the exponentiation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw**self.raw)\n    else:\n        return self._build_expression(expression=other**self.raw)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__ipow__","title":"__ipow__  <code>abstractmethod</code>","text":"<pre><code>__ipow__(other: Any) -&gt; Element\n</code></pre> <p>In-place exponentiation operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used as the exponent.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>The new/updated <code>Element</code> instance after exponentiation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>@abstractmethod\ndef __ipow__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    In-place exponentiation operation.\n    :param other: The `number` or `Element` instance to be used as the exponent.\n    :return: The new/updated `Element` instance after exponentiation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Element\n</code></pre> <p>Negation operation.</p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the negation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __neg__(self) -&gt; \"Element\":\n    \"\"\"\n    Negation operation.\n    :return: A new `Element` instance representing the negation.\n    \"\"\"\n    return self._build_expression(expression=-self.raw)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Element\n</code></pre> <p>Positive operation.</p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the positive value.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __pos__(self) -&gt; \"Element\":\n    \"\"\"\n    Positive operation.\n    :return: A new `Element` instance representing the positive value.\n    \"\"\"\n    return self._build_expression(expression=+self.raw)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Element\n</code></pre> <p>Absolute value operation.</p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the absolute value.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __abs__(self) -&gt; \"Element\":\n    \"\"\"\n    Absolute value operation.\n    :return: A new `Element` instance representing the absolute value.\n    \"\"\"\n    return self._build_expression(expression=abs(self.raw))\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; Element\n</code></pre> <p>Equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __eq__(self, other: Any) -&gt; \"Element\":  # type: ignore[override]\n    \"\"\"\n    Equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw == other.raw)\n    else:\n        return self._build_expression(expression=self.raw == other)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__ne__","title":"__ne__","text":"<pre><code>__ne__(other: Any) -&gt; Element\n</code></pre> <p>Not equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __ne__(self, other: Any) -&gt; \"Element\":  # type: ignore[override]\n    \"\"\"\n    Not equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw != other.raw)\n    else:\n        return self._build_expression(expression=self.raw != other)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Any) -&gt; Element\n</code></pre> <p>Less than comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __lt__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Less than comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &lt; other.raw)\n    else:\n        return self._build_expression(expression=self.raw &lt; other)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__le__","title":"__le__","text":"<pre><code>__le__(other: Any) -&gt; Element\n</code></pre> <p>Less than or equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __le__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Less than or equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &lt;= other.raw)\n    else:\n        return self._build_expression(expression=self.raw &lt;= other)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Any) -&gt; Element\n</code></pre> <p>Greater than comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __gt__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Greater than comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &gt; other.raw)\n    else:\n        return self._build_expression(expression=self.raw &gt; other)\n</code></pre>"},{"location":"api/algebra/element/#pyorlib.algebra.Element.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Any) -&gt; Element\n</code></pre> <p>Greater than or equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __ge__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Greater than or equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &gt;= other.raw)\n    else:\n        return self._build_expression(expression=self.raw &gt;= other)\n</code></pre>"},{"location":"api/algebra/expressions/","title":"<code>Expression</code> class","text":"<p>               Bases: <code>Element</code></p> <p>Represents a mathematical expression used to encapsulate expressions in an optimization model.</p> <p>The <code>Expression</code> class is a subclass of the <code>Element</code> class and serves as a representation of a mathematical expression within an optimization model. It is specifically designed to encapsulate expressions and offers methods for performing various mathematical operations on those expressions.</p> <p>Note: The supported mathematical operations on an <code>Expression</code> instance depend on the operations supported in the encapsulated expression. These operations can include arithmetic operations, functions, and any other operations defined by the underlying mathematical expression.</p> Source code in <code>pyorlib/algebra/expressions/expression.py</code> <pre><code>class Expression(Element):\n    \"\"\"\n    Represents a mathematical expression used to encapsulate expressions in an optimization model.\n\n    The `Expression` class is a subclass of the `Element` class and serves as a representation of a mathematical\n    expression within an optimization model. It is specifically designed to encapsulate expressions and offers\n    methods for performing various mathematical operations on those expressions.\n\n    **Note**: The supported mathematical operations on an `Expression` instance depend on the operations supported\n    in the encapsulated expression. These operations can include arithmetic operations, functions, and\n    any other operations defined by the underlying mathematical expression.\n    \"\"\"\n\n    @property\n    def raw(self) -&gt; Any:\n        return self.__expression\n\n    def __init__(self, expression: Any):\n        \"\"\"\n        Initialize an Expression instance.\n        :param expression: The expression value to be encapsulated.\n        :raises ValueError: If the expression is None.\n        \"\"\"\n        # Applies validations\n        if expression is None:\n            raise ValueError(\"Expression cannot be None\")\n\n        # Instance attributes\n        self.__expression: Any = expression\n        \"\"\" The mathematical expression. \"\"\"\n\n    def _build_expression(self, expression: Any) -&gt; Element:\n        return Expression(expression=expression)\n\n    def __str__(self) -&gt; str:\n        return str(self.raw)\n\n    def __iadd__(self, other: Any) -&gt; Element:\n        if isinstance(other, Element):\n            self.__expression += other.raw\n        else:\n            self.__expression += other\n        return self\n\n    def __isub__(self, other: Any) -&gt; Element:\n        if isinstance(other, Element):\n            self.__expression -= other.raw\n        else:\n            self.__expression -= other\n        return self\n\n    def __imul__(self, other: Any) -&gt; Element:\n        if isinstance(other, Element):\n            self.__expression *= other.raw\n        else:\n            self.__expression *= other\n        return self\n\n    def __itruediv__(self, other: Any) -&gt; Element:\n        if isinstance(other, Element):\n            self.__expression /= other.raw\n        else:\n            self.__expression /= other\n        return self\n\n    def __ifloordiv__(self, other: Any) -&gt; Element:\n        if isinstance(other, Element):\n            self.__expression //= other.raw\n        else:\n            self.__expression //= other\n        return self\n\n    def __imod__(self, other: Any) -&gt; Element:\n        if isinstance(other, Element):\n            self.__expression %= other.raw\n        else:\n            self.__expression %= other\n        return self\n\n    def __ipow__(self, other: Any) -&gt; Element:\n        if isinstance(other, Element):\n            self.__expression **= other.raw\n        else:\n            self.__expression **= other\n        return self\n</code></pre> <p></p>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression-attributes","title":"Attributes","text":""},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.raw","title":"raw  <code>property</code>","text":"<pre><code>raw: Any\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression-functions","title":"Functions","text":""},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__add__","title":"__add__","text":"<pre><code>__add__(other: Any) -&gt; Element\n</code></pre> <p>Addition operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be added.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the addition.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __add__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Addition operation.\n    :param other: The `number` or `Element` instance to be added.\n    :return: A new `Element` instance representing the addition.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw + other.raw)\n    else:\n        return self._build_expression(expression=self.raw + other)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__radd__","title":"__radd__","text":"<pre><code>__radd__(other: Any) -&gt; Element\n</code></pre> <p>Right addition operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be added.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the addition.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __radd__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right addition operation.\n    :param other: The `number` or `Element` instance to be added.\n    :return: A new `Element` instance representing the addition.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw + self.raw)\n    else:\n        return self._build_expression(expression=other + self.raw)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Any) -&gt; Element\n</code></pre> <p>Subtraction operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be subtracted.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the subtraction.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __sub__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Subtraction operation.\n    :param other: The `number` or `Element` instance to be subtracted.\n    :return: A new `Element` instance representing the subtraction.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw - other.raw)\n    else:\n        return self._build_expression(expression=self.raw - other)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other: Any) -&gt; Element\n</code></pre> <p>Right subtraction operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be subtracted.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the subtraction.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rsub__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right subtraction operation.\n    :param other: The `number` or `Element` instance to be subtracted.\n    :return: A new `Element` instance representing the subtraction.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw - self.raw)\n    else:\n        return self._build_expression(expression=other - self.raw)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: Any) -&gt; Element\n</code></pre> <p>Multiplication operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be multiplied.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the multiplication.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __mul__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Multiplication operation.\n    :param other: The `number` or `Element` instance to be multiplied.\n    :return: A new `Element` instance representing the multiplication.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw * other.raw)\n    else:\n        return self._build_expression(expression=self.raw * other)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other: Any) -&gt; Element\n</code></pre> <p>Right multiplication operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be multiplied.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the multiplication.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rmul__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right multiplication operation.\n    :param other: The `number` or `Element` instance to be multiplied.\n    :return: A new `Element` instance representing the multiplication.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw * self.raw)\n    else:\n        return self._build_expression(expression=other * self.raw)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: Any) -&gt; Element\n</code></pre> <p>Division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __truediv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Division operation.\n    :param other: The `number` or `Element` instance to be divided.\n    :return: A new `Element` instance representing the division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw / other.raw)\n    else:\n        return self._build_expression(expression=self.raw / other)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__rtruediv__","title":"__rtruediv__","text":"<pre><code>__rtruediv__(other: Any) -&gt; Element\n</code></pre> <p>Right division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rtruediv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right division operation.\n    :param other: The `number` or `Element` instance to be divided.\n    :return: A new `Element` instance representing the division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw / self.raw)\n    else:\n        return self._build_expression(expression=other / self.raw)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__floordiv__","title":"__floordiv__","text":"<pre><code>__floordiv__(other: Any) -&gt; Element\n</code></pre> <p>Floor division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be floor divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the floor division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __floordiv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Floor division operation.\n    :param other: The `number` or `Element` instance to be floor divided.\n    :return: A new `Element` instance representing the floor division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw // other.raw)\n    else:\n        return self._build_expression(expression=self.raw // other)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__rfloordiv__","title":"__rfloordiv__","text":"<pre><code>__rfloordiv__(other: Any) -&gt; Element\n</code></pre> <p>Right floor division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be floor divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the floor division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rfloordiv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right floor division operation.\n    :param other: The `number` or `Element` instance to be floor divided.\n    :return: A new `Element` instance representing the floor division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw // self.raw)\n    else:\n        return self._build_expression(expression=other // self.raw)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: Any) -&gt; Element\n</code></pre> <p>Modulo operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used for modulo.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the modulo operation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __mod__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Modulo operation.\n    :param other: The `number` or `Element` instance to be used for modulo.\n    :return: A new `Element` instance representing the modulo operation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw % other.raw)\n    else:\n        return self._build_expression(expression=self.raw % other)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__rmod__","title":"__rmod__","text":"<pre><code>__rmod__(other: Any) -&gt; Element\n</code></pre> <p>Right modulo operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used for modulo.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the modulo operation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rmod__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right modulo operation.\n    :param other: The `number` or `Element` instance to be used for modulo.\n    :return: A new `Element` instance representing the modulo operation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw % self.raw)\n    else:\n        return self._build_expression(expression=other % self.raw)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__pow__","title":"__pow__","text":"<pre><code>__pow__(other: Any) -&gt; Element\n</code></pre> <p>Exponentiation operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used as the exponent.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the exponentiation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __pow__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Exponentiation operation.\n    :param other: The `number` or `Element` instance to be used as the exponent.\n    :return: A new `Element` instance representing the exponentiation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw**other.raw)\n    else:\n        return self._build_expression(expression=self.raw**other)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__rpow__","title":"__rpow__","text":"<pre><code>__rpow__(other: Any) -&gt; Element\n</code></pre> <p>Right exponentiation operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used as the base.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the exponentiation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rpow__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right exponentiation operation.\n    :param other: The `number` or `Element` instance to be used as the base.\n    :return: A new `Element` instance representing the exponentiation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw**self.raw)\n    else:\n        return self._build_expression(expression=other**self.raw)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Element\n</code></pre> <p>Negation operation.</p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the negation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __neg__(self) -&gt; \"Element\":\n    \"\"\"\n    Negation operation.\n    :return: A new `Element` instance representing the negation.\n    \"\"\"\n    return self._build_expression(expression=-self.raw)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Element\n</code></pre> <p>Positive operation.</p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the positive value.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __pos__(self) -&gt; \"Element\":\n    \"\"\"\n    Positive operation.\n    :return: A new `Element` instance representing the positive value.\n    \"\"\"\n    return self._build_expression(expression=+self.raw)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Element\n</code></pre> <p>Absolute value operation.</p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the absolute value.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __abs__(self) -&gt; \"Element\":\n    \"\"\"\n    Absolute value operation.\n    :return: A new `Element` instance representing the absolute value.\n    \"\"\"\n    return self._build_expression(expression=abs(self.raw))\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; Element\n</code></pre> <p>Equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __eq__(self, other: Any) -&gt; \"Element\":  # type: ignore[override]\n    \"\"\"\n    Equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw == other.raw)\n    else:\n        return self._build_expression(expression=self.raw == other)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__ne__","title":"__ne__","text":"<pre><code>__ne__(other: Any) -&gt; Element\n</code></pre> <p>Not equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __ne__(self, other: Any) -&gt; \"Element\":  # type: ignore[override]\n    \"\"\"\n    Not equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw != other.raw)\n    else:\n        return self._build_expression(expression=self.raw != other)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Any) -&gt; Element\n</code></pre> <p>Less than comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __lt__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Less than comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &lt; other.raw)\n    else:\n        return self._build_expression(expression=self.raw &lt; other)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__le__","title":"__le__","text":"<pre><code>__le__(other: Any) -&gt; Element\n</code></pre> <p>Less than or equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __le__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Less than or equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &lt;= other.raw)\n    else:\n        return self._build_expression(expression=self.raw &lt;= other)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Any) -&gt; Element\n</code></pre> <p>Greater than comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __gt__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Greater than comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &gt; other.raw)\n    else:\n        return self._build_expression(expression=self.raw &gt; other)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Any) -&gt; Element\n</code></pre> <p>Greater than or equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __ge__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Greater than or equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &gt;= other.raw)\n    else:\n        return self._build_expression(expression=self.raw &gt;= other)\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__init__","title":"__init__","text":"<pre><code>__init__(expression: Any)\n</code></pre> <p>Initialize an Expression instance.</p> PARAMETER DESCRIPTION <code>expression</code> <p>The expression value to be encapsulated.</p> <p> TYPE: <code>Any</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the expression is None.</p> Source code in <code>pyorlib/algebra/expressions/expression.py</code> <pre><code>def __init__(self, expression: Any):\n    \"\"\"\n    Initialize an Expression instance.\n    :param expression: The expression value to be encapsulated.\n    :raises ValueError: If the expression is None.\n    \"\"\"\n    # Applies validations\n    if expression is None:\n        raise ValueError(\"Expression cannot be None\")\n\n    # Instance attributes\n    self.__expression: Any = expression\n    \"\"\" The mathematical expression. \"\"\"\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/expressions/expression.py</code> <pre><code>def __iadd__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        self.__expression += other.raw\n    else:\n        self.__expression += other\n    return self\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__isub__","title":"__isub__","text":"<pre><code>__isub__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/expressions/expression.py</code> <pre><code>def __isub__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        self.__expression -= other.raw\n    else:\n        self.__expression -= other\n    return self\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__imul__","title":"__imul__","text":"<pre><code>__imul__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/expressions/expression.py</code> <pre><code>def __imul__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        self.__expression *= other.raw\n    else:\n        self.__expression *= other\n    return self\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__itruediv__","title":"__itruediv__","text":"<pre><code>__itruediv__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/expressions/expression.py</code> <pre><code>def __itruediv__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        self.__expression /= other.raw\n    else:\n        self.__expression /= other\n    return self\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__ifloordiv__","title":"__ifloordiv__","text":"<pre><code>__ifloordiv__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/expressions/expression.py</code> <pre><code>def __ifloordiv__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        self.__expression //= other.raw\n    else:\n        self.__expression //= other\n    return self\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__imod__","title":"__imod__","text":"<pre><code>__imod__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/expressions/expression.py</code> <pre><code>def __imod__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        self.__expression %= other.raw\n    else:\n        self.__expression %= other\n    return self\n</code></pre>"},{"location":"api/algebra/expressions/#pyorlib.algebra.Expression.__ipow__","title":"__ipow__","text":"<pre><code>__ipow__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/expressions/expression.py</code> <pre><code>def __ipow__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        self.__expression **= other.raw\n    else:\n        self.__expression **= other\n    return self\n</code></pre>"},{"location":"api/algebra/terms/","title":"<code>Term</code> class","text":"<p>               Bases: <code>Element</code>, <code>ABC</code></p> <p>A base class representing a term in an optimization model.</p> <p>The <code>Term</code> class serves as a base class for representing terms in an optimization model. It is designed to be inherited by subclasses that represent specific types of terms. The <code>Term</code> class itself is an abstract base class (ABC) that defines the common behavior and interface for all terms.</p> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>@dataclass\nclass Term(Element, ABC):\n    \"\"\"\n    A base class representing a term in an optimization model.\n\n    The `Term` class serves as a base class for representing terms in an optimization model. It is designed to\n    be inherited by subclasses that represent specific types of terms. The `Term` class itself is an abstract\n    base class (ABC) that defines the common behavior and interface for all terms.\n    \"\"\"\n\n    __slots__ = [\"_term_type\", \"_value_type\"]\n\n    @property\n    def term_type(self) -&gt; TermType:\n        \"\"\"\n        Retrieves the type of the term.\n        :return: A TermType enumeration.\n        \"\"\"\n        return self._term_type\n\n    @property\n    def value_type(self) -&gt; ValueType:\n        \"\"\"\n        Retrieves the type of the term's value.\n        :return: A ValueType enumeration\n        \"\"\"\n        return self._value_type\n\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"\n        Retrieves the name of the term.\n        :return: A string with name of the term.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def lower_bound(self) -&gt; float:\n        \"\"\"\n        Retrieves the lower bound of the term's value.\n            For variable terms, the lower bound denotes the minimum value that the term can assume.\n            For constant terms, the lower bound is equivalent to its value.\n        :return: A float representing the lower bound of the term's value. If the upper bound is negative infinity,\n            the method returns `-inf` from the math module.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def upper_bound(self) -&gt; float:\n        \"\"\"\n        Retrieves the upper bound of the term's value.\n            For variable terms, the upper bound denotes the maximum value that the term can assume.\n            For constant terms, the upper bound is equivalent to its value.\n        :return: A float representing the upper bound of the term's value. If the upper bound is infinity,\n            the method returns `inf` from the math module.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def value(self) -&gt; float:\n        \"\"\"\n        Retrieves the value of the term.\n            For variable terms, the value corresponds to the current value of the term.\n            If the term has not been solved yet, the value is `-0.0`.\n            For constant terms, the value remains the constant value.\n        :return: A float representing the value of the term.\n        \"\"\"\n        pass\n\n    @property\n    def is_variable(self) -&gt; bool:\n        \"\"\"\n        Determines whether the term is a variable or not.\n        :return: `True` if the term is a variable, `False` otherwise.\n        \"\"\"\n        return self._term_type == TermType.VARIABLE\n\n    @property\n    def is_constant(self) -&gt; bool:\n        \"\"\"\n        Determines whether the term is a constant or not.\n        :return: `True` if the term is a constant, `False` otherwise.\n        \"\"\"\n        return self._term_type == TermType.CONSTANT\n\n    def __init__(self, term_type: TermType, value_type: ValueType):\n        \"\"\"\n        Initializes a new Term object.\n        :param term_type: An enumeration representing the type of the term.\n        :param value_type: An enumeration representing the type of the term's value.\n        \"\"\"\n        # Applies validations\n        if term_type is None:\n            raise TermException(\"Invalid term type.\")\n\n        if value_type is None:\n            raise TermException(\"Invalid term value type.\")\n\n        # Instance attributes\n        self._term_type: TermType = term_type\n        \"\"\" An enumeration representing the type of the term. \"\"\"\n\n        self._value_type: ValueType = value_type\n        \"\"\" An enumeration representing the type of the term's value. \"\"\"\n\n    def _build_expression(self, expression: Any) -&gt; Element:\n        return Expression(expression=expression)\n\n    @abstractmethod\n    def get_pretty_string(self, float_precision: int = 6) -&gt; str:\n        \"\"\"\n        Returns a formatted string representation of the term.\n        :param float_precision: It represents the number of digits used in printing the solution and objective.\n        :return: A formatted string representing the term.\n        \"\"\"\n        pass\n\n    def __str__(self) -&gt; str:  # pragma: no cover\n        return \"\".join(\n            [\n                f\"Name: {self.name} | \",\n                f\"Type: {self.term_type.name} | \",\n                f\"Value type: {self.value_type.name} | \",\n                f\"lb: {self.lower_bound} | \",\n                f\"ub: {self.upper_bound} | \",\n                f\"val: {self.value}\",\n            ]\n        )\n\n    def __iadd__(self, other: Any) -&gt; Element:\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw + other.raw)\n        else:\n            return self._build_expression(expression=self.raw + other)\n\n    def __isub__(self, other: Any) -&gt; Element:\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw - other.raw)\n        else:\n            return self._build_expression(expression=self.raw - other)\n\n    def __imul__(self, other: Any) -&gt; Element:\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw * other.raw)\n        else:\n            return self._build_expression(expression=self.raw * other)\n\n    def __itruediv__(self, other: Any) -&gt; Element:\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw / other.raw)\n        else:\n            return self._build_expression(expression=self.raw / other)\n\n    def __ifloordiv__(self, other: Any) -&gt; Element:\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw // other.raw)\n        else:\n            return self._build_expression(expression=self.raw // other)\n\n    def __imod__(self, other: Any) -&gt; Element:\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw % other.raw)\n        else:\n            return self._build_expression(expression=self.raw % other)\n\n    def __ipow__(self, other: Any) -&gt; Element:\n        if isinstance(other, Element):\n            return self._build_expression(expression=self.raw**other.raw)\n        else:\n            return self._build_expression(expression=self.raw**other)\n</code></pre> <p></p>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term-attributes","title":"Attributes","text":""},{"location":"api/algebra/terms/#pyorlib.algebra.Term.raw","title":"raw  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>raw: Any\n</code></pre> <p>Returns the raw representation of the mathematical element.</p> <p>The <code>raw</code> method, when implemented by subclasses, returns the mathematical element in its raw format. The raw format can take various forms, such as an expression used by solvers or engines, or a mathematical expression that represents the entity itself.</p> RETURNS DESCRIPTION <code>Any</code> <p>The raw representation of the mathematical element.</p>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.term_type","title":"term_type  <code>property</code>","text":"<pre><code>term_type: TermType\n</code></pre> <p>Retrieves the type of the term.</p> RETURNS DESCRIPTION <code>TermType</code> <p>A TermType enumeration.</p>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.value_type","title":"value_type  <code>property</code>","text":"<pre><code>value_type: ValueType\n</code></pre> <p>Retrieves the type of the term's value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>A ValueType enumeration</p>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.name","title":"name  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Retrieves the name of the term.</p> RETURNS DESCRIPTION <code>str</code> <p>A string with name of the term.</p>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.lower_bound","title":"lower_bound  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>lower_bound: float\n</code></pre> <p>Retrieves the lower bound of the term's value.     For variable terms, the lower bound denotes the minimum value that the term can assume.     For constant terms, the lower bound is equivalent to its value.</p> RETURNS DESCRIPTION <code>float</code> <p>A float representing the lower bound of the term's value. If the upper bound is negative infinity, the method returns <code>-inf</code> from the math module.</p>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.upper_bound","title":"upper_bound  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>upper_bound: float\n</code></pre> <p>Retrieves the upper bound of the term's value.     For variable terms, the upper bound denotes the maximum value that the term can assume.     For constant terms, the upper bound is equivalent to its value.</p> RETURNS DESCRIPTION <code>float</code> <p>A float representing the upper bound of the term's value. If the upper bound is infinity, the method returns <code>inf</code> from the math module.</p>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.value","title":"value  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>value: float\n</code></pre> <p>Retrieves the value of the term.     For variable terms, the value corresponds to the current value of the term.     If the term has not been solved yet, the value is <code>-0.0</code>.     For constant terms, the value remains the constant value.</p> RETURNS DESCRIPTION <code>float</code> <p>A float representing the value of the term.</p>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.is_variable","title":"is_variable  <code>property</code>","text":"<pre><code>is_variable: bool\n</code></pre> <p>Determines whether the term is a variable or not.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the term is a variable, <code>False</code> otherwise.</p>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.is_constant","title":"is_constant  <code>property</code>","text":"<pre><code>is_constant: bool\n</code></pre> <p>Determines whether the term is a constant or not.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the term is a constant, <code>False</code> otherwise.</p>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term-functions","title":"Functions","text":""},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__add__","title":"__add__","text":"<pre><code>__add__(other: Any) -&gt; Element\n</code></pre> <p>Addition operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be added.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the addition.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __add__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Addition operation.\n    :param other: The `number` or `Element` instance to be added.\n    :return: A new `Element` instance representing the addition.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw + other.raw)\n    else:\n        return self._build_expression(expression=self.raw + other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__radd__","title":"__radd__","text":"<pre><code>__radd__(other: Any) -&gt; Element\n</code></pre> <p>Right addition operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be added.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the addition.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __radd__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right addition operation.\n    :param other: The `number` or `Element` instance to be added.\n    :return: A new `Element` instance representing the addition.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw + self.raw)\n    else:\n        return self._build_expression(expression=other + self.raw)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Any) -&gt; Element\n</code></pre> <p>Subtraction operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be subtracted.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the subtraction.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __sub__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Subtraction operation.\n    :param other: The `number` or `Element` instance to be subtracted.\n    :return: A new `Element` instance representing the subtraction.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw - other.raw)\n    else:\n        return self._build_expression(expression=self.raw - other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other: Any) -&gt; Element\n</code></pre> <p>Right subtraction operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be subtracted.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the subtraction.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rsub__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right subtraction operation.\n    :param other: The `number` or `Element` instance to be subtracted.\n    :return: A new `Element` instance representing the subtraction.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw - self.raw)\n    else:\n        return self._build_expression(expression=other - self.raw)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: Any) -&gt; Element\n</code></pre> <p>Multiplication operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be multiplied.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the multiplication.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __mul__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Multiplication operation.\n    :param other: The `number` or `Element` instance to be multiplied.\n    :return: A new `Element` instance representing the multiplication.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw * other.raw)\n    else:\n        return self._build_expression(expression=self.raw * other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other: Any) -&gt; Element\n</code></pre> <p>Right multiplication operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be multiplied.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the multiplication.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rmul__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right multiplication operation.\n    :param other: The `number` or `Element` instance to be multiplied.\n    :return: A new `Element` instance representing the multiplication.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw * self.raw)\n    else:\n        return self._build_expression(expression=other * self.raw)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: Any) -&gt; Element\n</code></pre> <p>Division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __truediv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Division operation.\n    :param other: The `number` or `Element` instance to be divided.\n    :return: A new `Element` instance representing the division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw / other.raw)\n    else:\n        return self._build_expression(expression=self.raw / other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__rtruediv__","title":"__rtruediv__","text":"<pre><code>__rtruediv__(other: Any) -&gt; Element\n</code></pre> <p>Right division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rtruediv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right division operation.\n    :param other: The `number` or `Element` instance to be divided.\n    :return: A new `Element` instance representing the division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw / self.raw)\n    else:\n        return self._build_expression(expression=other / self.raw)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__floordiv__","title":"__floordiv__","text":"<pre><code>__floordiv__(other: Any) -&gt; Element\n</code></pre> <p>Floor division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be floor divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the floor division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __floordiv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Floor division operation.\n    :param other: The `number` or `Element` instance to be floor divided.\n    :return: A new `Element` instance representing the floor division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw // other.raw)\n    else:\n        return self._build_expression(expression=self.raw // other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__rfloordiv__","title":"__rfloordiv__","text":"<pre><code>__rfloordiv__(other: Any) -&gt; Element\n</code></pre> <p>Right floor division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be floor divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the floor division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rfloordiv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right floor division operation.\n    :param other: The `number` or `Element` instance to be floor divided.\n    :return: A new `Element` instance representing the floor division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw // self.raw)\n    else:\n        return self._build_expression(expression=other // self.raw)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: Any) -&gt; Element\n</code></pre> <p>Modulo operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used for modulo.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the modulo operation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __mod__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Modulo operation.\n    :param other: The `number` or `Element` instance to be used for modulo.\n    :return: A new `Element` instance representing the modulo operation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw % other.raw)\n    else:\n        return self._build_expression(expression=self.raw % other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__rmod__","title":"__rmod__","text":"<pre><code>__rmod__(other: Any) -&gt; Element\n</code></pre> <p>Right modulo operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used for modulo.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the modulo operation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rmod__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right modulo operation.\n    :param other: The `number` or `Element` instance to be used for modulo.\n    :return: A new `Element` instance representing the modulo operation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw % self.raw)\n    else:\n        return self._build_expression(expression=other % self.raw)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__pow__","title":"__pow__","text":"<pre><code>__pow__(other: Any) -&gt; Element\n</code></pre> <p>Exponentiation operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used as the exponent.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the exponentiation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __pow__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Exponentiation operation.\n    :param other: The `number` or `Element` instance to be used as the exponent.\n    :return: A new `Element` instance representing the exponentiation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw**other.raw)\n    else:\n        return self._build_expression(expression=self.raw**other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__rpow__","title":"__rpow__","text":"<pre><code>__rpow__(other: Any) -&gt; Element\n</code></pre> <p>Right exponentiation operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used as the base.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the exponentiation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rpow__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right exponentiation operation.\n    :param other: The `number` or `Element` instance to be used as the base.\n    :return: A new `Element` instance representing the exponentiation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw**self.raw)\n    else:\n        return self._build_expression(expression=other**self.raw)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Element\n</code></pre> <p>Negation operation.</p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the negation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __neg__(self) -&gt; \"Element\":\n    \"\"\"\n    Negation operation.\n    :return: A new `Element` instance representing the negation.\n    \"\"\"\n    return self._build_expression(expression=-self.raw)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Element\n</code></pre> <p>Positive operation.</p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the positive value.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __pos__(self) -&gt; \"Element\":\n    \"\"\"\n    Positive operation.\n    :return: A new `Element` instance representing the positive value.\n    \"\"\"\n    return self._build_expression(expression=+self.raw)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Element\n</code></pre> <p>Absolute value operation.</p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the absolute value.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __abs__(self) -&gt; \"Element\":\n    \"\"\"\n    Absolute value operation.\n    :return: A new `Element` instance representing the absolute value.\n    \"\"\"\n    return self._build_expression(expression=abs(self.raw))\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; Element\n</code></pre> <p>Equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __eq__(self, other: Any) -&gt; \"Element\":  # type: ignore[override]\n    \"\"\"\n    Equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw == other.raw)\n    else:\n        return self._build_expression(expression=self.raw == other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__ne__","title":"__ne__","text":"<pre><code>__ne__(other: Any) -&gt; Element\n</code></pre> <p>Not equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __ne__(self, other: Any) -&gt; \"Element\":  # type: ignore[override]\n    \"\"\"\n    Not equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw != other.raw)\n    else:\n        return self._build_expression(expression=self.raw != other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Any) -&gt; Element\n</code></pre> <p>Less than comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __lt__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Less than comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &lt; other.raw)\n    else:\n        return self._build_expression(expression=self.raw &lt; other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__le__","title":"__le__","text":"<pre><code>__le__(other: Any) -&gt; Element\n</code></pre> <p>Less than or equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __le__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Less than or equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &lt;= other.raw)\n    else:\n        return self._build_expression(expression=self.raw &lt;= other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Any) -&gt; Element\n</code></pre> <p>Greater than comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __gt__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Greater than comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &gt; other.raw)\n    else:\n        return self._build_expression(expression=self.raw &gt; other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Any) -&gt; Element\n</code></pre> <p>Greater than or equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __ge__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Greater than or equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &gt;= other.raw)\n    else:\n        return self._build_expression(expression=self.raw &gt;= other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__init__","title":"__init__","text":"<pre><code>__init__(term_type: TermType, value_type: ValueType)\n</code></pre> <p>Initializes a new Term object.</p> PARAMETER DESCRIPTION <code>term_type</code> <p>An enumeration representing the type of the term.</p> <p> TYPE: <code>TermType</code> </p> <code>value_type</code> <p>An enumeration representing the type of the term's value.</p> <p> TYPE: <code>ValueType</code> </p> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __init__(self, term_type: TermType, value_type: ValueType):\n    \"\"\"\n    Initializes a new Term object.\n    :param term_type: An enumeration representing the type of the term.\n    :param value_type: An enumeration representing the type of the term's value.\n    \"\"\"\n    # Applies validations\n    if term_type is None:\n        raise TermException(\"Invalid term type.\")\n\n    if value_type is None:\n        raise TermException(\"Invalid term value type.\")\n\n    # Instance attributes\n    self._term_type: TermType = term_type\n    \"\"\" An enumeration representing the type of the term. \"\"\"\n\n    self._value_type: ValueType = value_type\n    \"\"\" An enumeration representing the type of the term's value. \"\"\"\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.get_pretty_string","title":"get_pretty_string  <code>abstractmethod</code>","text":"<pre><code>get_pretty_string(float_precision: int = 6) -&gt; str\n</code></pre> <p>Returns a formatted string representation of the term.</p> PARAMETER DESCRIPTION <code>float_precision</code> <p>It represents the number of digits used in printing the solution and objective.</p> <p> TYPE: <code>int</code> DEFAULT: <code>6</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A formatted string representing the term.</p> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>@abstractmethod\ndef get_pretty_string(self, float_precision: int = 6) -&gt; str:\n    \"\"\"\n    Returns a formatted string representation of the term.\n    :param float_precision: It represents the number of digits used in printing the solution and objective.\n    :return: A formatted string representing the term.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __iadd__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw + other.raw)\n    else:\n        return self._build_expression(expression=self.raw + other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__isub__","title":"__isub__","text":"<pre><code>__isub__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __isub__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw - other.raw)\n    else:\n        return self._build_expression(expression=self.raw - other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__imul__","title":"__imul__","text":"<pre><code>__imul__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __imul__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw * other.raw)\n    else:\n        return self._build_expression(expression=self.raw * other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__itruediv__","title":"__itruediv__","text":"<pre><code>__itruediv__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __itruediv__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw / other.raw)\n    else:\n        return self._build_expression(expression=self.raw / other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__ifloordiv__","title":"__ifloordiv__","text":"<pre><code>__ifloordiv__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __ifloordiv__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw // other.raw)\n    else:\n        return self._build_expression(expression=self.raw // other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__imod__","title":"__imod__","text":"<pre><code>__imod__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __imod__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw % other.raw)\n    else:\n        return self._build_expression(expression=self.raw % other)\n</code></pre>"},{"location":"api/algebra/terms/#pyorlib.algebra.Term.__ipow__","title":"__ipow__","text":"<pre><code>__ipow__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __ipow__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw**other.raw)\n    else:\n        return self._build_expression(expression=self.raw**other)\n</code></pre>"},{"location":"api/algebra/terms/constant/","title":"<code>Constant</code> class","text":"<p>               Bases: <code>Term</code></p> <p>Represents a constant value in an optimization model.</p> <p>The <code>Constant</code> class is a subclass of <code>Term</code> and represents a fixed value that remains constant throughout the optimization process. It is typically used to represent known values or parameters in an optimization model.</p> Source code in <code>pyorlib/algebra/terms/constants/constant.py</code> <pre><code>class Constant(Term):\n    \"\"\"\n    Represents a constant value in an optimization model.\n\n    The `Constant` class is a subclass of `Term` and represents a fixed value that remains constant\n    throughout the optimization process. It is typically used to represent known values or\n    parameters in an optimization model.\n    \"\"\"\n\n    __slots__ = [\"_name\", \"_value\"]\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    @property\n    def lower_bound(self) -&gt; float:\n        return self._value\n\n    @property\n    def upper_bound(self) -&gt; float:\n        return self._value\n\n    @property\n    def value(self) -&gt; float:\n        return self._value\n\n    @property\n    def raw(self) -&gt; Any:\n        return self.value\n\n    def __init__(self, name: str, value_type: ValueType, value: float):\n        \"\"\"\n        Initializes a new instance of the Constant class.\n        :param name: A string representing the name of the constant.\n        :param value_type: A ValueType enumeration representing the type of value the constant can assume.\n        :param value: A float representing the value of the constant.\n        \"\"\"\n        # Calls the super init method.\n        super().__init__(term_type=TermType.CONSTANT, value_type=value_type)\n\n        # Applies validations\n        if not name:\n            raise TermException(\"Constant terms must have a name.\")\n        if value is None:\n            raise TermException(\"Constant terms must have a value.\")\n        if value &gt;= inf or value &lt;= -inf:\n            raise TermException(\"Constant terms value cannot be greater than or equal to [+/-]infinity.\")\n        if value_type == ValueType.BINARY and not ValueTypeValidator.is_binary(num=value):\n            raise TermException(\"The value of a binary constant must be 0 or 1.\")\n        if value_type == ValueType.INTEGER and not ValueTypeValidator.is_integer(num=value):\n            raise TermException(\"The value of an integer constant must be a valid integer.\")\n\n        # Instance attributes\n        self._name: str = name\n        \"\"\" The name of the constant. \"\"\"\n\n        self._value: float = value\n        \"\"\" The internal value of the constant. \"\"\"\n\n    def get_pretty_string(self, float_precision: int = 6) -&gt; str:  # pragma: no cover\n        default, debug = StdOutColors.DEFAULT, StdOutColors.PURPLE\n        return \"\".join(\n            [\n                f\"Name: {debug}{self.name}{default} | \",\n                f\"Type: {debug}{self.term_type.name.capitalize()}{default} | \",\n                f\"Value type: {debug}{self.value_type.name.capitalize()}{default} | \",\n                f\"Val:{debug} \",\n                \"{0:.{prec}g} \".format(self.value, prec=float_precision),\n                f\"{default}\",\n            ]\n        )\n</code></pre> <p></p>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant-attributes","title":"Attributes","text":""},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.term_type","title":"term_type  <code>property</code>","text":"<pre><code>term_type: TermType\n</code></pre> <p>Retrieves the type of the term.</p> RETURNS DESCRIPTION <code>TermType</code> <p>A TermType enumeration.</p>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.value_type","title":"value_type  <code>property</code>","text":"<pre><code>value_type: ValueType\n</code></pre> <p>Retrieves the type of the term's value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>A ValueType enumeration</p>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.is_variable","title":"is_variable  <code>property</code>","text":"<pre><code>is_variable: bool\n</code></pre> <p>Determines whether the term is a variable or not.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the term is a variable, <code>False</code> otherwise.</p>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.is_constant","title":"is_constant  <code>property</code>","text":"<pre><code>is_constant: bool\n</code></pre> <p>Determines whether the term is a constant or not.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the term is a constant, <code>False</code> otherwise.</p>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.lower_bound","title":"lower_bound  <code>property</code>","text":"<pre><code>lower_bound: float\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.upper_bound","title":"upper_bound  <code>property</code>","text":"<pre><code>upper_bound: float\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.value","title":"value  <code>property</code>","text":"<pre><code>value: float\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.raw","title":"raw  <code>property</code>","text":"<pre><code>raw: Any\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant-functions","title":"Functions","text":""},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__add__","title":"__add__","text":"<pre><code>__add__(other: Any) -&gt; Element\n</code></pre> <p>Addition operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be added.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the addition.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __add__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Addition operation.\n    :param other: The `number` or `Element` instance to be added.\n    :return: A new `Element` instance representing the addition.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw + other.raw)\n    else:\n        return self._build_expression(expression=self.raw + other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__radd__","title":"__radd__","text":"<pre><code>__radd__(other: Any) -&gt; Element\n</code></pre> <p>Right addition operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be added.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the addition.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __radd__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right addition operation.\n    :param other: The `number` or `Element` instance to be added.\n    :return: A new `Element` instance representing the addition.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw + self.raw)\n    else:\n        return self._build_expression(expression=other + self.raw)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __iadd__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw + other.raw)\n    else:\n        return self._build_expression(expression=self.raw + other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Any) -&gt; Element\n</code></pre> <p>Subtraction operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be subtracted.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the subtraction.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __sub__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Subtraction operation.\n    :param other: The `number` or `Element` instance to be subtracted.\n    :return: A new `Element` instance representing the subtraction.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw - other.raw)\n    else:\n        return self._build_expression(expression=self.raw - other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other: Any) -&gt; Element\n</code></pre> <p>Right subtraction operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be subtracted.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the subtraction.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rsub__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right subtraction operation.\n    :param other: The `number` or `Element` instance to be subtracted.\n    :return: A new `Element` instance representing the subtraction.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw - self.raw)\n    else:\n        return self._build_expression(expression=other - self.raw)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__isub__","title":"__isub__","text":"<pre><code>__isub__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __isub__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw - other.raw)\n    else:\n        return self._build_expression(expression=self.raw - other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: Any) -&gt; Element\n</code></pre> <p>Multiplication operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be multiplied.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the multiplication.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __mul__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Multiplication operation.\n    :param other: The `number` or `Element` instance to be multiplied.\n    :return: A new `Element` instance representing the multiplication.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw * other.raw)\n    else:\n        return self._build_expression(expression=self.raw * other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other: Any) -&gt; Element\n</code></pre> <p>Right multiplication operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be multiplied.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the multiplication.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rmul__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right multiplication operation.\n    :param other: The `number` or `Element` instance to be multiplied.\n    :return: A new `Element` instance representing the multiplication.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw * self.raw)\n    else:\n        return self._build_expression(expression=other * self.raw)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__imul__","title":"__imul__","text":"<pre><code>__imul__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __imul__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw * other.raw)\n    else:\n        return self._build_expression(expression=self.raw * other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: Any) -&gt; Element\n</code></pre> <p>Division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __truediv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Division operation.\n    :param other: The `number` or `Element` instance to be divided.\n    :return: A new `Element` instance representing the division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw / other.raw)\n    else:\n        return self._build_expression(expression=self.raw / other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__rtruediv__","title":"__rtruediv__","text":"<pre><code>__rtruediv__(other: Any) -&gt; Element\n</code></pre> <p>Right division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rtruediv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right division operation.\n    :param other: The `number` or `Element` instance to be divided.\n    :return: A new `Element` instance representing the division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw / self.raw)\n    else:\n        return self._build_expression(expression=other / self.raw)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__itruediv__","title":"__itruediv__","text":"<pre><code>__itruediv__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __itruediv__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw / other.raw)\n    else:\n        return self._build_expression(expression=self.raw / other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__floordiv__","title":"__floordiv__","text":"<pre><code>__floordiv__(other: Any) -&gt; Element\n</code></pre> <p>Floor division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be floor divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the floor division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __floordiv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Floor division operation.\n    :param other: The `number` or `Element` instance to be floor divided.\n    :return: A new `Element` instance representing the floor division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw // other.raw)\n    else:\n        return self._build_expression(expression=self.raw // other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__rfloordiv__","title":"__rfloordiv__","text":"<pre><code>__rfloordiv__(other: Any) -&gt; Element\n</code></pre> <p>Right floor division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be floor divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the floor division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rfloordiv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right floor division operation.\n    :param other: The `number` or `Element` instance to be floor divided.\n    :return: A new `Element` instance representing the floor division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw // self.raw)\n    else:\n        return self._build_expression(expression=other // self.raw)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__ifloordiv__","title":"__ifloordiv__","text":"<pre><code>__ifloordiv__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __ifloordiv__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw // other.raw)\n    else:\n        return self._build_expression(expression=self.raw // other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: Any) -&gt; Element\n</code></pre> <p>Modulo operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used for modulo.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the modulo operation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __mod__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Modulo operation.\n    :param other: The `number` or `Element` instance to be used for modulo.\n    :return: A new `Element` instance representing the modulo operation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw % other.raw)\n    else:\n        return self._build_expression(expression=self.raw % other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__rmod__","title":"__rmod__","text":"<pre><code>__rmod__(other: Any) -&gt; Element\n</code></pre> <p>Right modulo operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used for modulo.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the modulo operation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rmod__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right modulo operation.\n    :param other: The `number` or `Element` instance to be used for modulo.\n    :return: A new `Element` instance representing the modulo operation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw % self.raw)\n    else:\n        return self._build_expression(expression=other % self.raw)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__imod__","title":"__imod__","text":"<pre><code>__imod__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __imod__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw % other.raw)\n    else:\n        return self._build_expression(expression=self.raw % other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__pow__","title":"__pow__","text":"<pre><code>__pow__(other: Any) -&gt; Element\n</code></pre> <p>Exponentiation operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used as the exponent.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the exponentiation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __pow__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Exponentiation operation.\n    :param other: The `number` or `Element` instance to be used as the exponent.\n    :return: A new `Element` instance representing the exponentiation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw**other.raw)\n    else:\n        return self._build_expression(expression=self.raw**other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__rpow__","title":"__rpow__","text":"<pre><code>__rpow__(other: Any) -&gt; Element\n</code></pre> <p>Right exponentiation operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used as the base.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the exponentiation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rpow__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right exponentiation operation.\n    :param other: The `number` or `Element` instance to be used as the base.\n    :return: A new `Element` instance representing the exponentiation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw**self.raw)\n    else:\n        return self._build_expression(expression=other**self.raw)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__ipow__","title":"__ipow__","text":"<pre><code>__ipow__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __ipow__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw**other.raw)\n    else:\n        return self._build_expression(expression=self.raw**other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Element\n</code></pre> <p>Negation operation.</p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the negation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __neg__(self) -&gt; \"Element\":\n    \"\"\"\n    Negation operation.\n    :return: A new `Element` instance representing the negation.\n    \"\"\"\n    return self._build_expression(expression=-self.raw)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Element\n</code></pre> <p>Positive operation.</p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the positive value.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __pos__(self) -&gt; \"Element\":\n    \"\"\"\n    Positive operation.\n    :return: A new `Element` instance representing the positive value.\n    \"\"\"\n    return self._build_expression(expression=+self.raw)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Element\n</code></pre> <p>Absolute value operation.</p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the absolute value.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __abs__(self) -&gt; \"Element\":\n    \"\"\"\n    Absolute value operation.\n    :return: A new `Element` instance representing the absolute value.\n    \"\"\"\n    return self._build_expression(expression=abs(self.raw))\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; Element\n</code></pre> <p>Equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __eq__(self, other: Any) -&gt; \"Element\":  # type: ignore[override]\n    \"\"\"\n    Equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw == other.raw)\n    else:\n        return self._build_expression(expression=self.raw == other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__ne__","title":"__ne__","text":"<pre><code>__ne__(other: Any) -&gt; Element\n</code></pre> <p>Not equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __ne__(self, other: Any) -&gt; \"Element\":  # type: ignore[override]\n    \"\"\"\n    Not equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw != other.raw)\n    else:\n        return self._build_expression(expression=self.raw != other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Any) -&gt; Element\n</code></pre> <p>Less than comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __lt__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Less than comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &lt; other.raw)\n    else:\n        return self._build_expression(expression=self.raw &lt; other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__le__","title":"__le__","text":"<pre><code>__le__(other: Any) -&gt; Element\n</code></pre> <p>Less than or equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __le__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Less than or equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &lt;= other.raw)\n    else:\n        return self._build_expression(expression=self.raw &lt;= other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Any) -&gt; Element\n</code></pre> <p>Greater than comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __gt__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Greater than comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &gt; other.raw)\n    else:\n        return self._build_expression(expression=self.raw &gt; other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Any) -&gt; Element\n</code></pre> <p>Greater than or equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __ge__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Greater than or equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &gt;= other.raw)\n    else:\n        return self._build_expression(expression=self.raw &gt;= other)\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.__init__","title":"__init__","text":"<pre><code>__init__(name: str, value_type: ValueType, value: float)\n</code></pre> <p>Initializes a new instance of the Constant class.</p> PARAMETER DESCRIPTION <code>name</code> <p>A string representing the name of the constant.</p> <p> TYPE: <code>str</code> </p> <code>value_type</code> <p>A ValueType enumeration representing the type of value the constant can assume.</p> <p> TYPE: <code>ValueType</code> </p> <code>value</code> <p>A float representing the value of the constant.</p> <p> TYPE: <code>float</code> </p> Source code in <code>pyorlib/algebra/terms/constants/constant.py</code> <pre><code>def __init__(self, name: str, value_type: ValueType, value: float):\n    \"\"\"\n    Initializes a new instance of the Constant class.\n    :param name: A string representing the name of the constant.\n    :param value_type: A ValueType enumeration representing the type of value the constant can assume.\n    :param value: A float representing the value of the constant.\n    \"\"\"\n    # Calls the super init method.\n    super().__init__(term_type=TermType.CONSTANT, value_type=value_type)\n\n    # Applies validations\n    if not name:\n        raise TermException(\"Constant terms must have a name.\")\n    if value is None:\n        raise TermException(\"Constant terms must have a value.\")\n    if value &gt;= inf or value &lt;= -inf:\n        raise TermException(\"Constant terms value cannot be greater than or equal to [+/-]infinity.\")\n    if value_type == ValueType.BINARY and not ValueTypeValidator.is_binary(num=value):\n        raise TermException(\"The value of a binary constant must be 0 or 1.\")\n    if value_type == ValueType.INTEGER and not ValueTypeValidator.is_integer(num=value):\n        raise TermException(\"The value of an integer constant must be a valid integer.\")\n\n    # Instance attributes\n    self._name: str = name\n    \"\"\" The name of the constant. \"\"\"\n\n    self._value: float = value\n    \"\"\" The internal value of the constant. \"\"\"\n</code></pre>"},{"location":"api/algebra/terms/constant/#pyorlib.algebra.Constant.get_pretty_string","title":"get_pretty_string","text":"<pre><code>get_pretty_string(float_precision: int = 6) -&gt; str\n</code></pre> Source code in <code>pyorlib/algebra/terms/constants/constant.py</code> <pre><code>def get_pretty_string(self, float_precision: int = 6) -&gt; str:  # pragma: no cover\n    default, debug = StdOutColors.DEFAULT, StdOutColors.PURPLE\n    return \"\".join(\n        [\n            f\"Name: {debug}{self.name}{default} | \",\n            f\"Type: {debug}{self.term_type.name.capitalize()}{default} | \",\n            f\"Value type: {debug}{self.value_type.name.capitalize()}{default} | \",\n            f\"Val:{debug} \",\n            \"{0:.{prec}g} \".format(self.value, prec=float_precision),\n            f\"{default}\",\n        ]\n    )\n</code></pre>"},{"location":"api/algebra/terms/variable/","title":"<code>Variable</code> class","text":"<p>               Bases: <code>Term</code>, <code>ABC</code></p> <p>Represents a base class for variable terms in an optimization model.</p> <p>The <code>Variable</code> class is a subclass of <code>Term</code> and serves as a foundation for representing variable terms in optimization models. It is designed to be inherited by subclasses that represent specific types of variables. As an abstract base class (ABC), <code>Variable</code> defines the common behavior and interface for all variable terms.</p> Source code in <code>pyorlib/algebra/terms/variables/variable.py</code> <pre><code>class Variable(Term, ABC):\n    \"\"\"\n    Represents a base class for variable terms in an optimization model.\n\n    The `Variable` class is a subclass of `Term` and serves as a foundation for representing variable terms in\n    optimization models. It is designed to be inherited by subclasses that represent specific types of\n    variables. As an abstract base class (ABC), `Variable` defines the common behavior and interface\n    for all variable terms.\n    \"\"\"\n\n    def __init__(self, name: str, value_type: ValueType, lower_bound: float = 0, upper_bound: float = inf):\n        \"\"\"\n        Initializes a new `Variable` object with the specified attributes.\n        :param name: The name of the variable.\n        :param value_type: An enumeration representing the type of the variable's value.\n        :param lower_bound: The lower bound of the variable. Default is 0.\n        :param upper_bound: The upper bound of the variable. Default is infinity.\n        \"\"\"\n        # Calls the base init with the term type as Variable.\n        super().__init__(term_type=TermType.VARIABLE, value_type=value_type)\n\n        # Applies validations\n        if not name:\n            raise TermException(\"Variable terms must have a name.\")\n        if lower_bound is None or upper_bound is None:\n            raise TermException(\"Variable terms must have lower and upper bounds.\")\n        if lower_bound &gt;= inf:\n            raise TermException(\"Variable terms lower bounds cannot be +infinity.\")\n        if upper_bound &lt;= -inf:\n            raise TermException(\"Variable terms upper bounds cannot be -infinity.\")\n        if lower_bound &gt; upper_bound:\n            raise TermException(\"The lower bound of a variable cannot be greater than the upper bound.\")\n        if value_type == ValueType.BINARY and (lower_bound != 0 or (upper_bound != 1 and upper_bound != inf)):\n            raise TermException(\"Invalid bounds for a binary variable.\")\n        if value_type == ValueType.INTEGER and not lower_bound == -inf and not float(lower_bound).is_integer():\n            raise TermException(\"Invalid lower bound for an integer variable term.\")\n        if value_type == ValueType.INTEGER and not upper_bound == inf and not float(upper_bound).is_integer():\n            raise TermException(\"Invalid upper bound for an integer variable term.\")\n\n    def get_pretty_string(self, float_precision: int = 6) -&gt; str:  # pragma: no cover\n        default, debug = StdOutColors.DEFAULT, StdOutColors.PURPLE\n        return \"\".join(\n            [\n                f\"Name: {debug}{self.name}{default} | \",\n                f\"Type: {debug}{self.term_type.name.capitalize()}{default} | \",\n                f\"Value type: {debug}{self.value_type.name.capitalize()}{default} | \",\n                f\"Lb:{debug} \",\n                \"{0:.{prec}g} \".format(self.lower_bound, prec=float_precision),\n                f\"{default}| Ub:{debug} \",\n                \"{0:.{prec}g} \".format(self.upper_bound, prec=float_precision),\n                f\"{default}| Val:{debug} \",\n                \"{0:.{prec}g} \".format(self.value, prec=float_precision),\n                f\"{'(N/A) ' if self.value == -0.0 else ''}{default}\",\n            ]\n        )\n</code></pre> <p></p>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable-attributes","title":"Attributes","text":""},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.raw","title":"raw  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>raw: Any\n</code></pre> <p>Returns the raw representation of the mathematical element.</p> <p>The <code>raw</code> method, when implemented by subclasses, returns the mathematical element in its raw format. The raw format can take various forms, such as an expression used by solvers or engines, or a mathematical expression that represents the entity itself.</p> RETURNS DESCRIPTION <code>Any</code> <p>The raw representation of the mathematical element.</p>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.term_type","title":"term_type  <code>property</code>","text":"<pre><code>term_type: TermType\n</code></pre> <p>Retrieves the type of the term.</p> RETURNS DESCRIPTION <code>TermType</code> <p>A TermType enumeration.</p>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.value_type","title":"value_type  <code>property</code>","text":"<pre><code>value_type: ValueType\n</code></pre> <p>Retrieves the type of the term's value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>A ValueType enumeration</p>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.name","title":"name  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Retrieves the name of the term.</p> RETURNS DESCRIPTION <code>str</code> <p>A string with name of the term.</p>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.lower_bound","title":"lower_bound  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>lower_bound: float\n</code></pre> <p>Retrieves the lower bound of the term's value.     For variable terms, the lower bound denotes the minimum value that the term can assume.     For constant terms, the lower bound is equivalent to its value.</p> RETURNS DESCRIPTION <code>float</code> <p>A float representing the lower bound of the term's value. If the upper bound is negative infinity, the method returns <code>-inf</code> from the math module.</p>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.upper_bound","title":"upper_bound  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>upper_bound: float\n</code></pre> <p>Retrieves the upper bound of the term's value.     For variable terms, the upper bound denotes the maximum value that the term can assume.     For constant terms, the upper bound is equivalent to its value.</p> RETURNS DESCRIPTION <code>float</code> <p>A float representing the upper bound of the term's value. If the upper bound is infinity, the method returns <code>inf</code> from the math module.</p>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.value","title":"value  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>value: float\n</code></pre> <p>Retrieves the value of the term.     For variable terms, the value corresponds to the current value of the term.     If the term has not been solved yet, the value is <code>-0.0</code>.     For constant terms, the value remains the constant value.</p> RETURNS DESCRIPTION <code>float</code> <p>A float representing the value of the term.</p>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.is_variable","title":"is_variable  <code>property</code>","text":"<pre><code>is_variable: bool\n</code></pre> <p>Determines whether the term is a variable or not.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the term is a variable, <code>False</code> otherwise.</p>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.is_constant","title":"is_constant  <code>property</code>","text":"<pre><code>is_constant: bool\n</code></pre> <p>Determines whether the term is a constant or not.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the term is a constant, <code>False</code> otherwise.</p>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable-functions","title":"Functions","text":""},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__add__","title":"__add__","text":"<pre><code>__add__(other: Any) -&gt; Element\n</code></pre> <p>Addition operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be added.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the addition.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __add__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Addition operation.\n    :param other: The `number` or `Element` instance to be added.\n    :return: A new `Element` instance representing the addition.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw + other.raw)\n    else:\n        return self._build_expression(expression=self.raw + other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__radd__","title":"__radd__","text":"<pre><code>__radd__(other: Any) -&gt; Element\n</code></pre> <p>Right addition operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be added.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the addition.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __radd__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right addition operation.\n    :param other: The `number` or `Element` instance to be added.\n    :return: A new `Element` instance representing the addition.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw + self.raw)\n    else:\n        return self._build_expression(expression=other + self.raw)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __iadd__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw + other.raw)\n    else:\n        return self._build_expression(expression=self.raw + other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Any) -&gt; Element\n</code></pre> <p>Subtraction operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be subtracted.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the subtraction.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __sub__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Subtraction operation.\n    :param other: The `number` or `Element` instance to be subtracted.\n    :return: A new `Element` instance representing the subtraction.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw - other.raw)\n    else:\n        return self._build_expression(expression=self.raw - other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other: Any) -&gt; Element\n</code></pre> <p>Right subtraction operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be subtracted.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the subtraction.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rsub__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right subtraction operation.\n    :param other: The `number` or `Element` instance to be subtracted.\n    :return: A new `Element` instance representing the subtraction.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw - self.raw)\n    else:\n        return self._build_expression(expression=other - self.raw)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__isub__","title":"__isub__","text":"<pre><code>__isub__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __isub__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw - other.raw)\n    else:\n        return self._build_expression(expression=self.raw - other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: Any) -&gt; Element\n</code></pre> <p>Multiplication operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be multiplied.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the multiplication.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __mul__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Multiplication operation.\n    :param other: The `number` or `Element` instance to be multiplied.\n    :return: A new `Element` instance representing the multiplication.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw * other.raw)\n    else:\n        return self._build_expression(expression=self.raw * other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other: Any) -&gt; Element\n</code></pre> <p>Right multiplication operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be multiplied.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the multiplication.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rmul__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right multiplication operation.\n    :param other: The `number` or `Element` instance to be multiplied.\n    :return: A new `Element` instance representing the multiplication.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw * self.raw)\n    else:\n        return self._build_expression(expression=other * self.raw)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__imul__","title":"__imul__","text":"<pre><code>__imul__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __imul__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw * other.raw)\n    else:\n        return self._build_expression(expression=self.raw * other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: Any) -&gt; Element\n</code></pre> <p>Division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __truediv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Division operation.\n    :param other: The `number` or `Element` instance to be divided.\n    :return: A new `Element` instance representing the division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw / other.raw)\n    else:\n        return self._build_expression(expression=self.raw / other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__rtruediv__","title":"__rtruediv__","text":"<pre><code>__rtruediv__(other: Any) -&gt; Element\n</code></pre> <p>Right division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rtruediv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right division operation.\n    :param other: The `number` or `Element` instance to be divided.\n    :return: A new `Element` instance representing the division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw / self.raw)\n    else:\n        return self._build_expression(expression=other / self.raw)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__itruediv__","title":"__itruediv__","text":"<pre><code>__itruediv__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __itruediv__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw / other.raw)\n    else:\n        return self._build_expression(expression=self.raw / other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__floordiv__","title":"__floordiv__","text":"<pre><code>__floordiv__(other: Any) -&gt; Element\n</code></pre> <p>Floor division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be floor divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the floor division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __floordiv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Floor division operation.\n    :param other: The `number` or `Element` instance to be floor divided.\n    :return: A new `Element` instance representing the floor division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw // other.raw)\n    else:\n        return self._build_expression(expression=self.raw // other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__rfloordiv__","title":"__rfloordiv__","text":"<pre><code>__rfloordiv__(other: Any) -&gt; Element\n</code></pre> <p>Right floor division operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be floor divided.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the floor division.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rfloordiv__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right floor division operation.\n    :param other: The `number` or `Element` instance to be floor divided.\n    :return: A new `Element` instance representing the floor division.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw // self.raw)\n    else:\n        return self._build_expression(expression=other // self.raw)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__ifloordiv__","title":"__ifloordiv__","text":"<pre><code>__ifloordiv__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __ifloordiv__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw // other.raw)\n    else:\n        return self._build_expression(expression=self.raw // other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: Any) -&gt; Element\n</code></pre> <p>Modulo operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used for modulo.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the modulo operation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __mod__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Modulo operation.\n    :param other: The `number` or `Element` instance to be used for modulo.\n    :return: A new `Element` instance representing the modulo operation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw % other.raw)\n    else:\n        return self._build_expression(expression=self.raw % other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__rmod__","title":"__rmod__","text":"<pre><code>__rmod__(other: Any) -&gt; Element\n</code></pre> <p>Right modulo operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used for modulo.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the modulo operation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rmod__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right modulo operation.\n    :param other: The `number` or `Element` instance to be used for modulo.\n    :return: A new `Element` instance representing the modulo operation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw % self.raw)\n    else:\n        return self._build_expression(expression=other % self.raw)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__imod__","title":"__imod__","text":"<pre><code>__imod__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __imod__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw % other.raw)\n    else:\n        return self._build_expression(expression=self.raw % other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__pow__","title":"__pow__","text":"<pre><code>__pow__(other: Any) -&gt; Element\n</code></pre> <p>Exponentiation operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used as the exponent.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the exponentiation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __pow__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Exponentiation operation.\n    :param other: The `number` or `Element` instance to be used as the exponent.\n    :return: A new `Element` instance representing the exponentiation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw**other.raw)\n    else:\n        return self._build_expression(expression=self.raw**other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__rpow__","title":"__rpow__","text":"<pre><code>__rpow__(other: Any) -&gt; Element\n</code></pre> <p>Right exponentiation operation.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be used as the base.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the exponentiation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __rpow__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Right exponentiation operation.\n    :param other: The `number` or `Element` instance to be used as the base.\n    :return: A new `Element` instance representing the exponentiation.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=other.raw**self.raw)\n    else:\n        return self._build_expression(expression=other**self.raw)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__ipow__","title":"__ipow__","text":"<pre><code>__ipow__(other: Any) -&gt; Element\n</code></pre> Source code in <code>pyorlib/algebra/terms/term.py</code> <pre><code>def __ipow__(self, other: Any) -&gt; Element:\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw**other.raw)\n    else:\n        return self._build_expression(expression=self.raw**other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Element\n</code></pre> <p>Negation operation.</p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the negation.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __neg__(self) -&gt; \"Element\":\n    \"\"\"\n    Negation operation.\n    :return: A new `Element` instance representing the negation.\n    \"\"\"\n    return self._build_expression(expression=-self.raw)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Element\n</code></pre> <p>Positive operation.</p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the positive value.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __pos__(self) -&gt; \"Element\":\n    \"\"\"\n    Positive operation.\n    :return: A new `Element` instance representing the positive value.\n    \"\"\"\n    return self._build_expression(expression=+self.raw)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Element\n</code></pre> <p>Absolute value operation.</p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the absolute value.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __abs__(self) -&gt; \"Element\":\n    \"\"\"\n    Absolute value operation.\n    :return: A new `Element` instance representing the absolute value.\n    \"\"\"\n    return self._build_expression(expression=abs(self.raw))\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; Element\n</code></pre> <p>Equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __eq__(self, other: Any) -&gt; \"Element\":  # type: ignore[override]\n    \"\"\"\n    Equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw == other.raw)\n    else:\n        return self._build_expression(expression=self.raw == other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__ne__","title":"__ne__","text":"<pre><code>__ne__(other: Any) -&gt; Element\n</code></pre> <p>Not equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __ne__(self, other: Any) -&gt; \"Element\":  # type: ignore[override]\n    \"\"\"\n    Not equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw != other.raw)\n    else:\n        return self._build_expression(expression=self.raw != other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Any) -&gt; Element\n</code></pre> <p>Less than comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __lt__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Less than comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &lt; other.raw)\n    else:\n        return self._build_expression(expression=self.raw &lt; other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__le__","title":"__le__","text":"<pre><code>__le__(other: Any) -&gt; Element\n</code></pre> <p>Less than or equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __le__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Less than or equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &lt;= other.raw)\n    else:\n        return self._build_expression(expression=self.raw &lt;= other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: Any) -&gt; Element\n</code></pre> <p>Greater than comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __gt__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Greater than comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &gt; other.raw)\n    else:\n        return self._build_expression(expression=self.raw &gt; other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: Any) -&gt; Element\n</code></pre> <p>Greater than or equal to comparison.</p> PARAMETER DESCRIPTION <code>other</code> <p>The <code>number</code> or <code>Element</code> instance to be compared.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>A new <code>Element</code> instance representing the comparison result.</p> Source code in <code>pyorlib/algebra/element.py</code> <pre><code>def __ge__(self, other: Any) -&gt; \"Element\":\n    \"\"\"\n    Greater than or equal to comparison.\n    :param other: The `number` or `Element` instance to be compared.\n    :return: A new `Element` instance representing the comparison result.\n    \"\"\"\n    if isinstance(other, Element):\n        return self._build_expression(expression=self.raw &gt;= other.raw)\n    else:\n        return self._build_expression(expression=self.raw &gt;= other)\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.__init__","title":"__init__","text":"<pre><code>__init__(name: str, value_type: ValueType, lower_bound: float = 0, upper_bound: float = inf)\n</code></pre> <p>Initializes a new <code>Variable</code> object with the specified attributes.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the variable.</p> <p> TYPE: <code>str</code> </p> <code>value_type</code> <p>An enumeration representing the type of the variable's value.</p> <p> TYPE: <code>ValueType</code> </p> <code>lower_bound</code> <p>The lower bound of the variable. Default is 0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>upper_bound</code> <p>The upper bound of the variable. Default is infinity.</p> <p> TYPE: <code>float</code> DEFAULT: <code>inf</code> </p> Source code in <code>pyorlib/algebra/terms/variables/variable.py</code> <pre><code>def __init__(self, name: str, value_type: ValueType, lower_bound: float = 0, upper_bound: float = inf):\n    \"\"\"\n    Initializes a new `Variable` object with the specified attributes.\n    :param name: The name of the variable.\n    :param value_type: An enumeration representing the type of the variable's value.\n    :param lower_bound: The lower bound of the variable. Default is 0.\n    :param upper_bound: The upper bound of the variable. Default is infinity.\n    \"\"\"\n    # Calls the base init with the term type as Variable.\n    super().__init__(term_type=TermType.VARIABLE, value_type=value_type)\n\n    # Applies validations\n    if not name:\n        raise TermException(\"Variable terms must have a name.\")\n    if lower_bound is None or upper_bound is None:\n        raise TermException(\"Variable terms must have lower and upper bounds.\")\n    if lower_bound &gt;= inf:\n        raise TermException(\"Variable terms lower bounds cannot be +infinity.\")\n    if upper_bound &lt;= -inf:\n        raise TermException(\"Variable terms upper bounds cannot be -infinity.\")\n    if lower_bound &gt; upper_bound:\n        raise TermException(\"The lower bound of a variable cannot be greater than the upper bound.\")\n    if value_type == ValueType.BINARY and (lower_bound != 0 or (upper_bound != 1 and upper_bound != inf)):\n        raise TermException(\"Invalid bounds for a binary variable.\")\n    if value_type == ValueType.INTEGER and not lower_bound == -inf and not float(lower_bound).is_integer():\n        raise TermException(\"Invalid lower bound for an integer variable term.\")\n    if value_type == ValueType.INTEGER and not upper_bound == inf and not float(upper_bound).is_integer():\n        raise TermException(\"Invalid upper bound for an integer variable term.\")\n</code></pre>"},{"location":"api/algebra/terms/variable/#pyorlib.algebra.Variable.get_pretty_string","title":"get_pretty_string","text":"<pre><code>get_pretty_string(float_precision: int = 6) -&gt; str\n</code></pre> Source code in <code>pyorlib/algebra/terms/variables/variable.py</code> <pre><code>def get_pretty_string(self, float_precision: int = 6) -&gt; str:  # pragma: no cover\n    default, debug = StdOutColors.DEFAULT, StdOutColors.PURPLE\n    return \"\".join(\n        [\n            f\"Name: {debug}{self.name}{default} | \",\n            f\"Type: {debug}{self.term_type.name.capitalize()}{default} | \",\n            f\"Value type: {debug}{self.value_type.name.capitalize()}{default} | \",\n            f\"Lb:{debug} \",\n            \"{0:.{prec}g} \".format(self.lower_bound, prec=float_precision),\n            f\"{default}| Ub:{debug} \",\n            \"{0:.{prec}g} \".format(self.upper_bound, prec=float_precision),\n            f\"{default}| Val:{debug} \",\n            \"{0:.{prec}g} \".format(self.value, prec=float_precision),\n            f\"{'(N/A) ' if self.value == -0.0 else ''}{default}\",\n        ]\n    )\n</code></pre>"},{"location":"api/engines/","title":"<code>Engine</code> class","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for optimization engines.</p> <p>The <code>Engine</code> class is a base class that provides a common interface for interacting with different solvers. It serves as a foundation for representing and utilizing various solver implementations, such as Gurobi, CPLEX, and others.</p> <p>By inheriting from this base class, specific engine classes can be developed to implement solver-specific functionality while adhering to the common interface defined by the <code>Engine</code> class.</p> <p>This decoupling from the specific solvers allows for greater flexibility and interchangeability of solver implementations within an optimization model. It promotes code reuse and simplifies the process of integrating different solvers into an application.</p> <p>The <code>Engine</code> class defines a set of abstract methods that must be implemented by concrete engine classes. These methods include solving the optimization model, adding variables and constraints, setting the objective function, and configuring solver-specific parameters.</p> Source code in <code>pyorlib/engines/engine.py</code> <pre><code>class Engine(ABC):\n    \"\"\"\n    Abstract base class for optimization engines.\n\n    The `Engine` class is a base class that provides a common interface for interacting with different solvers. It\n    serves as a foundation for representing and utilizing various solver implementations, such as Gurobi, CPLEX,\n    and others.\n\n    By inheriting from this base class, specific engine classes can be developed to implement solver-specific\n    functionality while adhering to the common interface defined by the `Engine` class.\n\n    This decoupling from the specific solvers allows for greater flexibility and interchangeability of solver\n    implementations within an optimization model. It promotes code reuse and simplifies the process of integrating\n    different solvers into an application.\n\n    The `Engine` class defines a set of abstract methods that must be implemented by concrete engine classes. These\n    methods include solving the optimization model, adding variables and constraints, setting the objective function,\n    and configuring solver-specific parameters.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the concrete solver.\n        :return: The name of the concrete solver implementation.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def constraints(self) -&gt; List[Element]:\n        \"\"\"\n        Get the list of constraints in the model.\n        :return: The list of constraint objects.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def objective_value(self) -&gt; float | None:\n        \"\"\"\n        Get the objective value for the current solution.\n        :return: The objective value, or None if no solution exists.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def objective_expr(self) -&gt; Element | None:\n        \"\"\"\n        Get the objective expression object.\n        :return: The objective expression, or None if not set.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def solution_status(self) -&gt; SolutionStatus:\n        \"\"\"\n        Get the solution status.\n        :return: The status of the current solution.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def add_variable(\n        self,\n        name: str,\n        value_type: ValueType,\n        lower_bound: float = 0,\n        upper_bound: float = inf,\n    ) -&gt; Variable:\n        \"\"\"\n        Add a new variable to the engine.\n        :param name: The name of the variable.\n        :param value_type: The value type of the variable.\n        :param lower_bound: The lower bound of the variable. Default is 0.\n        :param upper_bound: The upper bound of the variable. Default is infinity.\n        :return: The created variable object.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def add_constraint(self, expression: Element) -&gt; Element:\n        \"\"\"\n        Add a new constraint expression to the engine.\n        :param expression: The constraint expression.\n        :return: The created constraint object.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_objective(self, opt_type: OptimizationType, expression: Element) -&gt; Element:\n        \"\"\"\n        Defines the objective function.\n        :param opt_type: The type of optimization to be performed.\n        :param expression: The objective expression.\n        :return: The objective function.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def solve(self) -&gt; None:\n        \"\"\"\n        Solve the optimization model.\n        :return: None\n        \"\"\"\n        pass\n</code></pre> <p></p>"},{"location":"api/engines/#pyorlib.engines.Engine-attributes","title":"Attributes","text":""},{"location":"api/engines/#pyorlib.engines.Engine.name","title":"name  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the name of the concrete solver.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of the concrete solver implementation.</p>"},{"location":"api/engines/#pyorlib.engines.Engine.constraints","title":"constraints  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>constraints: List[Element]\n</code></pre> <p>Get the list of constraints in the model.</p> RETURNS DESCRIPTION <code>List[Element]</code> <p>The list of constraint objects.</p>"},{"location":"api/engines/#pyorlib.engines.Engine.objective_value","title":"objective_value  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>objective_value: float | None\n</code></pre> <p>Get the objective value for the current solution.</p> RETURNS DESCRIPTION <code>float | None</code> <p>The objective value, or None if no solution exists.</p>"},{"location":"api/engines/#pyorlib.engines.Engine.objective_expr","title":"objective_expr  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>objective_expr: Element | None\n</code></pre> <p>Get the objective expression object.</p> RETURNS DESCRIPTION <code>Element | None</code> <p>The objective expression, or None if not set.</p>"},{"location":"api/engines/#pyorlib.engines.Engine.solution_status","title":"solution_status  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>solution_status: SolutionStatus\n</code></pre> <p>Get the solution status.</p> RETURNS DESCRIPTION <code>SolutionStatus</code> <p>The status of the current solution.</p>"},{"location":"api/engines/#pyorlib.engines.Engine-functions","title":"Functions","text":""},{"location":"api/engines/#pyorlib.engines.Engine.add_variable","title":"add_variable  <code>abstractmethod</code>","text":"<pre><code>add_variable(name: str, value_type: ValueType, lower_bound: float = 0, upper_bound: float = inf) -&gt; Variable\n</code></pre> <p>Add a new variable to the engine.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the variable.</p> <p> TYPE: <code>str</code> </p> <code>value_type</code> <p>The value type of the variable.</p> <p> TYPE: <code>ValueType</code> </p> <code>lower_bound</code> <p>The lower bound of the variable. Default is 0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>upper_bound</code> <p>The upper bound of the variable. Default is infinity.</p> <p> TYPE: <code>float</code> DEFAULT: <code>inf</code> </p> RETURNS DESCRIPTION <code>Variable</code> <p>The created variable object.</p> Source code in <code>pyorlib/engines/engine.py</code> <pre><code>@abstractmethod\ndef add_variable(\n    self,\n    name: str,\n    value_type: ValueType,\n    lower_bound: float = 0,\n    upper_bound: float = inf,\n) -&gt; Variable:\n    \"\"\"\n    Add a new variable to the engine.\n    :param name: The name of the variable.\n    :param value_type: The value type of the variable.\n    :param lower_bound: The lower bound of the variable. Default is 0.\n    :param upper_bound: The upper bound of the variable. Default is infinity.\n    :return: The created variable object.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/engines/#pyorlib.engines.Engine.add_constraint","title":"add_constraint  <code>abstractmethod</code>","text":"<pre><code>add_constraint(expression: Element) -&gt; Element\n</code></pre> <p>Add a new constraint expression to the engine.</p> PARAMETER DESCRIPTION <code>expression</code> <p>The constraint expression.</p> <p> TYPE: <code>Element</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>The created constraint object.</p> Source code in <code>pyorlib/engines/engine.py</code> <pre><code>@abstractmethod\ndef add_constraint(self, expression: Element) -&gt; Element:\n    \"\"\"\n    Add a new constraint expression to the engine.\n    :param expression: The constraint expression.\n    :return: The created constraint object.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/engines/#pyorlib.engines.Engine.set_objective","title":"set_objective  <code>abstractmethod</code>","text":"<pre><code>set_objective(opt_type: OptimizationType, expression: Element) -&gt; Element\n</code></pre> <p>Defines the objective function.</p> PARAMETER DESCRIPTION <code>opt_type</code> <p>The type of optimization to be performed.</p> <p> TYPE: <code>OptimizationType</code> </p> <code>expression</code> <p>The objective expression.</p> <p> TYPE: <code>Element</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>The objective function.</p> Source code in <code>pyorlib/engines/engine.py</code> <pre><code>@abstractmethod\ndef set_objective(self, opt_type: OptimizationType, expression: Element) -&gt; Element:\n    \"\"\"\n    Defines the objective function.\n    :param opt_type: The type of optimization to be performed.\n    :param expression: The objective expression.\n    :return: The objective function.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/engines/#pyorlib.engines.Engine.solve","title":"solve  <code>abstractmethod</code>","text":"<pre><code>solve() -&gt; None\n</code></pre> <p>Solve the optimization model.</p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>pyorlib/engines/engine.py</code> <pre><code>@abstractmethod\ndef solve(self) -&gt; None:\n    \"\"\"\n    Solve the optimization model.\n    :return: None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/engines/cplex/","title":"<code>CplexEngine</code> class","text":"<p>               Bases: <code>Engine</code></p> <p>Concrete engine implementation using IBM CPLEX optimizer.</p> <p>This class provides an interface for formulating and solving linear, integer, and nonlinear optimization models using the CPLEX solver.</p> Source code in <code>pyorlib/engines/cplex/cplex_engine.py</code> <pre><code>class CplexEngine(Engine):\n    \"\"\"\n    Concrete engine implementation using IBM CPLEX optimizer.\n\n    This class provides an interface for formulating and solving linear,\n    integer, and nonlinear optimization models using the CPLEX solver.\n    \"\"\"\n\n    class _Variable(Variable):\n        \"\"\"\n        Represents a CPLEX variable in an optimization model.\n\n        The `CplexVariable` class is a concrete implementation of the abstract `Variable` class.\n        It represents a variable that is compatible with the CPLEX solver.\n        \"\"\"\n\n        # Strict class attributes.\n        __slots__ = [\"_cplex_var\"]\n\n        @property\n        def name(self) -&gt; str:\n            return str(self._cplex_var.name)\n\n        @property\n        def lower_bound(self) -&gt; float:\n            lb = self._cplex_var.lb\n            return -inf if lb &lt;= -1e20 else float(lb)\n\n        @property\n        def upper_bound(self) -&gt; float:\n            ub = self._cplex_var.ub\n            return inf if ub &gt;= 1e20 else float(ub)\n\n        @property\n        def value(self) -&gt; float:\n            try:\n                return float(self._cplex_var.solution_value)\n            except DOcplexException:\n                return -0.0\n\n        @property\n        def raw(self) -&gt; Any:\n            return self._cplex_var\n\n        def __init__(\n            self,\n            name: str,\n            solver: cpx.Model,\n            value_type: ValueType,\n            lower_bound: float = 0,\n            upper_bound: float = inf,\n        ):\n            \"\"\"\n            Initializes a new `CplexVariable` object with the specified attributes and creates a corresponding CPLEX\n            variable in the specified CPLEX solver.\n            :param name: The name of the variable.\n            :param solver: A reference to the CPLEX solver.\n            :param value_type: An enumeration representing the type of the variable's value.\n            :param lower_bound: The lower bound of the variable. Default is 0.\n            :param upper_bound: The upper bound of the variable. Default is infinity.\n            \"\"\"\n            # Calls the super init method and its validations\n            super().__init__(name=name, value_type=value_type, lower_bound=lower_bound, upper_bound=upper_bound)\n\n            # Applies new validations\n            if solver is None:\n                raise CplexException(\"The 'solver' argument cannot be None.\")\n\n            # Creates the CPLEX variable according to the value type\n            cplex_var: Var | None\n\n            if self.value_type == ValueType.BINARY:\n                cplex_var = solver.binary_var(name=name)\n            elif self.value_type == ValueType.INTEGER:\n                cplex_var = solver.integer_var(name=name, lb=lower_bound, ub=upper_bound)\n            elif self.value_type == ValueType.CONTINUOUS:\n                cplex_var = solver.continuous_var(name=name, lb=lower_bound, ub=upper_bound)\n            else:\n                raise CplexException(\"Unknown ValueType.\")\n\n            # Applies new validations\n            if cplex_var is None:\n                raise CplexException(\"Failed to create the CPLEX variable.\")\n\n            # Instance attributes\n            self._cplex_var: Var = cplex_var\n            \"\"\" A Cplex.Var object representing the variable in the CPLEX solver. \"\"\"\n\n    @property\n    def name(self) -&gt; str:  # pragma: no cover\n        return \"CPLEX Engine\"\n\n    @property\n    def constraints(self) -&gt; List[Element]:\n        return [Expression(expression=constraint) for constraint in self._solver.iter_constraints()]\n\n    @property\n    def objective_value(self) -&gt; float | None:\n        if self.solution_status in [SolutionStatus.OPTIMAL, SolutionStatus.FEASIBLE]:\n            return float(self._solver.objective_value)\n        return None\n\n    @property\n    def objective_expr(self) -&gt; Element | None:\n        objective = self._solver.get_objective_expr()\n        return Expression(expression=objective) if objective is not None else None\n\n    @property\n    def solution_status(self) -&gt; SolutionStatus:  # pragma: no cover\n        if self._solver.solve_details is None:\n            return SolutionStatus.NOT_SOLVED\n\n        # Status Codes\n        optimal_codes = [1, 5, 15, 17, 19, 20, 101, 102, 115, 121, 123, 125, 129, 130, 301]\n        feasible_codes = [14, 16, 18, 23, 30, 120, 124, 127]\n        infeasible_codes = [3, 103]\n\n        if self._solver.solve_details.status_code in optimal_codes:\n            return SolutionStatus.OPTIMAL\n        elif self._solver.solve_details.status_code in feasible_codes:\n            return SolutionStatus.FEASIBLE\n        elif self._solver.solve_details.status_code in infeasible_codes:\n            return SolutionStatus.INFEASIBLE\n        else:\n            StdOutLogger.error(action=\"Error code: \", msg=f\"{self._solver.solve_details.status_code}\")\n            return SolutionStatus.ERROR\n\n    def __init__(self, solver: cpx.Model | None = None):\n        \"\"\"\n        Initialize a CPLEX engine instance.\n        :param solver: A CPLEX solver object. If None, a new solver will be\n            instantiated using CPLEX's default settings. Allows custom\n            configuration of the solver before passing to the engine.\n        \"\"\"\n\n        # Instance attributes\n        self._solver: cpx.Model = solver if solver else cpx.Model(log_output=False)\n        \"\"\" A reference to the CPLEX solver. \"\"\"\n\n        if self._solver is None or not isinstance(self._solver, cpx.Model):\n            raise CplexException(\"The CPLEX solver must be an instance of cpx.Model\")\n\n    def add_variable(\n        self,\n        name: str,\n        value_type: ValueType,\n        lower_bound: float = 0,\n        upper_bound: float = inf,\n    ) -&gt; Variable:\n        return CplexEngine._Variable(\n            name=name,\n            solver=self._solver,\n            value_type=value_type,\n            lower_bound=lower_bound,\n            upper_bound=upper_bound,\n        )\n\n    def add_constraint(self, expression: Element) -&gt; Element:\n        self._solver.add_constraint(ct=expression.raw)\n        return expression\n\n    def set_objective(self, opt_type: OptimizationType, expression: Element) -&gt; Element:\n        if opt_type == OptimizationType.MINIMIZE:\n            self._solver.minimize(expr=expression.raw)\n        elif opt_type == OptimizationType.MAXIMIZE:\n            self._solver.maximize(expr=expression.raw)\n        else:\n            raise CplexException(\"Optimization type not supported.\")\n        return expression\n\n    def solve(self) -&gt; None:\n        self._solver.solve()\n</code></pre> <p></p>"},{"location":"api/engines/cplex/#pyorlib.engines.cplex.CplexEngine-attributes","title":"Attributes","text":""},{"location":"api/engines/cplex/#pyorlib.engines.cplex.CplexEngine.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/engines/cplex/#pyorlib.engines.cplex.CplexEngine.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: List[Element]\n</code></pre>"},{"location":"api/engines/cplex/#pyorlib.engines.cplex.CplexEngine.objective_value","title":"objective_value  <code>property</code>","text":"<pre><code>objective_value: float | None\n</code></pre>"},{"location":"api/engines/cplex/#pyorlib.engines.cplex.CplexEngine.objective_expr","title":"objective_expr  <code>property</code>","text":"<pre><code>objective_expr: Element | None\n</code></pre>"},{"location":"api/engines/cplex/#pyorlib.engines.cplex.CplexEngine.solution_status","title":"solution_status  <code>property</code>","text":"<pre><code>solution_status: SolutionStatus\n</code></pre>"},{"location":"api/engines/cplex/#pyorlib.engines.cplex.CplexEngine-functions","title":"Functions","text":""},{"location":"api/engines/cplex/#pyorlib.engines.cplex.CplexEngine.__init__","title":"__init__","text":"<pre><code>__init__(solver: Model | None = None)\n</code></pre> <p>Initialize a CPLEX engine instance.</p> PARAMETER DESCRIPTION <code>solver</code> <p>A CPLEX solver object. If None, a new solver will be instantiated using CPLEX's default settings. Allows custom configuration of the solver before passing to the engine.</p> <p> TYPE: <code>Model | None</code> DEFAULT: <code>None</code> </p> Source code in <code>pyorlib/engines/cplex/cplex_engine.py</code> <pre><code>def __init__(self, solver: cpx.Model | None = None):\n    \"\"\"\n    Initialize a CPLEX engine instance.\n    :param solver: A CPLEX solver object. If None, a new solver will be\n        instantiated using CPLEX's default settings. Allows custom\n        configuration of the solver before passing to the engine.\n    \"\"\"\n\n    # Instance attributes\n    self._solver: cpx.Model = solver if solver else cpx.Model(log_output=False)\n    \"\"\" A reference to the CPLEX solver. \"\"\"\n\n    if self._solver is None or not isinstance(self._solver, cpx.Model):\n        raise CplexException(\"The CPLEX solver must be an instance of cpx.Model\")\n</code></pre>"},{"location":"api/engines/cplex/#pyorlib.engines.cplex.CplexEngine.add_variable","title":"add_variable","text":"<pre><code>add_variable(name: str, value_type: ValueType, lower_bound: float = 0, upper_bound: float = inf) -&gt; Variable\n</code></pre> Source code in <code>pyorlib/engines/cplex/cplex_engine.py</code> <pre><code>def add_variable(\n    self,\n    name: str,\n    value_type: ValueType,\n    lower_bound: float = 0,\n    upper_bound: float = inf,\n) -&gt; Variable:\n    return CplexEngine._Variable(\n        name=name,\n        solver=self._solver,\n        value_type=value_type,\n        lower_bound=lower_bound,\n        upper_bound=upper_bound,\n    )\n</code></pre>"},{"location":"api/engines/cplex/#pyorlib.engines.cplex.CplexEngine.add_constraint","title":"add_constraint","text":"<pre><code>add_constraint(expression: Element) -&gt; Element\n</code></pre> Source code in <code>pyorlib/engines/cplex/cplex_engine.py</code> <pre><code>def add_constraint(self, expression: Element) -&gt; Element:\n    self._solver.add_constraint(ct=expression.raw)\n    return expression\n</code></pre>"},{"location":"api/engines/cplex/#pyorlib.engines.cplex.CplexEngine.set_objective","title":"set_objective","text":"<pre><code>set_objective(opt_type: OptimizationType, expression: Element) -&gt; Element\n</code></pre> Source code in <code>pyorlib/engines/cplex/cplex_engine.py</code> <pre><code>def set_objective(self, opt_type: OptimizationType, expression: Element) -&gt; Element:\n    if opt_type == OptimizationType.MINIMIZE:\n        self._solver.minimize(expr=expression.raw)\n    elif opt_type == OptimizationType.MAXIMIZE:\n        self._solver.maximize(expr=expression.raw)\n    else:\n        raise CplexException(\"Optimization type not supported.\")\n    return expression\n</code></pre>"},{"location":"api/engines/cplex/#pyorlib.engines.cplex.CplexEngine.solve","title":"solve","text":"<pre><code>solve() -&gt; None\n</code></pre> Source code in <code>pyorlib/engines/cplex/cplex_engine.py</code> <pre><code>def solve(self) -&gt; None:\n    self._solver.solve()\n</code></pre>"},{"location":"api/engines/gurobi/","title":"<code>GurobiEngine</code> class","text":"<p>               Bases: <code>Engine</code></p> <p>Concrete engine implementation using Gurobi solver.</p> <p>This class provides an interface for formulating and solving linear, integer, and nonlinear optimization models using the Gurobi optimizer.</p> Source code in <code>pyorlib/engines/gurobi/gurobi_engine.py</code> <pre><code>class GurobiEngine(Engine):\n    \"\"\"\n    Concrete engine implementation using Gurobi solver.\n\n    This class provides an interface for formulating and solving linear,\n    integer, and nonlinear optimization models using the Gurobi optimizer.\n    \"\"\"\n\n    class _Variable(Variable):\n        \"\"\"\n        Represents a Gurobi variable in an optimization model.\n\n        The `GurobiVariable` class is a concrete implementation of the abstract `Variable` class.\n        It represents a variable that is compatible with the Gurobi solver.\n        \"\"\"\n\n        __slots__ = [\"_gurobi_var\"]\n\n        @property\n        def name(self) -&gt; str:\n            return str(self._gurobi_var.VarName)\n\n        @property\n        def lower_bound(self) -&gt; float:\n            lb = self._gurobi_var.getAttr(\"lb\")\n            return -inf if lb == gp.GRB.INFINITY else float(lb) if lb != -0.0 else 0.0\n\n        @property\n        def upper_bound(self) -&gt; float:\n            ub = self._gurobi_var.getAttr(\"ub\")\n            return inf if ub == gp.GRB.INFINITY else float(ub) if ub != -0.0 else 0.0\n\n        @property\n        def value(self) -&gt; float:\n            try:\n                value = self._gurobi_var.getAttr(\"x\")\n                return float(value) if value != -0.0 else 0.0  # pragma: no cover\n            except AttributeError:\n                return -0.0\n\n        @property\n        def raw(self) -&gt; Any:\n            return self._gurobi_var\n\n        def __init__(\n            self,\n            name: str,\n            solver: gp.Model,\n            value_type: ValueType,\n            lower_bound: float = 0,\n            upper_bound: float = inf,\n        ):\n            \"\"\"\n            Initializes a new `GurobiVariable` object with the specified attributes and creates a\n            corresponding Gurobi variable.\n            :param name: The name of the variable.\n            :param solver: A reference to the Gurobi solver.\n            :param value_type: An enumeration representing the type of the variable's value.\n            :param lower_bound: The lower bound of the variable. Default is 0.\n            :param upper_bound: The upper bound of the variable. Default is infinity.\n            \"\"\"\n            # Calls the super init method and its validations\n            super().__init__(name=name, value_type=value_type, lower_bound=lower_bound, upper_bound=upper_bound)\n\n            # Applies new validations\n            if solver is None:\n                raise GurobiException(\"The 'solver' argument cannot be None.\")\n\n            # Creates the Gurobi variable according to the value type\n            gurobi_var: gp.Var | None\n\n            if self.value_type == ValueType.BINARY:\n                gurobi_var = solver.addVar(lb=0, ub=1, vtype=gp.GRB.BINARY, name=name, column=None, obj=0)\n            elif self.value_type == ValueType.INTEGER:\n                gurobi_var = solver.addVar(\n                    lb=lower_bound,\n                    ub=upper_bound,\n                    vtype=gp.GRB.INTEGER,\n                    name=name,\n                    column=None,\n                    obj=0,\n                )\n            elif self.value_type == ValueType.CONTINUOUS:\n                gurobi_var = solver.addVar(\n                    lb=lower_bound,\n                    ub=upper_bound,\n                    vtype=gp.GRB.CONTINUOUS,\n                    name=name,\n                    column=None,\n                    obj=0,\n                )\n            else:\n                raise GurobiException(\"Unknown ValueType.\")\n\n            # Applies new validations\n            if gurobi_var is None:\n                raise GurobiException(\"Failed to create the Gurobi variable.\")\n\n            # Instance attributes\n            self._gurobi_var: gp.Var = gurobi_var\n            \"\"\" A gp.Var object representing the variable in the Gurobi solver. \"\"\"\n\n            # After creating the variable, we need to update the model in order\n            # to gain access to the newly created variable. This is necessary\n            # because Gurobi employs a lazy update approach.\n            solver.update()\n\n    @property\n    def name(self) -&gt; str:  # pragma: no cover\n        return \"Gurobi Engine\"\n\n    @property\n    def constraints(self) -&gt; List[Element]:\n        return [Expression(expression=constraint) for constraint in self._solver.getConstrs()]\n\n    @property\n    def objective_value(self) -&gt; float | None:\n        if self.solution_status in [SolutionStatus.OPTIMAL, SolutionStatus.FEASIBLE]:\n            return float(self._solver.getObjective().getValue())\n        return None\n\n    @property\n    def objective_expr(self) -&gt; Element | None:\n        objective = self._solver.getObjective()\n        return Expression(expression=objective) if objective is not None else None\n\n    @property\n    def solution_status(self) -&gt; SolutionStatus:  # pragma: no cover\n        if self._solver.status == gp.GRB.LOADED:\n            return SolutionStatus.NOT_SOLVED\n        elif self._solver.status == gp.GRB.OPTIMAL:\n            return SolutionStatus.OPTIMAL\n        elif self._solver.status == gp.GRB.SUBOPTIMAL:\n            return SolutionStatus.FEASIBLE\n        elif self._solver.status == gp.GRB.INFEASIBLE:\n            return SolutionStatus.INFEASIBLE\n        elif self._solver.status in [\n            gp.GRB.TIME_LIMIT,\n            gp.GRB.NODE_LIMIT,\n            gp.GRB.ITERATION_LIMIT,\n            gp.GRB.SOLUTION_LIMIT,\n            gp.GRB.INTERRUPTED,\n            gp.GRB.UNBOUNDED,\n        ]:\n            return SolutionStatus.ERROR\n        else:\n            StdOutLogger.error(action=\"Solution status: \", msg=f\"{self._solver.status}\")\n            raise GurobiException(\"Unhandled Gurobi status code.\")\n\n    def __init__(self, solver: gp.Model | None = None):\n        \"\"\"\n        Initializes a new GurobiEngine instance.\n\n        The solver parameter allows customizing the underlying Gurobi solver.\n        :param solver: A Gurobi solver object. If None, a new solver\n            will be instantiated using the Gurobipy default settings.\n            Allows customizing the solver configuration and behavior.\n        \"\"\"\n\n        # Instance attributes\n        self._solver: gp.Model = solver if solver else gp.Model()\n        \"\"\" A reference to the Gurobi solver. \"\"\"\n\n        if self._solver is None or not isinstance(self._solver, gp.Model):\n            raise GurobiException(\"The Gurobi solver must be an instance of gp.Model\")\n\n        self._solver.setParam(\"OutputFlag\", 0)\n\n    def add_variable(\n        self,\n        name: str,\n        value_type: ValueType,\n        lower_bound: float = 0,\n        upper_bound: float = inf,\n    ) -&gt; Variable:\n        return GurobiEngine._Variable(\n            name=name, solver=self._solver, value_type=value_type, lower_bound=lower_bound, upper_bound=upper_bound\n        )\n\n    def add_constraint(self, expression: Element) -&gt; Element:\n        self._solver.addConstr(expression.raw, name=\"\")\n        self._solver.update()\n        return expression\n\n    def set_objective(self, opt_type: OptimizationType, expression: Element) -&gt; Element:\n        if opt_type == OptimizationType.MINIMIZE:\n            self._solver.setObjective(expression.raw, gp.GRB.MINIMIZE)\n        elif opt_type == OptimizationType.MAXIMIZE:\n            self._solver.setObjective(expression.raw, gp.GRB.MAXIMIZE)\n        else:\n            raise GurobiException(\"Optimization type not supported.\")\n        self._solver.update()\n        return expression\n\n    def solve(self) -&gt; None:\n        self._solver.optimize()\n</code></pre> <p></p>"},{"location":"api/engines/gurobi/#pyorlib.engines.gurobi.GurobiEngine-attributes","title":"Attributes","text":""},{"location":"api/engines/gurobi/#pyorlib.engines.gurobi.GurobiEngine.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/engines/gurobi/#pyorlib.engines.gurobi.GurobiEngine.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: List[Element]\n</code></pre>"},{"location":"api/engines/gurobi/#pyorlib.engines.gurobi.GurobiEngine.objective_value","title":"objective_value  <code>property</code>","text":"<pre><code>objective_value: float | None\n</code></pre>"},{"location":"api/engines/gurobi/#pyorlib.engines.gurobi.GurobiEngine.objective_expr","title":"objective_expr  <code>property</code>","text":"<pre><code>objective_expr: Element | None\n</code></pre>"},{"location":"api/engines/gurobi/#pyorlib.engines.gurobi.GurobiEngine.solution_status","title":"solution_status  <code>property</code>","text":"<pre><code>solution_status: SolutionStatus\n</code></pre>"},{"location":"api/engines/gurobi/#pyorlib.engines.gurobi.GurobiEngine-functions","title":"Functions","text":""},{"location":"api/engines/gurobi/#pyorlib.engines.gurobi.GurobiEngine.__init__","title":"__init__","text":"<pre><code>__init__(solver: Model | None = None)\n</code></pre> <p>Initializes a new GurobiEngine instance.</p> <p>The solver parameter allows customizing the underlying Gurobi solver.</p> PARAMETER DESCRIPTION <code>solver</code> <p>A Gurobi solver object. If None, a new solver will be instantiated using the Gurobipy default settings. Allows customizing the solver configuration and behavior.</p> <p> TYPE: <code>Model | None</code> DEFAULT: <code>None</code> </p> Source code in <code>pyorlib/engines/gurobi/gurobi_engine.py</code> <pre><code>def __init__(self, solver: gp.Model | None = None):\n    \"\"\"\n    Initializes a new GurobiEngine instance.\n\n    The solver parameter allows customizing the underlying Gurobi solver.\n    :param solver: A Gurobi solver object. If None, a new solver\n        will be instantiated using the Gurobipy default settings.\n        Allows customizing the solver configuration and behavior.\n    \"\"\"\n\n    # Instance attributes\n    self._solver: gp.Model = solver if solver else gp.Model()\n    \"\"\" A reference to the Gurobi solver. \"\"\"\n\n    if self._solver is None or not isinstance(self._solver, gp.Model):\n        raise GurobiException(\"The Gurobi solver must be an instance of gp.Model\")\n\n    self._solver.setParam(\"OutputFlag\", 0)\n</code></pre>"},{"location":"api/engines/gurobi/#pyorlib.engines.gurobi.GurobiEngine.add_variable","title":"add_variable","text":"<pre><code>add_variable(name: str, value_type: ValueType, lower_bound: float = 0, upper_bound: float = inf) -&gt; Variable\n</code></pre> Source code in <code>pyorlib/engines/gurobi/gurobi_engine.py</code> <pre><code>def add_variable(\n    self,\n    name: str,\n    value_type: ValueType,\n    lower_bound: float = 0,\n    upper_bound: float = inf,\n) -&gt; Variable:\n    return GurobiEngine._Variable(\n        name=name, solver=self._solver, value_type=value_type, lower_bound=lower_bound, upper_bound=upper_bound\n    )\n</code></pre>"},{"location":"api/engines/gurobi/#pyorlib.engines.gurobi.GurobiEngine.add_constraint","title":"add_constraint","text":"<pre><code>add_constraint(expression: Element) -&gt; Element\n</code></pre> Source code in <code>pyorlib/engines/gurobi/gurobi_engine.py</code> <pre><code>def add_constraint(self, expression: Element) -&gt; Element:\n    self._solver.addConstr(expression.raw, name=\"\")\n    self._solver.update()\n    return expression\n</code></pre>"},{"location":"api/engines/gurobi/#pyorlib.engines.gurobi.GurobiEngine.set_objective","title":"set_objective","text":"<pre><code>set_objective(opt_type: OptimizationType, expression: Element) -&gt; Element\n</code></pre> Source code in <code>pyorlib/engines/gurobi/gurobi_engine.py</code> <pre><code>def set_objective(self, opt_type: OptimizationType, expression: Element) -&gt; Element:\n    if opt_type == OptimizationType.MINIMIZE:\n        self._solver.setObjective(expression.raw, gp.GRB.MINIMIZE)\n    elif opt_type == OptimizationType.MAXIMIZE:\n        self._solver.setObjective(expression.raw, gp.GRB.MAXIMIZE)\n    else:\n        raise GurobiException(\"Optimization type not supported.\")\n    self._solver.update()\n    return expression\n</code></pre>"},{"location":"api/engines/gurobi/#pyorlib.engines.gurobi.GurobiEngine.solve","title":"solve","text":"<pre><code>solve() -&gt; None\n</code></pre> Source code in <code>pyorlib/engines/gurobi/gurobi_engine.py</code> <pre><code>def solve(self) -&gt; None:\n    self._solver.optimize()\n</code></pre>"},{"location":"api/engines/ortools/","title":"<code>ORToolsEngine</code> class","text":"<p>               Bases: <code>Engine</code></p> <p>Concrete engine implementation using Google's OR-Tools linear programming solver.</p> <p>This class provides an interface for formulating and solving linear and integer programming models using the OR-Tools solver.</p> Source code in <code>pyorlib/engines/ortools/ortools_engine.py</code> <pre><code>class ORToolsEngine(Engine):\n    \"\"\"\n    Concrete engine implementation using Google's OR-Tools linear programming solver.\n\n    This class provides an interface for formulating and solving linear and\n    integer programming models using the OR-Tools solver.\n    \"\"\"\n\n    class _Variable(Variable):\n        \"\"\"\n        Represents a OR-Tools variable in an optimization model.\n\n        The `ORToolsVariable` class is a concrete implementation of the abstract `Variable` class.\n        It represents a variable that is compatible with the OR-Tools solver.\n        \"\"\"\n\n        __slots__ = [\"_ortools_var\", \"_solution_status\"]\n\n        @property\n        def name(self) -&gt; str:\n            return str(self._ortools_var.name())\n\n        @property\n        def lower_bound(self) -&gt; float:\n            return float(self._ortools_var.lb())\n\n        @property\n        def upper_bound(self) -&gt; float:\n            return float(self._ortools_var.ub())\n\n        @property\n        def value(self) -&gt; float:\n            if self._solution_status() in [SolutionStatus.OPTIMAL, SolutionStatus.FEASIBLE]:\n                return float(round(self._ortools_var.solution_value(), 6))\n            else:\n                return -0.0\n\n        @property\n        def raw(self) -&gt; Any:\n            return self._ortools_var\n\n        def __init__(\n            self,\n            name: str,\n            solver: Solver,\n            value_type: ValueType,\n            solution_status: Callable[[], SolutionStatus],\n            lower_bound: float = 0,\n            upper_bound: float = inf,\n        ):\n            \"\"\"\n            Initializes a new `ORToolsVariable` object with the specified attributes and creates a\n            corresponding OR-Tools variable.\n            :param name: The name of the variable.\n            :param solver: A reference to the OR-Tools solver.\n            :param value_type: An enumeration representing the type of the variable's value.\n            :param solution_status: A callable function that returns the current solution status.\n            :param lower_bound: The lower bound of the variable. Default is 0.\n            :param upper_bound: The upper bound of the variable. Default is infinity.\n            \"\"\"\n            # Calls the super init method and its validations\n            super().__init__(name=name, value_type=value_type, lower_bound=lower_bound, upper_bound=upper_bound)\n\n            # Applies new validations\n            if solver is None:\n                raise ORToolsException(\"The 'solver' argument cannot be None.\")\n\n            # Creates the OR-Tools variable according to the value type\n            ortools_var: ORToolsVar | None\n\n            if self.value_type == ValueType.BINARY:\n                ortools_var = solver.BoolVar(name=name)\n            elif self.value_type == ValueType.INTEGER:\n                ortools_var = solver.IntVar(name=name, lb=lower_bound, ub=upper_bound)\n            elif self.value_type == ValueType.CONTINUOUS:\n                ortools_var = solver.NumVar(name=name, lb=lower_bound, ub=upper_bound)\n            else:\n                raise ORToolsException(\"Unknown ValueType.\")\n\n            # Applies new validations\n            if solution_status is None:\n                raise ORToolsException(\"The 'solution_status' argument cannot be None.\")\n\n            if ortools_var is None:\n                raise ORToolsException(\"Failed to create the OR-Tools variable.\")\n\n            # Instance attributes\n            self._solution_status: Callable[[], SolutionStatus] = solution_status\n            \"\"\" A callable to check the current status of the solution. \"\"\"\n\n            self._ortools_var: ORToolsVar = ortools_var\n            \"\"\" A pywraplp.Variable object representing the variable in the OR-Tools solver. \"\"\"\n\n    @property\n    def name(self) -&gt; str:  # pragma: no cover\n        return \"OR-Tools Engine\"\n\n    @property\n    def constraints(self) -&gt; List[Element]:\n        return [Expression(expression=constraint) for constraint in self._solver.constraints()]\n\n    @property\n    def objective_value(self) -&gt; float | None:\n        if self.solution_status in [SolutionStatus.OPTIMAL, SolutionStatus.FEASIBLE]:\n            return float(self._solver.Objective().Value())\n        return None\n\n    @property\n    def objective_expr(self) -&gt; Element | None:\n        objective = self._solver.Objective()\n        return Expression(expression=objective) if objective is not None else None\n\n    @property\n    def solution_status(self) -&gt; SolutionStatus:  # pragma: no cover\n        if self._status == Solver.NOT_SOLVED:\n            return SolutionStatus.NOT_SOLVED\n        elif self._status == Solver.OPTIMAL:\n            return SolutionStatus.OPTIMAL\n        elif self._status == Solver.FEASIBLE:\n            return SolutionStatus.FEASIBLE\n        elif self._status == Solver.INFEASIBLE:\n            return SolutionStatus.INFEASIBLE\n        elif self._status in [Solver.UNBOUNDED, Solver.MODEL_INVALID, Solver.ABNORMAL]:\n            return SolutionStatus.ERROR\n        else:\n            StdOutLogger.error(action=\"Solution status: \", msg=f\"{self._status}\")\n            raise ORToolsException(\"Unhandled OR-Tools status code.\")\n\n    def __init__(self, solver: Solver | None = None, solver_params: MPSolverParameters | None = None):\n        \"\"\"\n        Initializes a new instance of the ORToolsEngine class.\n\n        The solver and solver_params parameters enable customizing the\n        underlying OR-Tools solver and its configuration.\n        :param solver: An OR-Tools Solver object. If None, a new OR-Tools Solver\n            will be instantiated using SCIP as its backend solver.\n            Allows customizing the solver type (e.g. GLOP, SCIP).\n        :param solver_params: OR-Tools solver parameters object. If None,\n            default parameters will be used. Allows customizing the\n            solver configuration.\n        \"\"\"\n\n        # Instance attributes\n        self._solver: Solver = solver if solver else Solver.CreateSolver(solver_id=\"SCIP\")\n        \"\"\" A reference to the OR-Tools solver. \"\"\"\n\n        # Set or tools configuration\n        self._solver_params: MPSolverParameters = solver_params if solver_params else MPSolverParameters()\n\n        self._status: int = 6\n        \"\"\" Represents the state of the solution. \"\"\"\n\n        if self._solver is None or not isinstance(self._solver, Solver):\n            raise ORToolsException(\"The OR-Tools solver cannot be None.\")\n\n        if self._solver_params is None:  # pragma: no cover\n            raise ORToolsException(\"The OR-Tools params cannot be None.\")\n\n    def add_variable(\n        self,\n        name: str,\n        value_type: ValueType,\n        lower_bound: float = 0,\n        upper_bound: float = inf,\n    ) -&gt; Variable:\n        return ORToolsEngine._Variable(\n            name=name,\n            solver=self._solver,\n            value_type=value_type,\n            lower_bound=lower_bound,\n            upper_bound=upper_bound,\n            solution_status=lambda: self.solution_status,\n        )\n\n    def add_constraint(self, expression: Element) -&gt; Element:\n        self._solver.Add(constraint=expression.raw)\n        return expression\n\n    def set_objective(self, opt_type: OptimizationType, expression: Element) -&gt; Element:\n        if opt_type == OptimizationType.MINIMIZE:\n            self._solver.Minimize(expr=expression.raw)\n        elif opt_type == OptimizationType.MAXIMIZE:\n            self._solver.Maximize(expr=expression.raw)\n        else:\n            raise ORToolsException(\"Optimization type not supported.\")\n        return expression\n\n    def solve(self) -&gt; None:\n        self._status = self._solver.Solve(self._solver_params)\n</code></pre> <p></p>"},{"location":"api/engines/ortools/#pyorlib.engines.ortools.ORToolsEngine-attributes","title":"Attributes","text":""},{"location":"api/engines/ortools/#pyorlib.engines.ortools.ORToolsEngine.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/engines/ortools/#pyorlib.engines.ortools.ORToolsEngine.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: List[Element]\n</code></pre>"},{"location":"api/engines/ortools/#pyorlib.engines.ortools.ORToolsEngine.objective_value","title":"objective_value  <code>property</code>","text":"<pre><code>objective_value: float | None\n</code></pre>"},{"location":"api/engines/ortools/#pyorlib.engines.ortools.ORToolsEngine.objective_expr","title":"objective_expr  <code>property</code>","text":"<pre><code>objective_expr: Element | None\n</code></pre>"},{"location":"api/engines/ortools/#pyorlib.engines.ortools.ORToolsEngine.solution_status","title":"solution_status  <code>property</code>","text":"<pre><code>solution_status: SolutionStatus\n</code></pre>"},{"location":"api/engines/ortools/#pyorlib.engines.ortools.ORToolsEngine-functions","title":"Functions","text":""},{"location":"api/engines/ortools/#pyorlib.engines.ortools.ORToolsEngine.__init__","title":"__init__","text":"<pre><code>__init__(solver: Solver | None = None, solver_params: MPSolverParameters | None = None)\n</code></pre> <p>Initializes a new instance of the ORToolsEngine class.</p> <p>The solver and solver_params parameters enable customizing the underlying OR-Tools solver and its configuration.</p> PARAMETER DESCRIPTION <code>solver</code> <p>An OR-Tools Solver object. If None, a new OR-Tools Solver will be instantiated using SCIP as its backend solver. Allows customizing the solver type (e.g. GLOP, SCIP).</p> <p> TYPE: <code>Solver | None</code> DEFAULT: <code>None</code> </p> <code>solver_params</code> <p>OR-Tools solver parameters object. If None, default parameters will be used. Allows customizing the solver configuration.</p> <p> TYPE: <code>MPSolverParameters | None</code> DEFAULT: <code>None</code> </p> Source code in <code>pyorlib/engines/ortools/ortools_engine.py</code> <pre><code>def __init__(self, solver: Solver | None = None, solver_params: MPSolverParameters | None = None):\n    \"\"\"\n    Initializes a new instance of the ORToolsEngine class.\n\n    The solver and solver_params parameters enable customizing the\n    underlying OR-Tools solver and its configuration.\n    :param solver: An OR-Tools Solver object. If None, a new OR-Tools Solver\n        will be instantiated using SCIP as its backend solver.\n        Allows customizing the solver type (e.g. GLOP, SCIP).\n    :param solver_params: OR-Tools solver parameters object. If None,\n        default parameters will be used. Allows customizing the\n        solver configuration.\n    \"\"\"\n\n    # Instance attributes\n    self._solver: Solver = solver if solver else Solver.CreateSolver(solver_id=\"SCIP\")\n    \"\"\" A reference to the OR-Tools solver. \"\"\"\n\n    # Set or tools configuration\n    self._solver_params: MPSolverParameters = solver_params if solver_params else MPSolverParameters()\n\n    self._status: int = 6\n    \"\"\" Represents the state of the solution. \"\"\"\n\n    if self._solver is None or not isinstance(self._solver, Solver):\n        raise ORToolsException(\"The OR-Tools solver cannot be None.\")\n\n    if self._solver_params is None:  # pragma: no cover\n        raise ORToolsException(\"The OR-Tools params cannot be None.\")\n</code></pre>"},{"location":"api/engines/ortools/#pyorlib.engines.ortools.ORToolsEngine.add_variable","title":"add_variable","text":"<pre><code>add_variable(name: str, value_type: ValueType, lower_bound: float = 0, upper_bound: float = inf) -&gt; Variable\n</code></pre> Source code in <code>pyorlib/engines/ortools/ortools_engine.py</code> <pre><code>def add_variable(\n    self,\n    name: str,\n    value_type: ValueType,\n    lower_bound: float = 0,\n    upper_bound: float = inf,\n) -&gt; Variable:\n    return ORToolsEngine._Variable(\n        name=name,\n        solver=self._solver,\n        value_type=value_type,\n        lower_bound=lower_bound,\n        upper_bound=upper_bound,\n        solution_status=lambda: self.solution_status,\n    )\n</code></pre>"},{"location":"api/engines/ortools/#pyorlib.engines.ortools.ORToolsEngine.add_constraint","title":"add_constraint","text":"<pre><code>add_constraint(expression: Element) -&gt; Element\n</code></pre> Source code in <code>pyorlib/engines/ortools/ortools_engine.py</code> <pre><code>def add_constraint(self, expression: Element) -&gt; Element:\n    self._solver.Add(constraint=expression.raw)\n    return expression\n</code></pre>"},{"location":"api/engines/ortools/#pyorlib.engines.ortools.ORToolsEngine.set_objective","title":"set_objective","text":"<pre><code>set_objective(opt_type: OptimizationType, expression: Element) -&gt; Element\n</code></pre> Source code in <code>pyorlib/engines/ortools/ortools_engine.py</code> <pre><code>def set_objective(self, opt_type: OptimizationType, expression: Element) -&gt; Element:\n    if opt_type == OptimizationType.MINIMIZE:\n        self._solver.Minimize(expr=expression.raw)\n    elif opt_type == OptimizationType.MAXIMIZE:\n        self._solver.Maximize(expr=expression.raw)\n    else:\n        raise ORToolsException(\"Optimization type not supported.\")\n    return expression\n</code></pre>"},{"location":"api/engines/ortools/#pyorlib.engines.ortools.ORToolsEngine.solve","title":"solve","text":"<pre><code>solve() -&gt; None\n</code></pre> Source code in <code>pyorlib/engines/ortools/ortools_engine.py</code> <pre><code>def solve(self) -&gt; None:\n    self._status = self._solver.Solve(self._solver_params)\n</code></pre>"},{"location":"api/engines/pulp/","title":"<code>PuLPEngine</code> class","text":"<p>               Bases: <code>Engine</code></p> <p>Concrete engine implementation using PuLP.</p> <p>This class provides a PuLP-based implementation of the abstract Engine interface for formulating and solving linear and integer optimization models.</p> Source code in <code>pyorlib/engines/pulp/pulp_engine.py</code> <pre><code>class PuLPEngine(Engine):\n    \"\"\"\n    Concrete engine implementation using PuLP.\n\n    This class provides a PuLP-based implementation of the abstract Engine interface for formulating\n    and solving linear and integer optimization models.\n    \"\"\"\n\n    class _Variable(Variable):\n        \"\"\"\n        Represents a PuLP variable in an optimization model.\n\n        The `PuLPVariable` class is a concrete implementation of the abstract `Variable` class.\n        It represents a variable that is compatible with the PuLP solver.\n        \"\"\"\n\n        # Strict class attributes.\n        __slots__ = [\"_pulp_var\"]\n\n        @property\n        def name(self) -&gt; str:\n            return str(self._pulp_var.name)\n\n        @property\n        def lower_bound(self) -&gt; float:\n            lb = self._pulp_var.lowBound\n            return float(lb) if lb is not None else -inf\n\n        @property\n        def upper_bound(self) -&gt; float:\n            ub = self._pulp_var.upBound\n            return float(ub) if ub is not None else inf\n\n        @property\n        def value(self) -&gt; float:\n            val = self._pulp_var.value()\n            return float(val) if val else -0.0\n\n        @property\n        def raw(self) -&gt; Any:\n            return self._pulp_var\n\n        def __init__(\n            self,\n            name: str,\n            solver: LpProblem,\n            value_type: ValueType,\n            lower_bound: float = 0,\n            upper_bound: float = inf,\n        ):\n            \"\"\"\n            Initializes a new `PuLPVariable` object with the specified attributes and creates a corresponding PuLP\n            variable in the PuLP solver.\n            :param name: The name of the variable.\n            :param solver: A reference to the PuLP solver.\n            :param value_type: An enumeration representing the type of the variable's value.\n            :param lower_bound: The lower bound of the variable. Default is 0.\n            :param upper_bound: The upper bound of the variable. Default is infinity.\n            \"\"\"\n            # Calls the super init method and its validations\n            super().__init__(name=name, value_type=value_type, lower_bound=lower_bound, upper_bound=upper_bound)\n\n            # Applies new validations\n            if solver is None:\n                raise PuLPException(\"The 'solver' argument cannot be None.\")\n\n            # Creates the PuLP variable according to the value type\n            pulp_var: LpVariable | None\n\n            if self.value_type == ValueType.BINARY:\n                pulp_var = LpVariable(name=name, cat=LpBinary, lowBound=0, upBound=1)\n            elif self.value_type == ValueType.INTEGER:\n                pulp_var = LpVariable(\n                    name=name,\n                    cat=LpInteger,\n                    lowBound=lower_bound if lower_bound &gt; -inf else None,\n                    upBound=upper_bound if upper_bound &lt; inf else None,\n                )\n            elif self.value_type == ValueType.CONTINUOUS:\n                pulp_var = LpVariable(\n                    name=name,\n                    cat=LpContinuous,\n                    lowBound=lower_bound if lower_bound &gt; -inf else None,\n                    upBound=upper_bound if upper_bound &lt; inf else None,\n                )\n            else:\n                raise PuLPException(\"Unknown ValueType.\")\n\n            # Applies new validations\n            if pulp_var is None:  # pragma: no cover\n                raise PuLPException(\"Failed to create the PuLP variable.\")\n\n            # Instance attributes\n            self._pulp_var: LpVariable = pulp_var\n            \"\"\" A LpVariable object representing the variable in the PuLP solver. \"\"\"\n\n    @property\n    def name(self) -&gt; str:  # pragma: no cover\n        return \"PuLP Engine\"\n\n    @property\n    def constraints(self) -&gt; List[Element]:\n        return [Expression(expression=constraint) for constraint in self._solver.constraints.values()]\n\n    @property\n    def objective_value(self) -&gt; float | None:\n        if self.solution_status in [SolutionStatus.OPTIMAL, SolutionStatus.FEASIBLE]:\n            return float(value(self._solver.objective))\n        return None\n\n    @property\n    def objective_expr(self) -&gt; Element | None:\n        return Expression(expression=self._objective) if self._objective is not None else None\n\n    @property\n    def solution_status(self) -&gt; SolutionStatus:  # pragma: no cover\n        if self._status == 0:\n            return SolutionStatus.NOT_SOLVED\n        elif self._status == 1:\n            return SolutionStatus.OPTIMAL\n        elif self._status == -1:\n            return SolutionStatus.INFEASIBLE\n        elif self._status in [-2, -3]:\n            return SolutionStatus.ERROR\n        else:\n            StdOutLogger.error(action=\"Solution status: \", msg=f\"{self._status}\")\n            raise PuLPException(\"Unhandled PuLP status code.\")\n\n    def __init__(self, solver: LpProblem | None = None):\n        \"\"\"\n        Initializes the PuLPEngine instance.\n\n        The solver parameter enables the user to pass a pre-configured PuLP solver with custom parameters\n        instead of using the default solver. This allows greater flexibility in specifying solver options.\n        :param solver: A pre-configured PuLP LpProblem\n            object to use as the solver. This allows custom configuration\n            of the solver before passing to the engine. If None, a default\n            solver will be instantiated with default settings.\n            Defaults to None.\n        \"\"\"\n\n        # Instance attributes\n        self._solver: LpProblem = solver if solver else LpProblem()\n        \"\"\" A reference to the PuLP solver. \"\"\"\n\n        if self._solver is None or not isinstance(self._solver, LpProblem):\n            raise PuLPException(\"The PuLP solver cannot be None.\")\n\n        self._objective: Any = None\n        \"\"\" An object representing the optimization function of the problem. \"\"\"\n\n        self._status: int = 0\n        \"\"\" Represents the state of the solution. \"\"\"\n\n    def add_variable(\n        self,\n        name: str,\n        value_type: ValueType,\n        lower_bound: float = 0,\n        upper_bound: float = inf,\n    ) -&gt; Variable:\n        return PuLPEngine._Variable(\n            name=name,\n            solver=self._solver,\n            value_type=value_type,\n            lower_bound=lower_bound,\n            upper_bound=upper_bound,\n        )\n\n    def add_constraint(self, expression: Element) -&gt; Element:\n        self._solver += expression.raw\n        return expression\n\n    def set_objective(self, opt_type: OptimizationType, expression: Element) -&gt; Element:\n        if opt_type == OptimizationType.MINIMIZE:\n            self._solver.sense = LpMinimize\n        elif opt_type == OptimizationType.MAXIMIZE:\n            self._solver.sense = LpMaximize\n        else:\n            raise PuLPException(\"Optimization type not supported.\")\n        self._solver.setObjective(expression.raw)\n        self._objective = expression.raw\n        return expression\n\n    def solve(self) -&gt; None:\n        solve_param = LpSolverDefault.msg = False\n        self._status = self._solver.solve(solve_param)\n</code></pre> <p></p>"},{"location":"api/engines/pulp/#pyorlib.engines.pulp.PuLPEngine-attributes","title":"Attributes","text":""},{"location":"api/engines/pulp/#pyorlib.engines.pulp.PuLPEngine.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/engines/pulp/#pyorlib.engines.pulp.PuLPEngine.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: List[Element]\n</code></pre>"},{"location":"api/engines/pulp/#pyorlib.engines.pulp.PuLPEngine.objective_value","title":"objective_value  <code>property</code>","text":"<pre><code>objective_value: float | None\n</code></pre>"},{"location":"api/engines/pulp/#pyorlib.engines.pulp.PuLPEngine.objective_expr","title":"objective_expr  <code>property</code>","text":"<pre><code>objective_expr: Element | None\n</code></pre>"},{"location":"api/engines/pulp/#pyorlib.engines.pulp.PuLPEngine.solution_status","title":"solution_status  <code>property</code>","text":"<pre><code>solution_status: SolutionStatus\n</code></pre>"},{"location":"api/engines/pulp/#pyorlib.engines.pulp.PuLPEngine-functions","title":"Functions","text":""},{"location":"api/engines/pulp/#pyorlib.engines.pulp.PuLPEngine.__init__","title":"__init__","text":"<pre><code>__init__(solver: LpProblem | None = None)\n</code></pre> <p>Initializes the PuLPEngine instance.</p> <p>The solver parameter enables the user to pass a pre-configured PuLP solver with custom parameters instead of using the default solver. This allows greater flexibility in specifying solver options.</p> PARAMETER DESCRIPTION <code>solver</code> <p>A pre-configured PuLP LpProblem object to use as the solver. This allows custom configuration of the solver before passing to the engine. If None, a default solver will be instantiated with default settings. Defaults to None.</p> <p> TYPE: <code>LpProblem | None</code> DEFAULT: <code>None</code> </p> Source code in <code>pyorlib/engines/pulp/pulp_engine.py</code> <pre><code>def __init__(self, solver: LpProblem | None = None):\n    \"\"\"\n    Initializes the PuLPEngine instance.\n\n    The solver parameter enables the user to pass a pre-configured PuLP solver with custom parameters\n    instead of using the default solver. This allows greater flexibility in specifying solver options.\n    :param solver: A pre-configured PuLP LpProblem\n        object to use as the solver. This allows custom configuration\n        of the solver before passing to the engine. If None, a default\n        solver will be instantiated with default settings.\n        Defaults to None.\n    \"\"\"\n\n    # Instance attributes\n    self._solver: LpProblem = solver if solver else LpProblem()\n    \"\"\" A reference to the PuLP solver. \"\"\"\n\n    if self._solver is None or not isinstance(self._solver, LpProblem):\n        raise PuLPException(\"The PuLP solver cannot be None.\")\n\n    self._objective: Any = None\n    \"\"\" An object representing the optimization function of the problem. \"\"\"\n\n    self._status: int = 0\n    \"\"\" Represents the state of the solution. \"\"\"\n</code></pre>"},{"location":"api/engines/pulp/#pyorlib.engines.pulp.PuLPEngine.add_variable","title":"add_variable","text":"<pre><code>add_variable(name: str, value_type: ValueType, lower_bound: float = 0, upper_bound: float = inf) -&gt; Variable\n</code></pre> Source code in <code>pyorlib/engines/pulp/pulp_engine.py</code> <pre><code>def add_variable(\n    self,\n    name: str,\n    value_type: ValueType,\n    lower_bound: float = 0,\n    upper_bound: float = inf,\n) -&gt; Variable:\n    return PuLPEngine._Variable(\n        name=name,\n        solver=self._solver,\n        value_type=value_type,\n        lower_bound=lower_bound,\n        upper_bound=upper_bound,\n    )\n</code></pre>"},{"location":"api/engines/pulp/#pyorlib.engines.pulp.PuLPEngine.add_constraint","title":"add_constraint","text":"<pre><code>add_constraint(expression: Element) -&gt; Element\n</code></pre> Source code in <code>pyorlib/engines/pulp/pulp_engine.py</code> <pre><code>def add_constraint(self, expression: Element) -&gt; Element:\n    self._solver += expression.raw\n    return expression\n</code></pre>"},{"location":"api/engines/pulp/#pyorlib.engines.pulp.PuLPEngine.set_objective","title":"set_objective","text":"<pre><code>set_objective(opt_type: OptimizationType, expression: Element) -&gt; Element\n</code></pre> Source code in <code>pyorlib/engines/pulp/pulp_engine.py</code> <pre><code>def set_objective(self, opt_type: OptimizationType, expression: Element) -&gt; Element:\n    if opt_type == OptimizationType.MINIMIZE:\n        self._solver.sense = LpMinimize\n    elif opt_type == OptimizationType.MAXIMIZE:\n        self._solver.sense = LpMaximize\n    else:\n        raise PuLPException(\"Optimization type not supported.\")\n    self._solver.setObjective(expression.raw)\n    self._objective = expression.raw\n    return expression\n</code></pre>"},{"location":"api/engines/pulp/#pyorlib.engines.pulp.PuLPEngine.solve","title":"solve","text":"<pre><code>solve() -&gt; None\n</code></pre> Source code in <code>pyorlib/engines/pulp/pulp_engine.py</code> <pre><code>def solve(self) -&gt; None:\n    solve_param = LpSolverDefault.msg = False\n    self._status = self._solver.solve(solve_param)\n</code></pre>"},{"location":"api/enums/","title":"<code>Enums</code> module","text":"<p>The Enums module in PyORlib provides a set of enumerations representing different types and statuses used in optimization and mathematical modeling.</p> <p></p>"},{"location":"api/enums/optimization-type/","title":"<code>OptimizationType</code> enum","text":"<p>               Bases: <code>IntEnum</code></p> <p>An enumeration class representing the type of optimization to be performed.</p> <p>This class extends the <code>IntEnum</code> class and provides two options for optimization types: MINIMIZE and MAXIMIZE.</p> Source code in <code>pyorlib/enums/optimization_type.py</code> <pre><code>class OptimizationType(IntEnum):\n    \"\"\"\n    An enumeration class representing the type of optimization to be performed.\n\n    This class extends the `IntEnum` class and provides two options for\n    optimization types: MINIMIZE and MAXIMIZE.\n    \"\"\"\n\n    MINIMIZE = 1\n    \"\"\" Represents a minimization problem. \"\"\"\n\n    MAXIMIZE = 2\n    \"\"\" Represents a maximization problem. \"\"\"\n</code></pre> <p></p>"},{"location":"api/enums/optimization-type/#pyorlib.enums.OptimizationType-attributes","title":"Attributes","text":""},{"location":"api/enums/optimization-type/#pyorlib.enums.OptimizationType.MINIMIZE","title":"MINIMIZE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINIMIZE = 1\n</code></pre> <p>Represents a minimization problem.</p>"},{"location":"api/enums/optimization-type/#pyorlib.enums.OptimizationType.MAXIMIZE","title":"MAXIMIZE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAXIMIZE = 2\n</code></pre> <p>Represents a maximization problem.</p>"},{"location":"api/enums/parameter-type/","title":"<code>ParameterType</code> enum","text":"<p>               Bases: <code>IntEnum</code></p> <p>An enumeration class representing the types of parameters in an optimization model.</p> <p>Parameters can be categorized as either FIXED, representing parameters under certainty with a single/fixed value, or BOUNDED, representing parameters under uncertainty with a lower and upper limit.</p> Source code in <code>pyorlib/enums/parameter_type.py</code> <pre><code>class ParameterType(IntEnum):\n    \"\"\"\n    An enumeration class representing the types of parameters in an optimization model.\n\n    Parameters can be categorized as either FIXED, representing parameters under certainty with a single/fixed\n    value, or BOUNDED, representing parameters under uncertainty with a lower and upper limit.\n    \"\"\"\n\n    FIXED = 1\n    \"\"\" Represents parameters under certainty with a single/fixed value. \"\"\"\n\n    BOUNDED = 2\n    \"\"\" Represents parameters under uncertainty with a lower and upper limit. \"\"\"\n</code></pre> <p></p>"},{"location":"api/enums/parameter-type/#pyorlib.enums.ParameterType-attributes","title":"Attributes","text":""},{"location":"api/enums/parameter-type/#pyorlib.enums.ParameterType.FIXED","title":"FIXED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FIXED = 1\n</code></pre> <p>Represents parameters under certainty with a single/fixed value.</p>"},{"location":"api/enums/parameter-type/#pyorlib.enums.ParameterType.BOUNDED","title":"BOUNDED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOUNDED = 2\n</code></pre> <p>Represents parameters under uncertainty with a lower and upper limit.</p>"},{"location":"api/enums/solution-status/","title":"<code>SolutionStatus</code> enum","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumerates the possible solution statuses for an optimization model.</p> <p>The SolutionStatus class provides a set of predefined statuses that describe the outcome of an optimization model. These statuses can be used to determine the quality and feasibility of the obtained solution.</p> Source code in <code>pyorlib/enums/solution_status.py</code> <pre><code>class SolutionStatus(IntEnum):\n    \"\"\"\n    Enumerates the possible solution statuses for an optimization model.\n\n    The SolutionStatus class provides a set of predefined statuses that describe the outcome of an\n    optimization model. These statuses can be used to determine the quality and feasibility of\n    the obtained solution.\n    \"\"\"\n\n    OPTIMAL = 1\n    \"\"\" The model has been solved to optimality. \"\"\"\n\n    FEASIBLE = 2\n    \"\"\" The model has been solved but may not be optimal. \"\"\"\n\n    INFEASIBLE = 3\n    \"\"\" The model has been proven to be infeasible. \"\"\"\n\n    NOT_SOLVED = 4\n    \"\"\" The model has not been solved yet. \"\"\"\n\n    ERROR = 5\n    \"\"\" The solver terminated abnormally with some errors. \"\"\"\n</code></pre> <p></p>"},{"location":"api/enums/solution-status/#pyorlib.enums.SolutionStatus-attributes","title":"Attributes","text":""},{"location":"api/enums/solution-status/#pyorlib.enums.SolutionStatus.OPTIMAL","title":"OPTIMAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OPTIMAL = 1\n</code></pre> <p>The model has been solved to optimality.</p>"},{"location":"api/enums/solution-status/#pyorlib.enums.SolutionStatus.FEASIBLE","title":"FEASIBLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FEASIBLE = 2\n</code></pre> <p>The model has been solved but may not be optimal.</p>"},{"location":"api/enums/solution-status/#pyorlib.enums.SolutionStatus.INFEASIBLE","title":"INFEASIBLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INFEASIBLE = 3\n</code></pre> <p>The model has been proven to be infeasible.</p>"},{"location":"api/enums/solution-status/#pyorlib.enums.SolutionStatus.NOT_SOLVED","title":"NOT_SOLVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOT_SOLVED = 4\n</code></pre> <p>The model has not been solved yet.</p>"},{"location":"api/enums/solution-status/#pyorlib.enums.SolutionStatus.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = 5\n</code></pre> <p>The solver terminated abnormally with some errors.</p>"},{"location":"api/enums/term-type/","title":"<code>TermType</code> enum","text":"<p>               Bases: <code>IntEnum</code></p> <p>An enumeration class representing the types of terms in the context of an optimization model.</p> <p>The TermType class provides a set of predefined types that categorize terms according to their behavior.</p> Source code in <code>pyorlib/enums/term_type.py</code> <pre><code>class TermType(IntEnum):\n    \"\"\"\n    An enumeration class representing the types of terms in the context of an optimization model.\n\n    The TermType class provides a set of predefined types that categorize terms according to their behavior.\n    \"\"\"\n\n    CONSTANT = 1\n    \"\"\" Represents a constant term. \"\"\"\n\n    VARIABLE = 2\n    \"\"\" Represents a variable term. \"\"\"\n</code></pre> <p></p>"},{"location":"api/enums/term-type/#pyorlib.enums.TermType-attributes","title":"Attributes","text":""},{"location":"api/enums/term-type/#pyorlib.enums.TermType.CONSTANT","title":"CONSTANT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONSTANT = 1\n</code></pre> <p>Represents a constant term.</p>"},{"location":"api/enums/term-type/#pyorlib.enums.TermType.VARIABLE","title":"VARIABLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VARIABLE = 2\n</code></pre> <p>Represents a variable term.</p>"},{"location":"api/enums/value-type/","title":"<code>ValueType</code> enum","text":"<p>               Bases: <code>IntEnum</code></p> <p>An enumeration class representing the type of value that a parameter or term can take in the context of an optimization model.</p> <p>The ValueType class provides a set of predefined types that categorize the values that a parameter or term can have. These types help describe the nature of the values and guide the optimization algorithm or mathematical modeling techniques.</p> Source code in <code>pyorlib/enums/value_type.py</code> <pre><code>class ValueType(IntEnum):\n    \"\"\"\n    An enumeration class representing the type of value that a parameter or term can take in the context of\n    an optimization model.\n\n    The ValueType class provides a set of predefined types that categorize the values that a parameter\n    or term can have. These types help describe the nature of the values and guide the optimization\n    algorithm or mathematical modeling techniques.\n    \"\"\"\n\n    BINARY = 1\n    \"\"\" Represents a binary value (0 or 1). \"\"\"\n\n    INTEGER = 2\n    \"\"\" Represents an integer value. \"\"\"\n\n    CONTINUOUS = 3\n    \"\"\" Represents a continuous value. \"\"\"\n</code></pre> <p></p>"},{"location":"api/enums/value-type/#pyorlib.enums.ValueType-attributes","title":"Attributes","text":""},{"location":"api/enums/value-type/#pyorlib.enums.ValueType.BINARY","title":"BINARY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BINARY = 1\n</code></pre> <p>Represents a binary value (0 or 1).</p>"},{"location":"api/enums/value-type/#pyorlib.enums.ValueType.INTEGER","title":"INTEGER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTEGER = 2\n</code></pre> <p>Represents an integer value.</p>"},{"location":"api/enums/value-type/#pyorlib.enums.ValueType.CONTINUOUS","title":"CONTINUOUS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONTINUOUS = 3\n</code></pre> <p>Represents a continuous value.</p>"},{"location":"api/exceptions/","title":"<code>Exceptions</code> module","text":"<p>The Exceptions module in PyORlib provides a set of exception classes for handling specific errors and exceptions that may occur during the usage of the library.</p> <p></p>"},{"location":"api/exceptions/cplex-exception/","title":"<code>CplexException</code> exception","text":"<p>               Bases: <code>PyORlibException</code></p> <p>An exception class for handling errors related to the IBM ILOG CPLEX optimization library.</p> <p>The CplexException class is a subclass of the CoreException class and is used to handle exceptions specific to the CPLEX library.</p> Source code in <code>pyorlib/exceptions/cplex_exception.py</code> <pre><code>class CplexException(PyORlibException):\n    \"\"\"\n    An exception class for handling errors related to the IBM ILOG CPLEX optimization library.\n\n    The CplexException class is a subclass of the CoreException class and is used to handle\n    exceptions specific to the CPLEX library.\n    \"\"\"\n\n    def __init__(self, message: str = \"CPLEX Exception\"):\n        super().__init__(message)\n</code></pre> <p></p>"},{"location":"api/exceptions/cplex-exception/#pyorlib.exceptions.CplexException-attributes","title":"Attributes","text":""},{"location":"api/exceptions/cplex-exception/#pyorlib.exceptions.CplexException.errors","title":"errors  <code>instance-attribute</code>","text":"<pre><code>errors: str | List[str] = errors if errors else __name__\n</code></pre>"},{"location":"api/exceptions/cplex-exception/#pyorlib.exceptions.CplexException-functions","title":"Functions","text":""},{"location":"api/exceptions/cplex-exception/#pyorlib.exceptions.CplexException.__init__","title":"__init__","text":"<pre><code>__init__(message: str = 'CPLEX Exception')\n</code></pre> Source code in <code>pyorlib/exceptions/cplex_exception.py</code> <pre><code>def __init__(self, message: str = \"CPLEX Exception\"):\n    super().__init__(message)\n</code></pre>"},{"location":"api/exceptions/gurobi-exception/","title":"<code>GurobiException</code> exception","text":"<p>               Bases: <code>PyORlibException</code></p> <p>An exception class for handling errors related to the Gurobi Optimization library.</p> <p>The GurobiException class is a subclass of the CoreException class and is used to handle exceptions specific to the Gurobi library.</p> Source code in <code>pyorlib/exceptions/gurobi_exception.py</code> <pre><code>class GurobiException(PyORlibException):\n    \"\"\"\n    An exception class for handling errors related to the Gurobi Optimization library.\n\n    The GurobiException class is a subclass of the CoreException class and is used to handle\n    exceptions specific to the Gurobi library.\n    \"\"\"\n\n    def __init__(self, message: str = \"Gurobi exception\"):\n        super().__init__(message)\n</code></pre> <p></p>"},{"location":"api/exceptions/gurobi-exception/#pyorlib.exceptions.GurobiException-attributes","title":"Attributes","text":""},{"location":"api/exceptions/gurobi-exception/#pyorlib.exceptions.GurobiException.errors","title":"errors  <code>instance-attribute</code>","text":"<pre><code>errors: str | List[str] = errors if errors else __name__\n</code></pre>"},{"location":"api/exceptions/gurobi-exception/#pyorlib.exceptions.GurobiException-functions","title":"Functions","text":""},{"location":"api/exceptions/gurobi-exception/#pyorlib.exceptions.GurobiException.__init__","title":"__init__","text":"<pre><code>__init__(message: str = 'Gurobi exception')\n</code></pre> Source code in <code>pyorlib/exceptions/gurobi_exception.py</code> <pre><code>def __init__(self, message: str = \"Gurobi exception\"):\n    super().__init__(message)\n</code></pre>"},{"location":"api/exceptions/model-exception/","title":"<code>ModelException</code> exception","text":"<p>               Bases: <code>PyORlibException</code></p> <p>An exception class for handling errors related to the execution or handling of an optimization model.</p> Source code in <code>pyorlib/exceptions/model_exception.py</code> <pre><code>class ModelException(PyORlibException):\n    \"\"\"\n    An exception class for handling errors related to the execution\n    or handling of an optimization model.\n    \"\"\"\n\n    def __init__(self, message: str = \"Model exception\"):\n        super().__init__(message)\n</code></pre> <p></p>"},{"location":"api/exceptions/model-exception/#pyorlib.exceptions.ModelException-attributes","title":"Attributes","text":""},{"location":"api/exceptions/model-exception/#pyorlib.exceptions.ModelException.errors","title":"errors  <code>instance-attribute</code>","text":"<pre><code>errors: str | List[str] = errors if errors else __name__\n</code></pre>"},{"location":"api/exceptions/model-exception/#pyorlib.exceptions.ModelException-functions","title":"Functions","text":""},{"location":"api/exceptions/model-exception/#pyorlib.exceptions.ModelException.__init__","title":"__init__","text":"<pre><code>__init__(message: str = 'Model exception')\n</code></pre> Source code in <code>pyorlib/exceptions/model_exception.py</code> <pre><code>def __init__(self, message: str = \"Model exception\"):\n    super().__init__(message)\n</code></pre>"},{"location":"api/exceptions/ortools-exception/","title":"<code>ORToolsException</code> exception","text":"<p>               Bases: <code>PyORlibException</code></p> <p>An exception class for handling errors related to the OR-Tools library.</p> <p>The ORToolsException class is a subclass of the CoreException class and is used to handle exceptions specific to the OR-Tools library.</p> Source code in <code>pyorlib/exceptions/ortools_exception.py</code> <pre><code>class ORToolsException(PyORlibException):\n    \"\"\"\n    An exception class for handling errors related to the OR-Tools library.\n\n    The ORToolsException class is a subclass of the CoreException class and is used to handle\n    exceptions specific to the OR-Tools library.\n    \"\"\"\n\n    def __init__(self, message: str = \"OR-Tools exception\"):\n        super().__init__(message)\n</code></pre> <p></p>"},{"location":"api/exceptions/ortools-exception/#pyorlib.exceptions.ORToolsException-attributes","title":"Attributes","text":""},{"location":"api/exceptions/ortools-exception/#pyorlib.exceptions.ORToolsException.errors","title":"errors  <code>instance-attribute</code>","text":"<pre><code>errors: str | List[str] = errors if errors else __name__\n</code></pre>"},{"location":"api/exceptions/ortools-exception/#pyorlib.exceptions.ORToolsException-functions","title":"Functions","text":""},{"location":"api/exceptions/ortools-exception/#pyorlib.exceptions.ORToolsException.__init__","title":"__init__","text":"<pre><code>__init__(message: str = 'OR-Tools exception')\n</code></pre> Source code in <code>pyorlib/exceptions/ortools_exception.py</code> <pre><code>def __init__(self, message: str = \"OR-Tools exception\"):\n    super().__init__(message)\n</code></pre>"},{"location":"api/exceptions/pulp-exception/","title":"<code>PuLPException</code> exception","text":"<p>               Bases: <code>PyORlibException</code></p> <p>An exception class for handling errors related to the PuLP library.</p> <p>The PuLPException class is a subclass of the CoreException class and is used to handle exceptions specific to the PuLP library.</p> Source code in <code>pyorlib/exceptions/pulp_exception.py</code> <pre><code>class PuLPException(PyORlibException):\n    \"\"\"\n    An exception class for handling errors related to the PuLP library.\n\n    The PuLPException class is a subclass of the CoreException class and is used to handle\n    exceptions specific to the PuLP library.\n    \"\"\"\n\n    def __init__(self, message: str = \"PuLP exception\"):\n        super().__init__(message)\n</code></pre> <p></p>"},{"location":"api/exceptions/pulp-exception/#pyorlib.exceptions.PuLPException-attributes","title":"Attributes","text":""},{"location":"api/exceptions/pulp-exception/#pyorlib.exceptions.PuLPException.errors","title":"errors  <code>instance-attribute</code>","text":"<pre><code>errors: str | List[str] = errors if errors else __name__\n</code></pre>"},{"location":"api/exceptions/pulp-exception/#pyorlib.exceptions.PuLPException-functions","title":"Functions","text":""},{"location":"api/exceptions/pulp-exception/#pyorlib.exceptions.PuLPException.__init__","title":"__init__","text":"<pre><code>__init__(message: str = 'PuLP exception')\n</code></pre> Source code in <code>pyorlib/exceptions/pulp_exception.py</code> <pre><code>def __init__(self, message: str = \"PuLP exception\"):\n    super().__init__(message)\n</code></pre>"},{"location":"api/exceptions/term-exception/","title":"<code>TermException</code> exception","text":"<p>               Bases: <code>PyORlibException</code></p> <p>An exception class for handling errors related to terms in an optimization model.</p> <p>The TermException class is a subclass of the CoreException class and is used to handle exceptions specific to terms in a mathematical model, such as validations.</p> Source code in <code>pyorlib/exceptions/term_exception.py</code> <pre><code>class TermException(PyORlibException):\n    \"\"\"\n    An exception class for handling errors related to terms in an optimization model.\n\n    The TermException class is a subclass of the CoreException class and is used to handle\n    exceptions specific to terms in a mathematical model, such as validations.\n    \"\"\"\n\n    def __init__(self, message: str = \"Term exception\"):\n        super().__init__(message)\n</code></pre> <p></p>"},{"location":"api/exceptions/term-exception/#pyorlib.exceptions.TermException-attributes","title":"Attributes","text":""},{"location":"api/exceptions/term-exception/#pyorlib.exceptions.TermException.errors","title":"errors  <code>instance-attribute</code>","text":"<pre><code>errors: str | List[str] = errors if errors else __name__\n</code></pre>"},{"location":"api/exceptions/term-exception/#pyorlib.exceptions.TermException-functions","title":"Functions","text":""},{"location":"api/exceptions/term-exception/#pyorlib.exceptions.TermException.__init__","title":"__init__","text":"<pre><code>__init__(message: str = 'Term exception')\n</code></pre> Source code in <code>pyorlib/exceptions/term_exception.py</code> <pre><code>def __init__(self, message: str = \"Term exception\"):\n    super().__init__(message)\n</code></pre>"},{"location":"api/model/","title":"<code>Model</code> class","text":"<p>Represents a mathematical programming model.</p> <p>The <code>Model</code> class serves as a versatile tool for creating and managing mathematical programming models.</p> <p>As a factory, the <code>Model</code> class provides methods to create optimization objects, decision variables, and constraints, allowing users to build their models step by step.</p> <p>The class also offers various accessors and iterators to efficiently navigate and manipulate the modeling objects within the model. Additionally, the <code>Model</code> class manages solving operations.</p> Source code in <code>pyorlib/model/model.py</code> <pre><code>class Model:\n    \"\"\"\n    Represents a mathematical programming model.\n\n    The `Model` class serves as a versatile tool for creating and managing mathematical programming models.\n\n    As a factory, the `Model` class provides methods to create optimization objects, decision variables,\n    and constraints, allowing users to build their models step by step.\n\n    The class also offers various accessors and iterators to efficiently navigate and manipulate the\n    modeling objects within the model. Additionally, the `Model` class manages solving operations.\n    \"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Retrieves the name of the model.\n        :return: The name assigned to the model.\n        \"\"\"\n        return self._name\n\n    @property\n    def dimensions(self) -&gt; Mapping[str, int]:\n        \"\"\"\n        Retrieves the dimensions and their sizes of the model.\n        :return: A dictionary with dimension names as keys and their sizes as values.\n        \"\"\"\n        return self._dimensions\n\n    @property\n    def constraints(self) -&gt; List[Element]:\n        \"\"\"\n        Retrieves the constraints defined in the model.\n        :return: A list containing the constraints.\n        \"\"\"\n        return self._engine.constraints\n\n    @property\n    def terms(self) -&gt; Mapping[str, Term]:\n        \"\"\"\n        Retrieves a dictionary of individual terms used in the model.\n        :return: A dictionary where the keys represent the names of the\n            terms and the values represent the terms themselves.\n        \"\"\"\n        return self._terms\n\n    @property\n    def term_sets(self) -&gt; Mapping[str, Mapping[Tuple[int, ...], Term]]:\n        \"\"\"\n        Retrieves a dictionary of term sets used in the model.\n        :return: A dictionary where the keys represent the names of the sets and the values\n            represent the sets themselves. Each set of terms is a dictionary with the indices of\n            the terms as keys and the terms themselves as values.\n        \"\"\"\n        return self._term_sets\n\n    @property\n    def objective_value(self) -&gt; float | None:\n        \"\"\"\n        Retrieves the value of the objective function in the model.\n        :return: The value of the objective function, or `None` if the model has\n            not been solved or an objective function is not defined.\n        \"\"\"\n        return self._engine.objective_value\n\n    @property\n    def objective_expr(self) -&gt; Element | None:\n        \"\"\"\n        Retrieves the expression of the objective function in the model, if available.\n        :return: The objective function expression, or `None` if not available.\n        \"\"\"\n        return self._engine.objective_expr\n\n    @property\n    def solution_status(self) -&gt; SolutionStatus:\n        \"\"\"\n        Retrieves an enumeration that represents the state of the solution.\n        :return: An enumeration that represents the state of the solution.\n        \"\"\"\n        return self._engine.solution_status\n\n    @property\n    def float_precision(self) -&gt; int:\n        \"\"\"\n        This property is used to get or set the float precision of the model.\n        The `float_precision` is an integer number of digits, used in printing the solution and objective.\n        :return: The current float precision of the solver.\n        \"\"\"\n        return self._float_precision\n\n    @float_precision.setter\n    def float_precision(self, float_precision: int) -&gt; None:\n        num_digits: int = float_precision\n\n        if float_precision &lt; 0:\n            self._logger.warning(f\"Negative float precision given: {num_digits}, using 0 instead.\")\n            num_digits = 0\n\n        self._float_precision: int = num_digits\n        \"\"\" The float precision is an integer number of digits, used in printing the solution and objective. \"\"\"\n\n    def __init__(self, engine: Engine, name: str | None = None, debug: bool = False, float_precision: int = 6):\n        \"\"\"\n        Initializes a new instance of the `Model` class.\n        :param engine: The engine interface to be used for solving the model.\n        :param name: An optional name for the model. Defaults to None.\n        :param debug: A flag indicating whether debug mode is enabled. Defaults to False.\n        :param float_precision: The number of digits used in printing the solution and objective. Defaults to 6.\n        \"\"\"\n        # Instance attributes\n        self._name: str = name if name else f\"model_{str(uuid4())}\"\n        \"\"\" The name of the model. \"\"\"\n\n        self._logger: Logger = Logger(self._name, debug)\n        \"\"\" An object used for logging messages from the model. \"\"\"\n\n        self._engine: Engine = engine\n        \"\"\" The engine interface used to solve the model. \"\"\"\n\n        self._dimensions: Dict[str, int] = {}\n        \"\"\"  \n        Stores the dimensions of the model. Each dimension is represented by a key-value pair, \n        where the key is the name of the dimension and the value is its size.\n        \"\"\"\n\n        self._terms: Dict[str, Term] = {}\n        \"\"\" \n        Stores individual terms used in the model. Each term is represented by a key-value pair, where \n        the key is the name of the term and the value is the term itself. \n        A term can be a constant value or a variable.\n        \"\"\"\n\n        self._term_sets: Dict[str, Dict[Tuple[int, ...], Term]] = {}\n        \"\"\"\n        Stores sets of terms used in the model. Each set of terms is represented by a key-value pair, \n        where the key is the name of the set and the value is another dictionary. The inner dictionary \n        represents the set of terms, where the keys are indices that uniquely identify each term, \n        and the values are the terms themselves. A term can be a constant value or a variable.\n\n        Example:\n            Z_r_s_t: {\n                (1, 1, 1): Variable,\n                (1, 1, 2): Constant,\n                (2, 1, 1): Variable,\n            }\n        \"\"\"\n\n        if self._engine is None:\n            raise ModelException(\"The engine interface cannot be None.\")\n\n        if self._logger.debug_enabled:  # pragma: no cover\n            self._logger.debug(\n                f\"The '{StdOutColors.PURPLE}{self.name.capitalize()}{StdOutColors.DEFAULT}' has been created.\"\n            )\n\n        self.float_precision = float_precision\n\n    def __save_term(self, term: Term) -&gt; None:\n        \"\"\"\n        Saves a single term in the model.\n        :param term: The term to be saved.\n        :return: None\n        \"\"\"\n        self._terms[term.name] = term\n\n    def __save_term_to_set(self, set_name: str, set_index: Tuple[int, ...], term: Term) -&gt; None:\n        \"\"\"\n        Saves a term into a set within the model.\n        :param set_name: The name of the set where the term will be saved.\n        :param set_index: The index position of the term within the set in the model.\n        :param term: The term to be saved.\n        :return: None\n        \"\"\"\n        if not set_name:\n            raise ModelException(\"Set name cannot be empty.\")\n\n        self.__save_term(term)\n\n        if set_name not in self._term_sets:\n            self._term_sets[set_name] = {}\n\n        self._term_sets[set_name][set_index] = term\n\n    def get_dimension_by_name(self, name: str) -&gt; int:\n        \"\"\"\n        Retrieves the size of a dimension in the model based on its name.\n        :param name: The name of the dimension.\n        :return: The size of the dimension. Returns 0 if the dimension does not exist.\n        \"\"\"\n        return self._dimensions.get(name, 0)\n\n    def get_term_by_name(self, name: str) -&gt; Term | None:\n        \"\"\"\n        Retrieves a term from the model based on its name.\n        :param name: The name of the term.\n        :return: The term with the specified name. Returns `None` if the term does not exist.\n        \"\"\"\n        return self._terms.get(name, None)\n\n    def get_term_set_by_name(self, name: str) -&gt; Mapping[Tuple[int, ...], Term] | None:\n        \"\"\"\n        Retrieves a set of terms from the model based on its name.\n        :param name: The name of the set.\n        :return: The set of terms with the specified name. Returns `None` if the set does not exist.\n        \"\"\"\n        return self._term_sets.get(name, None)\n\n    def add_dimension(self, name: str, value: int) -&gt; int:\n        \"\"\"\n        Adds a new dimension to the model.\n        :param name: The name of the dimension to be added.\n        :param value: The size of the new dimension.\n        :return: The dimension that was added to the model.\n        \"\"\"\n        if not name or value is None or not isinstance(value, int) or value &lt; 1:\n            raise ModelException(\"Invalid dimension values.\")\n        self._dimensions[name] = value\n\n        if self._logger.debug_enabled:  # pragma: no cover\n            self._logger.debug(\n                action=\"Dimension added: \",\n                msg=\"\".join(\n                    [\n                        f\"Name: {StdOutColors.PURPLE}{name}{StdOutColors.DEFAULT} | \",\n                        f\"val: {StdOutColors.PURPLE}{value}{StdOutColors.DEFAULT}\",\n                    ]\n                ),\n            )\n\n        return value\n\n    def add_constant(self, name: str, value_type: ValueType, value: float) -&gt; Constant:\n        \"\"\"\n        Adds a new constant to the model.\n        :param name: The name of the constant to be added.\n        :param value_type: The type of the constant value.\n        :param value: The constant value.\n        :return: The constant that was added to the model.\n        \"\"\"\n        if name in self.terms:\n            raise ModelException(f\"Duplicate term with name: {name}\")\n\n        constant: Constant = Constant(name=name, value_type=value_type, value=value)\n\n        self.__save_term(term=constant)\n\n        if self._logger.debug_enabled:  # pragma: no cover\n            self._logger.debug(\n                action=\"Constant added: \",\n                msg=constant.get_pretty_string(float_precision=self.float_precision),\n            )\n\n        return constant\n\n    def add_variable(\n        self,\n        name: str,\n        value_type: ValueType,\n        lower_bound: float = 0,\n        upper_bound: float = inf,\n    ) -&gt; Variable:\n        \"\"\"\n        Adds a new variable to the model.\n        :param name: The name of the variable to be added.\n        :param value_type: The type of the variable values.\n        :param lower_bound: The lower bound of the variable. Default is 0.\n        :param upper_bound: The upper bound of the variable. Default is infinity.\n        :return: The variable that was added to the model.\n        \"\"\"\n        if name in self.terms:\n            raise ModelException(f\"Duplicate term with name: {name}\")\n\n        variable: Variable = self._engine.add_variable(\n            name=name, value_type=value_type, lower_bound=lower_bound, upper_bound=upper_bound\n        )\n\n        self.__save_term(term=variable)\n\n        if self._logger.debug_enabled:  # pragma: no cover\n            self._logger.debug(\n                action=\"Variable added: \",\n                msg=variable.get_pretty_string(float_precision=self.float_precision),\n            )\n\n        return variable\n\n    def add_constant_to_set(\n        self,\n        set_name: str,\n        set_index: Tuple[int, ...],\n        const_name: str,\n        value_type: ValueType,\n        value: float,\n    ) -&gt; Constant:\n        \"\"\"\n        Adds a new constant to the model within a set.\n        :param set_name: The name of the set where the constant will be added.\n        :param set_index: The position of a term within a set representing its indices.\n        :param const_name: The name of the constant to be saved.\n        :param value_type: The type of the constant value.\n        :param value: The constant value.\n        :return: The constant that was added to the model.\n        \"\"\"\n        if const_name in self.terms:\n            raise ModelException(f\"Duplicate term with name: {const_name}\")\n\n        if set_name in self.term_sets and set_index in self.term_sets[set_name]:\n            raise ModelException(f\"Duplicate set name and index: {set_name} | {set_index}\")\n\n        constant: Constant = Constant(name=const_name, value_type=value_type, value=value)\n\n        self.__save_term_to_set(set_name=set_name, set_index=set_index, term=constant)\n\n        if self._logger.debug_enabled:  # pragma: no cover\n            self._logger.debug(\n                action=\"Constant added to set: \",\n                msg=\"\".join(\n                    [\n                        f\"Set name: {StdOutColors.PURPLE}{set_name}{StdOutColors.DEFAULT} | \",\n                        f\"Set index: {StdOutColors.PURPLE}{set_index}{StdOutColors.DEFAULT} | \",\n                        constant.get_pretty_string(float_precision=self.float_precision),\n                    ]\n                ),\n            )\n\n        return constant\n\n    def add_variable_to_set(\n        self,\n        set_name: str,\n        set_index: Tuple[int, ...],\n        var_name: str,\n        value_type: ValueType,\n        lower_bound: float = 0,\n        upper_bound: float = inf,\n    ) -&gt; Variable:\n        \"\"\"\n        Adds a new variable to the model within a set.\n        :param set_name: The name of the set where the variable will be added.\n        :param set_index: The position of a term within a set that represents its indices.\n        :param var_name: The name of the variable to be added.\n        :param value_type: The type of the variable values.\n        :param lower_bound: The lower bound of the variable. Default is 0.\n        :param upper_bound: The upper bound of the variable. Default is infinity.\n        :return: The variable that was added to the model.\n        \"\"\"\n        if var_name in self.terms:\n            raise ModelException(f\"Duplicate term with name: {var_name}\")\n\n        if set_name in self.term_sets and set_index in self.term_sets[set_name]:\n            raise ModelException(f\"Duplicate set name and index: {set_name} | {set_index}\")\n\n        variable: Variable = self._engine.add_variable(\n            name=var_name, value_type=value_type, lower_bound=lower_bound, upper_bound=upper_bound\n        )\n\n        self.__save_term_to_set(set_name=set_name, set_index=set_index, term=variable)\n\n        if self._logger.debug_enabled:  # pragma: no cover\n            self._logger.debug(\n                action=\"Variable added to set: \",\n                msg=\"\".join(\n                    [\n                        f\"Set name: {StdOutColors.PURPLE}{set_name}{StdOutColors.DEFAULT} | \",\n                        f\"Set index: {StdOutColors.PURPLE}{set_index}{StdOutColors.DEFAULT} | \",\n                        variable.get_pretty_string(float_precision=self.float_precision),\n                    ]\n                ),\n            )\n\n        return variable\n\n    def add_constraint(self, expression: Element) -&gt; Element:\n        \"\"\"\n        Adds a new constraint to the model.\n        :param expression: The constraint expression\n        :return: An object representing the constraint.\n        \"\"\"\n        constraint: Element = self._engine.add_constraint(expression=expression)\n\n        if self._logger.debug_enabled:  # pragma: no cover\n            try:\n                self._logger.debug(action=\"Constraint added: \", msg=f\"Expr: {expression}\")\n            except RecursionError:\n                self._logger.debug(action=\"Constraint added: \", msg=\"Expr: Unprintable expression\")\n\n        return constraint\n\n    def set_objective(self, opt_type: OptimizationType, expression: Element) -&gt; Element:\n        \"\"\"\n        Defines the objective function.\n        :param opt_type: The type of optimization to be performed.\n        :param expression: The objective expression.\n        :return: The objective function.\n        \"\"\"\n        objective: Element = self._engine.set_objective(opt_type=opt_type, expression=expression)\n\n        if self._logger.debug_enabled:  # pragma: no cover\n            try:\n                self._logger.debug(\n                    action=\"Objective function added: \",\n                    msg=\"\".join(\n                        [\n                            f\"Opt Type: {StdOutColors.PURPLE}{opt_type.name.capitalize()}{StdOutColors.DEFAULT} | \",\n                            f\"Expr: {objective}\",\n                        ]\n                    ),\n                )\n            except RecursionError:\n                self._logger.debug(action=\"Objective function added: \", msg=\"Expr: Unprintable expression\")\n\n        return objective\n\n    def solve(self) -&gt; None:\n        \"\"\"\n        Solves the optimization problem represented by the model.\n        :return: None.\n        \"\"\"\n        if self._logger.debug_enabled:  # pragma: no cover\n            self._logger.debug(f\"Solving the model...\")\n\n        self._engine.solve()\n\n        if self._logger.debug_enabled:  # pragma: no cover\n            self._logger.debug(f\"The model has been solved.\")\n\n    def print_info(self, display_term_sets: bool = False) -&gt; None:  # pragma: no cover\n        \"\"\"\n        Prints information about the model.\n        :param display_term_sets: Whether to display information about term sets. Defaults to False.\n        :return: None.\n        \"\"\"\n        default, debug = StdOutColors.DEFAULT, StdOutColors.PURPLE\n        print(f\"\\n------ MODEL INFORMATION ------\\n\")\n        print(\"Model properties:\")\n        print(f\"\\tName: {debug}{self.name}{default}\")\n        print(\"Objective function:\")\n        print(f\"\\tExpression: {self.objective_expr}\")\n        print(f\"\\tStatus: {debug}{self.solution_status.name}{default}\")\n        print(\n            f\"\\tValue: {debug}\",\n            (\n                \"{0:.{prec}g}\".format(self.objective_value, prec=self.float_precision)\n                if self.objective_value is not None\n                else \"--\"\n            ),\n            f\"{default}\",\n        )\n\n        print(f\"Dimensions: {debug}{len(self.dimensions)}{default}\")\n        for name, size in self.dimensions.items():\n            print(\n                f\"\\tName: {debug}{name}{default} | \",\n                f\"Val: {debug}{size}{default}\",\n            )\n\n        print(f\"Terms: {debug}{len(self.terms)}{default}\")\n        for name, term in self.terms.items():\n            print(f\"\\t{term.get_pretty_string(float_precision=self.float_precision)}\")\n        if display_term_sets:\n            print(f\"Terms Sets: {debug}{len(self.term_sets)}{default}\")\n            for name, terms in self.term_sets.items():\n                print(f\"\\tTerm: {debug}{name}{default}\")\n                for index, term in terms.items():\n                    print(\n                        f\"\\t\\tIndex: {debug}{index}{default} | \",\n                        f\"{term.get_pretty_string(float_precision=self.float_precision)}\",\n                    )\n\n        constraints = self.constraints\n        print(f\"Constraints: {debug}{len(constraints)}{default}\")\n        for exp in constraints:\n            try:\n                print(f\"\\tExpression: {exp}\")\n            except RecursionError:\n                print(\"\\tExpression: Print Error\")\n        print()\n\n    def print_solution(self) -&gt; None:  # pragma: no cover\n        \"\"\"\n        Prints the solution of the optimization problem.\n        :return: None.\n        \"\"\"\n        default, debug = StdOutColors.DEFAULT, StdOutColors.PURPLE\n        print(f\"\\n------ MODEL SOLUTION ------\\n\")\n        print(\"Objective function:\")\n        print(f\"\\tStatus: {debug}{self.solution_status.name}{default}\")\n        print(\n            f\"\\tValue: {debug}\",\n            (\n                \"{0:.{prec}g}\".format(self.objective_value, prec=self.float_precision)\n                if self.objective_value is not None\n                else \"--\"\n            ),\n            f\"{default}\",\n        )\n\n        solution_variables: Dict[str, Term] = {\n            name: term for name, term in self.terms.items() if (term.is_variable and term.value != 0)\n        }\n\n        if solution_variables:\n            print(\"Terms:\")\n            for name, term in solution_variables.items():\n                print(f\"\\t{term.get_pretty_string(float_precision=self.float_precision)}\")\n\n        print()\n</code></pre> <p></p>"},{"location":"api/model/#pyorlib.model.Model-attributes","title":"Attributes","text":""},{"location":"api/model/#pyorlib.model.Model.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Retrieves the name of the model.</p> RETURNS DESCRIPTION <code>str</code> <p>The name assigned to the model.</p>"},{"location":"api/model/#pyorlib.model.Model.dimensions","title":"dimensions  <code>property</code>","text":"<pre><code>dimensions: Mapping[str, int]\n</code></pre> <p>Retrieves the dimensions and their sizes of the model.</p> RETURNS DESCRIPTION <code>Mapping[str, int]</code> <p>A dictionary with dimension names as keys and their sizes as values.</p>"},{"location":"api/model/#pyorlib.model.Model.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: List[Element]\n</code></pre> <p>Retrieves the constraints defined in the model.</p> RETURNS DESCRIPTION <code>List[Element]</code> <p>A list containing the constraints.</p>"},{"location":"api/model/#pyorlib.model.Model.terms","title":"terms  <code>property</code>","text":"<pre><code>terms: Mapping[str, Term]\n</code></pre> <p>Retrieves a dictionary of individual terms used in the model.</p> RETURNS DESCRIPTION <code>Mapping[str, Term]</code> <p>A dictionary where the keys represent the names of the terms and the values represent the terms themselves.</p>"},{"location":"api/model/#pyorlib.model.Model.term_sets","title":"term_sets  <code>property</code>","text":"<pre><code>term_sets: Mapping[str, Mapping[Tuple[int, ...], Term]]\n</code></pre> <p>Retrieves a dictionary of term sets used in the model.</p> RETURNS DESCRIPTION <code>Mapping[str, Mapping[Tuple[int, ...], Term]]</code> <p>A dictionary where the keys represent the names of the sets and the values represent the sets themselves. Each set of terms is a dictionary with the indices of the terms as keys and the terms themselves as values.</p>"},{"location":"api/model/#pyorlib.model.Model.objective_value","title":"objective_value  <code>property</code>","text":"<pre><code>objective_value: float | None\n</code></pre> <p>Retrieves the value of the objective function in the model.</p> RETURNS DESCRIPTION <code>float | None</code> <p>The value of the objective function, or <code>None</code> if the model has not been solved or an objective function is not defined.</p>"},{"location":"api/model/#pyorlib.model.Model.objective_expr","title":"objective_expr  <code>property</code>","text":"<pre><code>objective_expr: Element | None\n</code></pre> <p>Retrieves the expression of the objective function in the model, if available.</p> RETURNS DESCRIPTION <code>Element | None</code> <p>The objective function expression, or <code>None</code> if not available.</p>"},{"location":"api/model/#pyorlib.model.Model.solution_status","title":"solution_status  <code>property</code>","text":"<pre><code>solution_status: SolutionStatus\n</code></pre> <p>Retrieves an enumeration that represents the state of the solution.</p> RETURNS DESCRIPTION <code>SolutionStatus</code> <p>An enumeration that represents the state of the solution.</p>"},{"location":"api/model/#pyorlib.model.Model.float_precision","title":"float_precision  <code>instance-attribute</code> <code>property</code> <code>writable</code>","text":"<pre><code>float_precision: int = float_precision\n</code></pre> <p>This property is used to get or set the float precision of the model. The <code>float_precision</code> is an integer number of digits, used in printing the solution and objective.</p> RETURNS DESCRIPTION <code>int</code> <p>The current float precision of the solver.</p>"},{"location":"api/model/#pyorlib.model.Model-functions","title":"Functions","text":""},{"location":"api/model/#pyorlib.model.Model.__init__","title":"__init__","text":"<pre><code>__init__(engine: Engine, name: str | None = None, debug: bool = False, float_precision: int = 6)\n</code></pre> <p>Initializes a new instance of the <code>Model</code> class.</p> PARAMETER DESCRIPTION <code>engine</code> <p>The engine interface to be used for solving the model.</p> <p> TYPE: <code>Engine</code> </p> <code>name</code> <p>An optional name for the model. Defaults to None.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>debug</code> <p>A flag indicating whether debug mode is enabled. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>float_precision</code> <p>The number of digits used in printing the solution and objective. Defaults to 6.</p> <p> TYPE: <code>int</code> DEFAULT: <code>6</code> </p> Source code in <code>pyorlib/model/model.py</code> <pre><code>def __init__(self, engine: Engine, name: str | None = None, debug: bool = False, float_precision: int = 6):\n    \"\"\"\n    Initializes a new instance of the `Model` class.\n    :param engine: The engine interface to be used for solving the model.\n    :param name: An optional name for the model. Defaults to None.\n    :param debug: A flag indicating whether debug mode is enabled. Defaults to False.\n    :param float_precision: The number of digits used in printing the solution and objective. Defaults to 6.\n    \"\"\"\n    # Instance attributes\n    self._name: str = name if name else f\"model_{str(uuid4())}\"\n    \"\"\" The name of the model. \"\"\"\n\n    self._logger: Logger = Logger(self._name, debug)\n    \"\"\" An object used for logging messages from the model. \"\"\"\n\n    self._engine: Engine = engine\n    \"\"\" The engine interface used to solve the model. \"\"\"\n\n    self._dimensions: Dict[str, int] = {}\n    \"\"\"  \n    Stores the dimensions of the model. Each dimension is represented by a key-value pair, \n    where the key is the name of the dimension and the value is its size.\n    \"\"\"\n\n    self._terms: Dict[str, Term] = {}\n    \"\"\" \n    Stores individual terms used in the model. Each term is represented by a key-value pair, where \n    the key is the name of the term and the value is the term itself. \n    A term can be a constant value or a variable.\n    \"\"\"\n\n    self._term_sets: Dict[str, Dict[Tuple[int, ...], Term]] = {}\n    \"\"\"\n    Stores sets of terms used in the model. Each set of terms is represented by a key-value pair, \n    where the key is the name of the set and the value is another dictionary. The inner dictionary \n    represents the set of terms, where the keys are indices that uniquely identify each term, \n    and the values are the terms themselves. A term can be a constant value or a variable.\n\n    Example:\n        Z_r_s_t: {\n            (1, 1, 1): Variable,\n            (1, 1, 2): Constant,\n            (2, 1, 1): Variable,\n        }\n    \"\"\"\n\n    if self._engine is None:\n        raise ModelException(\"The engine interface cannot be None.\")\n\n    if self._logger.debug_enabled:  # pragma: no cover\n        self._logger.debug(\n            f\"The '{StdOutColors.PURPLE}{self.name.capitalize()}{StdOutColors.DEFAULT}' has been created.\"\n        )\n\n    self.float_precision = float_precision\n</code></pre>"},{"location":"api/model/#pyorlib.model.Model.get_dimension_by_name","title":"get_dimension_by_name","text":"<pre><code>get_dimension_by_name(name: str) -&gt; int\n</code></pre> <p>Retrieves the size of a dimension in the model based on its name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the dimension.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The size of the dimension. Returns 0 if the dimension does not exist.</p> Source code in <code>pyorlib/model/model.py</code> <pre><code>def get_dimension_by_name(self, name: str) -&gt; int:\n    \"\"\"\n    Retrieves the size of a dimension in the model based on its name.\n    :param name: The name of the dimension.\n    :return: The size of the dimension. Returns 0 if the dimension does not exist.\n    \"\"\"\n    return self._dimensions.get(name, 0)\n</code></pre>"},{"location":"api/model/#pyorlib.model.Model.get_term_by_name","title":"get_term_by_name","text":"<pre><code>get_term_by_name(name: str) -&gt; Term | None\n</code></pre> <p>Retrieves a term from the model based on its name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the term.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Term | None</code> <p>The term with the specified name. Returns <code>None</code> if the term does not exist.</p> Source code in <code>pyorlib/model/model.py</code> <pre><code>def get_term_by_name(self, name: str) -&gt; Term | None:\n    \"\"\"\n    Retrieves a term from the model based on its name.\n    :param name: The name of the term.\n    :return: The term with the specified name. Returns `None` if the term does not exist.\n    \"\"\"\n    return self._terms.get(name, None)\n</code></pre>"},{"location":"api/model/#pyorlib.model.Model.get_term_set_by_name","title":"get_term_set_by_name","text":"<pre><code>get_term_set_by_name(name: str) -&gt; Mapping[Tuple[int, ...], Term] | None\n</code></pre> <p>Retrieves a set of terms from the model based on its name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the set.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Mapping[Tuple[int, ...], Term] | None</code> <p>The set of terms with the specified name. Returns <code>None</code> if the set does not exist.</p> Source code in <code>pyorlib/model/model.py</code> <pre><code>def get_term_set_by_name(self, name: str) -&gt; Mapping[Tuple[int, ...], Term] | None:\n    \"\"\"\n    Retrieves a set of terms from the model based on its name.\n    :param name: The name of the set.\n    :return: The set of terms with the specified name. Returns `None` if the set does not exist.\n    \"\"\"\n    return self._term_sets.get(name, None)\n</code></pre>"},{"location":"api/model/#pyorlib.model.Model.add_dimension","title":"add_dimension","text":"<pre><code>add_dimension(name: str, value: int) -&gt; int\n</code></pre> <p>Adds a new dimension to the model.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the dimension to be added.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>The size of the new dimension.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The dimension that was added to the model.</p> Source code in <code>pyorlib/model/model.py</code> <pre><code>def add_dimension(self, name: str, value: int) -&gt; int:\n    \"\"\"\n    Adds a new dimension to the model.\n    :param name: The name of the dimension to be added.\n    :param value: The size of the new dimension.\n    :return: The dimension that was added to the model.\n    \"\"\"\n    if not name or value is None or not isinstance(value, int) or value &lt; 1:\n        raise ModelException(\"Invalid dimension values.\")\n    self._dimensions[name] = value\n\n    if self._logger.debug_enabled:  # pragma: no cover\n        self._logger.debug(\n            action=\"Dimension added: \",\n            msg=\"\".join(\n                [\n                    f\"Name: {StdOutColors.PURPLE}{name}{StdOutColors.DEFAULT} | \",\n                    f\"val: {StdOutColors.PURPLE}{value}{StdOutColors.DEFAULT}\",\n                ]\n            ),\n        )\n\n    return value\n</code></pre>"},{"location":"api/model/#pyorlib.model.Model.add_constant","title":"add_constant","text":"<pre><code>add_constant(name: str, value_type: ValueType, value: float) -&gt; Constant\n</code></pre> <p>Adds a new constant to the model.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the constant to be added.</p> <p> TYPE: <code>str</code> </p> <code>value_type</code> <p>The type of the constant value.</p> <p> TYPE: <code>ValueType</code> </p> <code>value</code> <p>The constant value.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Constant</code> <p>The constant that was added to the model.</p> Source code in <code>pyorlib/model/model.py</code> <pre><code>def add_constant(self, name: str, value_type: ValueType, value: float) -&gt; Constant:\n    \"\"\"\n    Adds a new constant to the model.\n    :param name: The name of the constant to be added.\n    :param value_type: The type of the constant value.\n    :param value: The constant value.\n    :return: The constant that was added to the model.\n    \"\"\"\n    if name in self.terms:\n        raise ModelException(f\"Duplicate term with name: {name}\")\n\n    constant: Constant = Constant(name=name, value_type=value_type, value=value)\n\n    self.__save_term(term=constant)\n\n    if self._logger.debug_enabled:  # pragma: no cover\n        self._logger.debug(\n            action=\"Constant added: \",\n            msg=constant.get_pretty_string(float_precision=self.float_precision),\n        )\n\n    return constant\n</code></pre>"},{"location":"api/model/#pyorlib.model.Model.add_variable","title":"add_variable","text":"<pre><code>add_variable(name: str, value_type: ValueType, lower_bound: float = 0, upper_bound: float = inf) -&gt; Variable\n</code></pre> <p>Adds a new variable to the model.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the variable to be added.</p> <p> TYPE: <code>str</code> </p> <code>value_type</code> <p>The type of the variable values.</p> <p> TYPE: <code>ValueType</code> </p> <code>lower_bound</code> <p>The lower bound of the variable. Default is 0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>upper_bound</code> <p>The upper bound of the variable. Default is infinity.</p> <p> TYPE: <code>float</code> DEFAULT: <code>inf</code> </p> RETURNS DESCRIPTION <code>Variable</code> <p>The variable that was added to the model.</p> Source code in <code>pyorlib/model/model.py</code> <pre><code>def add_variable(\n    self,\n    name: str,\n    value_type: ValueType,\n    lower_bound: float = 0,\n    upper_bound: float = inf,\n) -&gt; Variable:\n    \"\"\"\n    Adds a new variable to the model.\n    :param name: The name of the variable to be added.\n    :param value_type: The type of the variable values.\n    :param lower_bound: The lower bound of the variable. Default is 0.\n    :param upper_bound: The upper bound of the variable. Default is infinity.\n    :return: The variable that was added to the model.\n    \"\"\"\n    if name in self.terms:\n        raise ModelException(f\"Duplicate term with name: {name}\")\n\n    variable: Variable = self._engine.add_variable(\n        name=name, value_type=value_type, lower_bound=lower_bound, upper_bound=upper_bound\n    )\n\n    self.__save_term(term=variable)\n\n    if self._logger.debug_enabled:  # pragma: no cover\n        self._logger.debug(\n            action=\"Variable added: \",\n            msg=variable.get_pretty_string(float_precision=self.float_precision),\n        )\n\n    return variable\n</code></pre>"},{"location":"api/model/#pyorlib.model.Model.add_constant_to_set","title":"add_constant_to_set","text":"<pre><code>add_constant_to_set(set_name: str, set_index: Tuple[int, ...], const_name: str, value_type: ValueType, value: float) -&gt; Constant\n</code></pre> <p>Adds a new constant to the model within a set.</p> PARAMETER DESCRIPTION <code>set_name</code> <p>The name of the set where the constant will be added.</p> <p> TYPE: <code>str</code> </p> <code>set_index</code> <p>The position of a term within a set representing its indices.</p> <p> TYPE: <code>Tuple[int, ...]</code> </p> <code>const_name</code> <p>The name of the constant to be saved.</p> <p> TYPE: <code>str</code> </p> <code>value_type</code> <p>The type of the constant value.</p> <p> TYPE: <code>ValueType</code> </p> <code>value</code> <p>The constant value.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>Constant</code> <p>The constant that was added to the model.</p> Source code in <code>pyorlib/model/model.py</code> <pre><code>def add_constant_to_set(\n    self,\n    set_name: str,\n    set_index: Tuple[int, ...],\n    const_name: str,\n    value_type: ValueType,\n    value: float,\n) -&gt; Constant:\n    \"\"\"\n    Adds a new constant to the model within a set.\n    :param set_name: The name of the set where the constant will be added.\n    :param set_index: The position of a term within a set representing its indices.\n    :param const_name: The name of the constant to be saved.\n    :param value_type: The type of the constant value.\n    :param value: The constant value.\n    :return: The constant that was added to the model.\n    \"\"\"\n    if const_name in self.terms:\n        raise ModelException(f\"Duplicate term with name: {const_name}\")\n\n    if set_name in self.term_sets and set_index in self.term_sets[set_name]:\n        raise ModelException(f\"Duplicate set name and index: {set_name} | {set_index}\")\n\n    constant: Constant = Constant(name=const_name, value_type=value_type, value=value)\n\n    self.__save_term_to_set(set_name=set_name, set_index=set_index, term=constant)\n\n    if self._logger.debug_enabled:  # pragma: no cover\n        self._logger.debug(\n            action=\"Constant added to set: \",\n            msg=\"\".join(\n                [\n                    f\"Set name: {StdOutColors.PURPLE}{set_name}{StdOutColors.DEFAULT} | \",\n                    f\"Set index: {StdOutColors.PURPLE}{set_index}{StdOutColors.DEFAULT} | \",\n                    constant.get_pretty_string(float_precision=self.float_precision),\n                ]\n            ),\n        )\n\n    return constant\n</code></pre>"},{"location":"api/model/#pyorlib.model.Model.add_variable_to_set","title":"add_variable_to_set","text":"<pre><code>add_variable_to_set(set_name: str, set_index: Tuple[int, ...], var_name: str, value_type: ValueType, lower_bound: float = 0, upper_bound: float = inf) -&gt; Variable\n</code></pre> <p>Adds a new variable to the model within a set.</p> PARAMETER DESCRIPTION <code>set_name</code> <p>The name of the set where the variable will be added.</p> <p> TYPE: <code>str</code> </p> <code>set_index</code> <p>The position of a term within a set that represents its indices.</p> <p> TYPE: <code>Tuple[int, ...]</code> </p> <code>var_name</code> <p>The name of the variable to be added.</p> <p> TYPE: <code>str</code> </p> <code>value_type</code> <p>The type of the variable values.</p> <p> TYPE: <code>ValueType</code> </p> <code>lower_bound</code> <p>The lower bound of the variable. Default is 0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>upper_bound</code> <p>The upper bound of the variable. Default is infinity.</p> <p> TYPE: <code>float</code> DEFAULT: <code>inf</code> </p> RETURNS DESCRIPTION <code>Variable</code> <p>The variable that was added to the model.</p> Source code in <code>pyorlib/model/model.py</code> <pre><code>def add_variable_to_set(\n    self,\n    set_name: str,\n    set_index: Tuple[int, ...],\n    var_name: str,\n    value_type: ValueType,\n    lower_bound: float = 0,\n    upper_bound: float = inf,\n) -&gt; Variable:\n    \"\"\"\n    Adds a new variable to the model within a set.\n    :param set_name: The name of the set where the variable will be added.\n    :param set_index: The position of a term within a set that represents its indices.\n    :param var_name: The name of the variable to be added.\n    :param value_type: The type of the variable values.\n    :param lower_bound: The lower bound of the variable. Default is 0.\n    :param upper_bound: The upper bound of the variable. Default is infinity.\n    :return: The variable that was added to the model.\n    \"\"\"\n    if var_name in self.terms:\n        raise ModelException(f\"Duplicate term with name: {var_name}\")\n\n    if set_name in self.term_sets and set_index in self.term_sets[set_name]:\n        raise ModelException(f\"Duplicate set name and index: {set_name} | {set_index}\")\n\n    variable: Variable = self._engine.add_variable(\n        name=var_name, value_type=value_type, lower_bound=lower_bound, upper_bound=upper_bound\n    )\n\n    self.__save_term_to_set(set_name=set_name, set_index=set_index, term=variable)\n\n    if self._logger.debug_enabled:  # pragma: no cover\n        self._logger.debug(\n            action=\"Variable added to set: \",\n            msg=\"\".join(\n                [\n                    f\"Set name: {StdOutColors.PURPLE}{set_name}{StdOutColors.DEFAULT} | \",\n                    f\"Set index: {StdOutColors.PURPLE}{set_index}{StdOutColors.DEFAULT} | \",\n                    variable.get_pretty_string(float_precision=self.float_precision),\n                ]\n            ),\n        )\n\n    return variable\n</code></pre>"},{"location":"api/model/#pyorlib.model.Model.add_constraint","title":"add_constraint","text":"<pre><code>add_constraint(expression: Element) -&gt; Element\n</code></pre> <p>Adds a new constraint to the model.</p> PARAMETER DESCRIPTION <code>expression</code> <p>The constraint expression</p> <p> TYPE: <code>Element</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>An object representing the constraint.</p> Source code in <code>pyorlib/model/model.py</code> <pre><code>def add_constraint(self, expression: Element) -&gt; Element:\n    \"\"\"\n    Adds a new constraint to the model.\n    :param expression: The constraint expression\n    :return: An object representing the constraint.\n    \"\"\"\n    constraint: Element = self._engine.add_constraint(expression=expression)\n\n    if self._logger.debug_enabled:  # pragma: no cover\n        try:\n            self._logger.debug(action=\"Constraint added: \", msg=f\"Expr: {expression}\")\n        except RecursionError:\n            self._logger.debug(action=\"Constraint added: \", msg=\"Expr: Unprintable expression\")\n\n    return constraint\n</code></pre>"},{"location":"api/model/#pyorlib.model.Model.set_objective","title":"set_objective","text":"<pre><code>set_objective(opt_type: OptimizationType, expression: Element) -&gt; Element\n</code></pre> <p>Defines the objective function.</p> PARAMETER DESCRIPTION <code>opt_type</code> <p>The type of optimization to be performed.</p> <p> TYPE: <code>OptimizationType</code> </p> <code>expression</code> <p>The objective expression.</p> <p> TYPE: <code>Element</code> </p> RETURNS DESCRIPTION <code>Element</code> <p>The objective function.</p> Source code in <code>pyorlib/model/model.py</code> <pre><code>def set_objective(self, opt_type: OptimizationType, expression: Element) -&gt; Element:\n    \"\"\"\n    Defines the objective function.\n    :param opt_type: The type of optimization to be performed.\n    :param expression: The objective expression.\n    :return: The objective function.\n    \"\"\"\n    objective: Element = self._engine.set_objective(opt_type=opt_type, expression=expression)\n\n    if self._logger.debug_enabled:  # pragma: no cover\n        try:\n            self._logger.debug(\n                action=\"Objective function added: \",\n                msg=\"\".join(\n                    [\n                        f\"Opt Type: {StdOutColors.PURPLE}{opt_type.name.capitalize()}{StdOutColors.DEFAULT} | \",\n                        f\"Expr: {objective}\",\n                    ]\n                ),\n            )\n        except RecursionError:\n            self._logger.debug(action=\"Objective function added: \", msg=\"Expr: Unprintable expression\")\n\n    return objective\n</code></pre>"},{"location":"api/model/#pyorlib.model.Model.solve","title":"solve","text":"<pre><code>solve() -&gt; None\n</code></pre> <p>Solves the optimization problem represented by the model.</p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyorlib/model/model.py</code> <pre><code>def solve(self) -&gt; None:\n    \"\"\"\n    Solves the optimization problem represented by the model.\n    :return: None.\n    \"\"\"\n    if self._logger.debug_enabled:  # pragma: no cover\n        self._logger.debug(f\"Solving the model...\")\n\n    self._engine.solve()\n\n    if self._logger.debug_enabled:  # pragma: no cover\n        self._logger.debug(f\"The model has been solved.\")\n</code></pre>"},{"location":"api/model/#pyorlib.model.Model.print_info","title":"print_info","text":"<pre><code>print_info(display_term_sets: bool = False) -&gt; None\n</code></pre> <p>Prints information about the model.</p> PARAMETER DESCRIPTION <code>display_term_sets</code> <p>Whether to display information about term sets. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyorlib/model/model.py</code> <pre><code>def print_info(self, display_term_sets: bool = False) -&gt; None:  # pragma: no cover\n    \"\"\"\n    Prints information about the model.\n    :param display_term_sets: Whether to display information about term sets. Defaults to False.\n    :return: None.\n    \"\"\"\n    default, debug = StdOutColors.DEFAULT, StdOutColors.PURPLE\n    print(f\"\\n------ MODEL INFORMATION ------\\n\")\n    print(\"Model properties:\")\n    print(f\"\\tName: {debug}{self.name}{default}\")\n    print(\"Objective function:\")\n    print(f\"\\tExpression: {self.objective_expr}\")\n    print(f\"\\tStatus: {debug}{self.solution_status.name}{default}\")\n    print(\n        f\"\\tValue: {debug}\",\n        (\n            \"{0:.{prec}g}\".format(self.objective_value, prec=self.float_precision)\n            if self.objective_value is not None\n            else \"--\"\n        ),\n        f\"{default}\",\n    )\n\n    print(f\"Dimensions: {debug}{len(self.dimensions)}{default}\")\n    for name, size in self.dimensions.items():\n        print(\n            f\"\\tName: {debug}{name}{default} | \",\n            f\"Val: {debug}{size}{default}\",\n        )\n\n    print(f\"Terms: {debug}{len(self.terms)}{default}\")\n    for name, term in self.terms.items():\n        print(f\"\\t{term.get_pretty_string(float_precision=self.float_precision)}\")\n    if display_term_sets:\n        print(f\"Terms Sets: {debug}{len(self.term_sets)}{default}\")\n        for name, terms in self.term_sets.items():\n            print(f\"\\tTerm: {debug}{name}{default}\")\n            for index, term in terms.items():\n                print(\n                    f\"\\t\\tIndex: {debug}{index}{default} | \",\n                    f\"{term.get_pretty_string(float_precision=self.float_precision)}\",\n                )\n\n    constraints = self.constraints\n    print(f\"Constraints: {debug}{len(constraints)}{default}\")\n    for exp in constraints:\n        try:\n            print(f\"\\tExpression: {exp}\")\n        except RecursionError:\n            print(\"\\tExpression: Print Error\")\n    print()\n</code></pre>"},{"location":"api/model/#pyorlib.model.Model.print_solution","title":"print_solution","text":"<pre><code>print_solution() -&gt; None\n</code></pre> <p>Prints the solution of the optimization problem.</p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyorlib/model/model.py</code> <pre><code>def print_solution(self) -&gt; None:  # pragma: no cover\n    \"\"\"\n    Prints the solution of the optimization problem.\n    :return: None.\n    \"\"\"\n    default, debug = StdOutColors.DEFAULT, StdOutColors.PURPLE\n    print(f\"\\n------ MODEL SOLUTION ------\\n\")\n    print(\"Objective function:\")\n    print(f\"\\tStatus: {debug}{self.solution_status.name}{default}\")\n    print(\n        f\"\\tValue: {debug}\",\n        (\n            \"{0:.{prec}g}\".format(self.objective_value, prec=self.float_precision)\n            if self.objective_value is not None\n            else \"--\"\n        ),\n        f\"{default}\",\n    )\n\n    solution_variables: Dict[str, Term] = {\n        name: term for name, term in self.terms.items() if (term.is_variable and term.value != 0)\n    }\n\n    if solution_variables:\n        print(\"Terms:\")\n        for name, term in solution_variables.items():\n            print(f\"\\t{term.get_pretty_string(float_precision=self.float_precision)}\")\n\n    print()\n</code></pre>"},{"location":"api/structures/","title":"<code>Structures</code> module","text":"<p>The Structures module in PyORlib provides a set of classes for managing and manipulating various structures encountered in optimization modeling.</p> <p></p>"},{"location":"api/structures/definitions/","title":"<code>Definitions</code> module","text":"<p>The Definitions module in PyORlib offers a comprehensive set of classes to define and organize the vital components of an optimization model. With this module, you can easily define terms, variables, and parameters in a structured and maintainable manner. By centralizing all the metadata, including names and other relevant information, you can ensure consistency and extensibility throughout your optimization process.</p> <p></p>"},{"location":"api/structures/definitions/dimension-definition/","title":"<code>DimensionDefinition</code> class","text":"<p>Represents the definition of a dimension in an optimization model.</p> <p>It provides a way to define the characteristics of a dimension, such as its name, display name, minimum and maximum values allowed.</p> Source code in <code>pyorlib/structures/definitions/dimension_definition.py</code> <pre><code>@dataclass(frozen=True)\nclass DimensionDefinition:\n    \"\"\"\n    Represents the definition of a dimension in an optimization model.\n\n    It provides a way to define the characteristics of a dimension, such as its name, display name,\n    minimum and maximum values allowed.\n    \"\"\"\n\n    name: str\n    \"\"\" The name of the dimension. \"\"\"\n\n    display_name: str | None = None\n    \"\"\" The name of the dimension as it should be displayed to the user. \"\"\"\n\n    min: float | int | None = 1\n    \"\"\" The minimum value allowed for the dimension. \"\"\"\n\n    max: float | int | None = None\n    \"\"\" The maximum value allowed for the dimension. \"\"\"\n</code></pre> <p></p>"},{"location":"api/structures/definitions/dimension-definition/#pyorlib.structures.DimensionDefinition-attributes","title":"Attributes","text":""},{"location":"api/structures/definitions/dimension-definition/#pyorlib.structures.DimensionDefinition.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the dimension.</p>"},{"location":"api/structures/definitions/dimension-definition/#pyorlib.structures.DimensionDefinition.display_name","title":"display_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>display_name: str | None = None\n</code></pre> <p>The name of the dimension as it should be displayed to the user.</p>"},{"location":"api/structures/definitions/dimension-definition/#pyorlib.structures.DimensionDefinition.min","title":"min  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min: float | int | None = 1\n</code></pre> <p>The minimum value allowed for the dimension.</p>"},{"location":"api/structures/definitions/dimension-definition/#pyorlib.structures.DimensionDefinition.max","title":"max  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max: float | int | None = None\n</code></pre> <p>The maximum value allowed for the dimension.</p>"},{"location":"api/structures/definitions/dimension-definition/#pyorlib.structures.DimensionDefinition-functions","title":"Functions","text":""},{"location":"api/structures/definitions/dimension-definition/#pyorlib.structures.DimensionDefinition.__init__","title":"__init__","text":"<pre><code>__init__(name: str, display_name: str | None = None, min: float | int | None = 1, max: float | int | None = None) -&gt; None\n</code></pre>"},{"location":"api/structures/definitions/parameter-definition/","title":"<code>ParameterDefinition</code> class","text":"<p>Represents the definition of a parameter in an optimization model.</p> <p>It provides various attributes to define the characteristics of the parameter in an optimization problem.</p> Source code in <code>pyorlib/structures/definitions/parameter_definition.py</code> <pre><code>@dataclass(frozen=True)\nclass ParameterDefinition:\n    \"\"\"\n    Represents the definition of a parameter in an optimization model.\n\n    It provides various attributes to define the characteristics of the parameter in an optimization problem.\n    \"\"\"\n\n    name: Callable[..., str] | str\n    \"\"\" \n    The name of the parameter. It can be a callable that returns the indexed name\n    of the parameter (e.g., `lambda` i, j: 'c_i_j'), or a string with the name itself.\n    \"\"\"\n\n    parameter_types: Set[ParameterType]\n    \"\"\" A set of parameter types supported by the parameter. \"\"\"\n\n    value_types: Set[ValueType]\n    \"\"\" A set of value types supported by the parameter. \"\"\"\n\n    set_name: str | None = None\n    \"\"\" The name of the term set to which this parameter belongs (e.g., c_i_j). \"\"\"\n\n    display_name: str | None = None\n    \"\"\" The name of the parameter as it should be displayed to the user. \"\"\"\n\n    min: float | int | None = None\n    \"\"\" The minimum value allowed for the parameter. \"\"\"\n\n    max: float | int | None = None\n    \"\"\" The maximum value allowed for the parameter. \"\"\"\n</code></pre> <p></p>"},{"location":"api/structures/definitions/parameter-definition/#pyorlib.structures.ParameterDefinition-attributes","title":"Attributes","text":""},{"location":"api/structures/definitions/parameter-definition/#pyorlib.structures.ParameterDefinition.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: Callable[..., str] | str\n</code></pre> <p>The name of the parameter. It can be a callable that returns the indexed name of the parameter (e.g., <code>lambda</code> i, j: 'c_i_j'), or a string with the name itself.</p>"},{"location":"api/structures/definitions/parameter-definition/#pyorlib.structures.ParameterDefinition.parameter_types","title":"parameter_types  <code>instance-attribute</code>","text":"<pre><code>parameter_types: Set[ParameterType]\n</code></pre> <p>A set of parameter types supported by the parameter.</p>"},{"location":"api/structures/definitions/parameter-definition/#pyorlib.structures.ParameterDefinition.value_types","title":"value_types  <code>instance-attribute</code>","text":"<pre><code>value_types: Set[ValueType]\n</code></pre> <p>A set of value types supported by the parameter.</p>"},{"location":"api/structures/definitions/parameter-definition/#pyorlib.structures.ParameterDefinition.set_name","title":"set_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>set_name: str | None = None\n</code></pre> <p>The name of the term set to which this parameter belongs (e.g., c_i_j).</p>"},{"location":"api/structures/definitions/parameter-definition/#pyorlib.structures.ParameterDefinition.display_name","title":"display_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>display_name: str | None = None\n</code></pre> <p>The name of the parameter as it should be displayed to the user.</p>"},{"location":"api/structures/definitions/parameter-definition/#pyorlib.structures.ParameterDefinition.min","title":"min  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min: float | int | None = None\n</code></pre> <p>The minimum value allowed for the parameter.</p>"},{"location":"api/structures/definitions/parameter-definition/#pyorlib.structures.ParameterDefinition.max","title":"max  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max: float | int | None = None\n</code></pre> <p>The maximum value allowed for the parameter.</p>"},{"location":"api/structures/definitions/parameter-definition/#pyorlib.structures.ParameterDefinition-functions","title":"Functions","text":""},{"location":"api/structures/definitions/parameter-definition/#pyorlib.structures.ParameterDefinition.__init__","title":"__init__","text":"<pre><code>__init__(name: Callable[..., str] | str, parameter_types: Set[ParameterType], value_types: Set[ValueType], set_name: str | None = None, display_name: str | None = None, min: float | int | None = None, max: float | int | None = None) -&gt; None\n</code></pre>"},{"location":"api/structures/definitions/term-definition/","title":"<code>TermDefinition</code> class","text":"<p>Represents the definition of a term in an optimization model.</p> <p>It provides a way to define the characteristics of a Term, such as its name, the term set it belongs to (if applicable), and the display name for the term.</p> Source code in <code>pyorlib/structures/definitions/term_definition.py</code> <pre><code>@dataclass(frozen=True)\nclass TermDefinition:\n    \"\"\"\n    Represents the definition of a term in an optimization model.\n\n    It provides a way to define the characteristics of a Term, such as its name,\n    the term set it belongs to (if applicable), and the display name for the term.\n    \"\"\"\n\n    name: Callable[..., str] | str\n    \"\"\" \n    The name of the term. It can be a callable that returns the indexed name\n    of the term (e.g., `lambda` i, j: 'x_i_j'), or a string with the name itself.\n    \"\"\"\n\n    set_name: str | None = None\n    \"\"\" The name of the term set to which this term belongs (e.g., x_i_j). \"\"\"\n\n    display_name: str | None = None\n    \"\"\" The name of the term as it should be displayed to the user. \"\"\"\n</code></pre> <p></p>"},{"location":"api/structures/definitions/term-definition/#pyorlib.structures.TermDefinition-attributes","title":"Attributes","text":""},{"location":"api/structures/definitions/term-definition/#pyorlib.structures.TermDefinition.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: Callable[..., str] | str\n</code></pre> <p>The name of the term. It can be a callable that returns the indexed name of the term (e.g., <code>lambda</code> i, j: 'x_i_j'), or a string with the name itself.</p>"},{"location":"api/structures/definitions/term-definition/#pyorlib.structures.TermDefinition.set_name","title":"set_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>set_name: str | None = None\n</code></pre> <p>The name of the term set to which this term belongs (e.g., x_i_j).</p>"},{"location":"api/structures/definitions/term-definition/#pyorlib.structures.TermDefinition.display_name","title":"display_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>display_name: str | None = None\n</code></pre> <p>The name of the term as it should be displayed to the user.</p>"},{"location":"api/structures/definitions/term-definition/#pyorlib.structures.TermDefinition-functions","title":"Functions","text":""},{"location":"api/structures/definitions/term-definition/#pyorlib.structures.TermDefinition.__init__","title":"__init__","text":"<pre><code>__init__(name: Callable[..., str] | str, set_name: str | None = None, display_name: str | None = None) -&gt; None\n</code></pre>"},{"location":"api/structures/parameters/","title":"<code>Parameter</code> class","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract data class representing a parameter in an optimization model.</p> <p>The <code>Parameter</code> class is an abstract base class (ABC) that defines the common interface for parameters in an optimization model. It provides information about the type of the parameter and the value type of its values.</p> Source code in <code>pyorlib/structures/parameters/parameter.py</code> <pre><code>@dataclass(frozen=True)\nclass Parameter(ABC):\n    \"\"\"\n    An abstract data class representing a parameter in an optimization model.\n\n    The `Parameter` class is an abstract base class (ABC) that defines the common interface for parameters in an\n    optimization model. It provides information about the type of the parameter and the value type of its values.\n    \"\"\"\n\n    parameter_type: ParameterType\n    \"\"\" The type of the parameter. \"\"\"\n\n    value_type: ValueType\n    \"\"\" The value type of the parameter values. \"\"\"\n\n    @property\n    def is_bounded(self) -&gt; bool:\n        \"\"\"\n        Returns a boolean indicating whether the parameter is bounded.\n        :return: `True` if the parameter is bounded, `False` otherwise.\n        \"\"\"\n        return self.parameter_type == ParameterType.BOUNDED\n</code></pre> <p></p>"},{"location":"api/structures/parameters/#pyorlib.structures.Parameter-attributes","title":"Attributes","text":""},{"location":"api/structures/parameters/#pyorlib.structures.Parameter.parameter_type","title":"parameter_type  <code>instance-attribute</code>","text":"<pre><code>parameter_type: ParameterType\n</code></pre> <p>The type of the parameter.</p>"},{"location":"api/structures/parameters/#pyorlib.structures.Parameter.value_type","title":"value_type  <code>instance-attribute</code>","text":"<pre><code>value_type: ValueType\n</code></pre> <p>The value type of the parameter values.</p>"},{"location":"api/structures/parameters/#pyorlib.structures.Parameter.is_bounded","title":"is_bounded  <code>property</code>","text":"<pre><code>is_bounded: bool\n</code></pre> <p>Returns a boolean indicating whether the parameter is bounded.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the parameter is bounded, <code>False</code> otherwise.</p>"},{"location":"api/structures/parameters/#pyorlib.structures.Parameter-functions","title":"Functions","text":""},{"location":"api/structures/parameters/#pyorlib.structures.Parameter.__init__","title":"__init__","text":"<pre><code>__init__(parameter_type: ParameterType, value_type: ValueType) -&gt; None\n</code></pre>"},{"location":"api/structures/parameters/multi-value-parameter/","title":"<code>MultiValueParameter</code> class","text":"<p>               Bases: <code>Parameter</code></p> <p>A data class representing a multi-value parameter in an optimization model.</p> <p>The <code>MultiValueParameter</code> class is a subclass of <code>Parameter</code> and is used to represent parameters with multiple values in an optimization model. It provides properties to access the set of parameter values, lower bounds, and upper bounds.</p> Source code in <code>pyorlib/structures/parameters/multi_value_parameter.py</code> <pre><code>@dataclass(frozen=True)\nclass MultiValueParameter(Parameter):\n    \"\"\"\n    A data class representing a multi-value parameter in an optimization model.\n\n    The `MultiValueParameter` class is a subclass of `Parameter` and is used to represent parameters with multiple\n    values in an optimization model. It provides properties to access the set of parameter values, lower bounds,\n    and upper bounds.\n    \"\"\"\n\n    values: Tuple[float, ...] | None = None\n    \"\"\" A tuple containing the parameter values, or None if no values are specified. \"\"\"\n\n    lower_bounds: Tuple[float, ...] | None = None\n    \"\"\" A tuple containing the lower bounds for each parameter value, or None if no lower bounds are specified. \"\"\"\n\n    upper_bounds: Tuple[float, ...] | None = None\n    \"\"\" A tuple containing the upper bounds for each parameter value, or None if no upper bounds are specified. \"\"\"\n\n    def __post_init__(self) -&gt; None:\n        # Parameter Validations\n        if self.value_type is None:\n            raise ValueError(\"Parameter value type is required.\")\n\n        if self.parameter_type == ParameterType.FIXED and self.values is not None:\n            if self.lower_bounds is not None or self.upper_bounds is not None:\n                raise ValueError(\"Parameters with values cannot have bounds.\")\n            if len(self.values) == 0:\n                raise ValueError(\"Parameter values cannot be empty.\")\n            for val in self.values:\n                if val &gt;= 1e20 or val &lt;= -1e20:\n                    raise ValueError(\"Parameter values cannot be [+/-]infinity.\")\n\n                # Value and Value Type validations\n                if self.value_type == ValueType.BINARY and not ValueTypeValidator.is_binary(val):\n                    raise ValueError(\"Parameter set values must be valid integer numbers.\")\n                elif self.value_type == ValueType.INTEGER and not ValueTypeValidator.is_integer(val):\n                    raise ValueError(\"Parameter set values must be valid integer numbers.\")\n        elif (\n            self.parameter_type == ParameterType.BOUNDED\n            and self.lower_bounds is not None\n            and self.upper_bounds is not None\n        ):\n            if self.values is not None:\n                raise ValueError(\"Parameters with bounds cannot have a value.\")\n            if len(self.lower_bounds) != len(self.upper_bounds):\n                raise ValueError(\"Parameters bounds must have the same length.\")\n            if len(self.lower_bounds) == 0:\n                raise ValueError(\"Parameters bounds cannot be empty.\")\n            for i in range(0, len(self.lower_bounds)):\n                lb = self.lower_bounds[i]\n                ub = self.upper_bounds[i]\n                if lb &gt; ub:\n                    raise ValueError(\"Parameters lower bounds cannot be greater than upper bounds.\")\n\n                if ub &gt;= 1e20 or lb &lt; -1e20:\n                    raise ValueError(\"Parameter upper and lower bounds cannot be [+/-]infinity.\")\n\n                # lb and ub values and value type validation\n                if self.value_type == ValueType.BINARY and (\n                    not ValueTypeValidator.is_binary(lb) or not ValueTypeValidator.is_binary(ub)\n                ):\n                    raise ValueError(\"Parameter lower and upper bound values must be valid binary numbers.\")\n                elif self.value_type == ValueType.INTEGER and (\n                    not ValueTypeValidator.is_integer(lb) or not ValueTypeValidator.is_integer(ub)\n                ):\n                    raise ValueError(\"Parameter lower and upper bound values must be valid integer numbers.\")\n        else:\n            raise ValueError(\"Invalid parameter\")\n</code></pre> <p></p>"},{"location":"api/structures/parameters/multi-value-parameter/#pyorlib.structures.MultiValueParameter-attributes","title":"Attributes","text":""},{"location":"api/structures/parameters/multi-value-parameter/#pyorlib.structures.MultiValueParameter.parameter_type","title":"parameter_type  <code>instance-attribute</code>","text":"<pre><code>parameter_type: ParameterType\n</code></pre> <p>The type of the parameter.</p>"},{"location":"api/structures/parameters/multi-value-parameter/#pyorlib.structures.MultiValueParameter.value_type","title":"value_type  <code>instance-attribute</code>","text":"<pre><code>value_type: ValueType\n</code></pre> <p>The value type of the parameter values.</p>"},{"location":"api/structures/parameters/multi-value-parameter/#pyorlib.structures.MultiValueParameter.is_bounded","title":"is_bounded  <code>property</code>","text":"<pre><code>is_bounded: bool\n</code></pre> <p>Returns a boolean indicating whether the parameter is bounded.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the parameter is bounded, <code>False</code> otherwise.</p>"},{"location":"api/structures/parameters/multi-value-parameter/#pyorlib.structures.MultiValueParameter.values","title":"values  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>values: Tuple[float, ...] | None = None\n</code></pre> <p>A tuple containing the parameter values, or None if no values are specified.</p>"},{"location":"api/structures/parameters/multi-value-parameter/#pyorlib.structures.MultiValueParameter.lower_bounds","title":"lower_bounds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lower_bounds: Tuple[float, ...] | None = None\n</code></pre> <p>A tuple containing the lower bounds for each parameter value, or None if no lower bounds are specified.</p>"},{"location":"api/structures/parameters/multi-value-parameter/#pyorlib.structures.MultiValueParameter.upper_bounds","title":"upper_bounds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>upper_bounds: Tuple[float, ...] | None = None\n</code></pre> <p>A tuple containing the upper bounds for each parameter value, or None if no upper bounds are specified.</p>"},{"location":"api/structures/parameters/multi-value-parameter/#pyorlib.structures.MultiValueParameter-functions","title":"Functions","text":""},{"location":"api/structures/parameters/multi-value-parameter/#pyorlib.structures.MultiValueParameter.__init__","title":"__init__","text":"<pre><code>__init__(parameter_type: ParameterType, value_type: ValueType, values: Tuple[float, ...] | None = None, lower_bounds: Tuple[float, ...] | None = None, upper_bounds: Tuple[float, ...] | None = None) -&gt; None\n</code></pre>"},{"location":"api/structures/parameters/single-value-parameter/","title":"<code>SingleValueParameter</code> class","text":"<p>               Bases: <code>Parameter</code></p> <p>A data class representing a single-value parameter in an optimization model.</p> <p>The <code>SingleValueParameter</code> class is a subclass of <code>Parameter</code> and is used to represent parameters with a single value in an optimization model. It provides properties to access the parameter value, lower bound, and upper bound.</p> Source code in <code>pyorlib/structures/parameters/single_value_parameter.py</code> <pre><code>@dataclass(frozen=True)\nclass SingleValueParameter(Parameter):\n    \"\"\"\n    A data class representing a single-value parameter in an optimization model.\n\n    The `SingleValueParameter` class is a subclass of `Parameter` and is used to represent parameters with a single\n    value in an optimization model. It provides properties to access the parameter value, lower bound, and upper bound.\n    \"\"\"\n\n    value: float | None = None\n    \"\"\" The value of the parameter, or None if no value is specified. \"\"\"\n\n    lower_bound: float | None = None\n    \"\"\" The lower bound of the parameter, or None if no lower bound is specified. \"\"\"\n\n    upper_bound: float | None = None\n    \"\"\" The upper bound of the parameter, or None if no upper bound is specified. \"\"\"\n\n    def __post_init__(self) -&gt; None:\n        # Parameter Validations\n        if self.value_type is None:\n            raise ValueError(\"Parameter value type is required.\")\n\n        if self.parameter_type == ParameterType.FIXED and self.value is not None:\n            if self.lower_bound is not None or self.upper_bound is not None:\n                raise ValueError(\"Parameters with value cannot has bounds.\")\n            if self.value &gt;= 1e20 or self.value &lt;= -1e20:\n                raise ValueError(\"Parameter value cannot be infinity.\")\n\n            # Validate value and value type\n            if self.value_type == ValueType.BINARY and not ValueTypeValidator.is_binary(self.value):\n                raise ValueError(\"Parameter value must be a valid binary number.\")\n            elif self.value_type == ValueType.INTEGER and not ValueTypeValidator.is_integer(self.value):\n                raise ValueError(\"Parameter value must be a valid integer number.\")\n        elif (\n            self.parameter_type == ParameterType.BOUNDED\n            and self.lower_bound is not None\n            and self.upper_bound is not None\n        ):\n            if self.value is not None:\n                raise ValueError(\"Parameters with bounds cannot has a value.\")\n            if self.upper_bound &gt;= 1e20 or self.lower_bound &lt;= -1e20:\n                raise ValueError(\"Parameter upper bound cannot be infinity.\")\n            if self.lower_bound &gt; self.upper_bound:\n                raise ValueError(\"The upper bound of the parameter must be greater than or equal to the lower bound.\")\n\n            # Validate lower and upper bound values and value type\n            if self.value_type == ValueType.BINARY and (\n                not ValueTypeValidator.is_binary(self.lower_bound) or not ValueTypeValidator.is_binary(self.upper_bound)\n            ):\n                raise ValueError(\"Parameter lower and upper bound values must be valid binary numbers.\")\n            elif self.value_type == ValueType.INTEGER and (\n                not ValueTypeValidator.is_integer(self.lower_bound)\n                or not ValueTypeValidator.is_integer(self.upper_bound)\n            ):\n                raise ValueError(\"Parameter lower and upper bound values must be valid integer numbers.\")\n        else:\n            raise ValueError(\"Invalid parameter.\")\n</code></pre> <p></p>"},{"location":"api/structures/parameters/single-value-parameter/#pyorlib.structures.SingleValueParameter-attributes","title":"Attributes","text":""},{"location":"api/structures/parameters/single-value-parameter/#pyorlib.structures.SingleValueParameter.parameter_type","title":"parameter_type  <code>instance-attribute</code>","text":"<pre><code>parameter_type: ParameterType\n</code></pre> <p>The type of the parameter.</p>"},{"location":"api/structures/parameters/single-value-parameter/#pyorlib.structures.SingleValueParameter.value_type","title":"value_type  <code>instance-attribute</code>","text":"<pre><code>value_type: ValueType\n</code></pre> <p>The value type of the parameter values.</p>"},{"location":"api/structures/parameters/single-value-parameter/#pyorlib.structures.SingleValueParameter.is_bounded","title":"is_bounded  <code>property</code>","text":"<pre><code>is_bounded: bool\n</code></pre> <p>Returns a boolean indicating whether the parameter is bounded.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the parameter is bounded, <code>False</code> otherwise.</p>"},{"location":"api/structures/parameters/single-value-parameter/#pyorlib.structures.SingleValueParameter.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: float | None = None\n</code></pre> <p>The value of the parameter, or None if no value is specified.</p>"},{"location":"api/structures/parameters/single-value-parameter/#pyorlib.structures.SingleValueParameter.lower_bound","title":"lower_bound  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lower_bound: float | None = None\n</code></pre> <p>The lower bound of the parameter, or None if no lower bound is specified.</p>"},{"location":"api/structures/parameters/single-value-parameter/#pyorlib.structures.SingleValueParameter.upper_bound","title":"upper_bound  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>upper_bound: float | None = None\n</code></pre> <p>The upper bound of the parameter, or None if no upper bound is specified.</p>"},{"location":"api/structures/parameters/single-value-parameter/#pyorlib.structures.SingleValueParameter-functions","title":"Functions","text":""},{"location":"api/structures/parameters/single-value-parameter/#pyorlib.structures.SingleValueParameter.__init__","title":"__init__","text":"<pre><code>__init__(parameter_type: ParameterType, value_type: ValueType, value: float | None = None, lower_bound: float | None = None, upper_bound: float | None = None) -&gt; None\n</code></pre>"},{"location":"api/validators/","title":"<code>Validators</code> module","text":"<p>The Validators module in PyORlib provides a set of classes and descriptors for validating various components within optimization modeling.</p> <p></p>"},{"location":"api/validators/value-type-validator/","title":"<code>ValueTypeValidator</code> class","text":"<p>This class has two static methods to validate if a given \"float\" or \"int\" number is a valid binary or integer number.</p> Source code in <code>pyorlib/validators/value_type_validator.py</code> <pre><code>class ValueTypeValidator:\n    \"\"\"\n    This class has two static methods to validate if a\n    given \"float\" or \"int\" number is a valid binary or\n    integer number.\n    \"\"\"\n\n    @staticmethod\n    def is_binary(num: float | int) -&gt; bool:\n        \"\"\"\n        This method checks if the given float/int number is binary or not.\n        :param num: float/int number to be checked\n        :return: True if the given float/int number is binary else False\n        \"\"\"\n        return num is not None and num in [0, 1]\n\n    @staticmethod\n    def is_integer(num: float | int) -&gt; bool:\n        \"\"\"\n        This method checks if the given float/int number is a valid integer or not.\n        :param num: float/int number to be checked\n        :return: True if the given float/int number is an integer else False\n        \"\"\"\n        return num is not None and (num == inf or num == -inf or isinstance(num, int) or float(num).is_integer())\n</code></pre> <p></p>"},{"location":"api/validators/value-type-validator/#pyorlib.validators.ValueTypeValidator-functions","title":"Functions","text":""},{"location":"api/validators/value-type-validator/#pyorlib.validators.ValueTypeValidator.is_binary","title":"is_binary  <code>staticmethod</code>","text":"<pre><code>is_binary(num: float | int) -&gt; bool\n</code></pre> <p>This method checks if the given float/int number is binary or not.</p> PARAMETER DESCRIPTION <code>num</code> <p>float/int number to be checked</p> <p> TYPE: <code>float | int</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the given float/int number is binary else False</p> Source code in <code>pyorlib/validators/value_type_validator.py</code> <pre><code>@staticmethod\ndef is_binary(num: float | int) -&gt; bool:\n    \"\"\"\n    This method checks if the given float/int number is binary or not.\n    :param num: float/int number to be checked\n    :return: True if the given float/int number is binary else False\n    \"\"\"\n    return num is not None and num in [0, 1]\n</code></pre>"},{"location":"api/validators/value-type-validator/#pyorlib.validators.ValueTypeValidator.is_integer","title":"is_integer  <code>staticmethod</code>","text":"<pre><code>is_integer(num: float | int) -&gt; bool\n</code></pre> <p>This method checks if the given float/int number is a valid integer or not.</p> PARAMETER DESCRIPTION <code>num</code> <p>float/int number to be checked</p> <p> TYPE: <code>float | int</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the given float/int number is an integer else False</p> Source code in <code>pyorlib/validators/value_type_validator.py</code> <pre><code>@staticmethod\ndef is_integer(num: float | int) -&gt; bool:\n    \"\"\"\n    This method checks if the given float/int number is a valid integer or not.\n    :param num: float/int number to be checked\n    :return: True if the given float/int number is an integer else False\n    \"\"\"\n    return num is not None and (num == inf or num == -inf or isinstance(num, int) or float(num).is_integer())\n</code></pre>"},{"location":"api/validators/fields/","title":"<code>Fields</code> module","text":"<p>Validation fields module description...</p> <p></p>"},{"location":"api/validators/fields/dimension-field/","title":"<code>DimensionField</code> class","text":"<p>               Bases: <code>FieldValidator[int]</code></p> <p>A descriptor used to validate dimensions in an optimization model.</p> <p>The <code>DimensionField</code> class is a field validator specifically designed for model's dimension fields. It ensures that the dimension value is within specified bounds and is an integer number. It allows setting minimum and maximum limits for the dimension.</p> <p>This class is a subclass of <code>FieldValidator</code> and inherits its functionality for validating and formatting field values.</p> Source code in <code>pyorlib/validators/fields/dimension_field.py</code> <pre><code>class DimensionField(FieldValidator[int]):\n    \"\"\"\n    A descriptor used to validate dimensions in an optimization model.\n\n    The `DimensionField` class is a field validator specifically designed for model's dimension fields. It ensures that\n    the dimension value is within specified bounds and is an integer number. It allows setting minimum and maximum\n    limits for the dimension.\n\n    This class is a subclass of `FieldValidator` and inherits its functionality for validating and formatting field\n    values.\n    \"\"\"\n\n    __slots__ = [\"_min\", \"_max\"]\n\n    @property\n    def min(self) -&gt; int | None:\n        \"\"\"\n        Get the minimum value allowed.\n        :return: The minimum value or None if not set.\n        \"\"\"\n        return self._min\n\n    @property\n    def max(self) -&gt; int | None:\n        \"\"\"\n        Get the maximum value allowed.\n        :return: The maximum value or None if not set.\n        \"\"\"\n        return self._max\n\n    def __init__(self, min: int | None = None, max: int | None = None):\n        \"\"\"\n        Initialize a new DimensionField instance.\n        :param min: The minimum value allowed for the dimension field. Defaults to None.\n        :param max: The maximum value allowed for the dimension field. Defaults to None.\n        \"\"\"\n        # Calls the base init method\n        super().__init__()\n\n        # Applies validations\n        if min is not None and not ValueTypeValidator.is_integer(min):\n            raise ValueError(f\"{self._public_name} 'min' value must be an integer number.\")\n\n        if max is not None and not ValueTypeValidator.is_integer(max):\n            raise ValueError(f\"{self._public_name} 'max' value must be an integer number.\")\n\n        if min is not None and min &lt; 0:\n            raise ValueError(f\"{self._public_name} 'min' value must be greater than or equal to 0.\")\n\n        if max is not None and min is not None and min &gt; max:\n            raise ValueError(f\"{self._public_name} 'min' value cannot be greater than maximum.\")\n\n        # Instance attributes\n        self._min: int | None = min\n        self._max: int | None = max\n\n    def validate(self, value: int | None) -&gt; None:\n        if value is None:\n            raise ValueError(f\"{self._public_name} value cannot be None.\")\n\n        if not ValueTypeValidator.is_integer(value):\n            raise ValueError(f\"{self._public_name} value must be an integer number.\")\n\n        if self._min is not None and value &lt; self._min:\n            raise ValueError(f\"{self._public_name} value must be greater than or equal to {self._min}.\")\n\n        if self._max is not None and value &gt; self._max:\n            raise ValueError(f\"{self._public_name} value must be less than or equal to {self._max}.\")\n</code></pre> <p></p>"},{"location":"api/validators/fields/dimension-field/#pyorlib.validators.DimensionField-attributes","title":"Attributes","text":""},{"location":"api/validators/fields/dimension-field/#pyorlib.validators.DimensionField.min","title":"min  <code>property</code>","text":"<pre><code>min: int | None\n</code></pre> <p>Get the minimum value allowed.</p> RETURNS DESCRIPTION <code>int | None</code> <p>The minimum value or None if not set.</p>"},{"location":"api/validators/fields/dimension-field/#pyorlib.validators.DimensionField.max","title":"max  <code>property</code>","text":"<pre><code>max: int | None\n</code></pre> <p>Get the maximum value allowed.</p> RETURNS DESCRIPTION <code>int | None</code> <p>The maximum value or None if not set.</p>"},{"location":"api/validators/fields/dimension-field/#pyorlib.validators.DimensionField-functions","title":"Functions","text":""},{"location":"api/validators/fields/dimension-field/#pyorlib.validators.DimensionField.__init__","title":"__init__","text":"<pre><code>__init__(min: int | None = None, max: int | None = None)\n</code></pre> <p>Initialize a new DimensionField instance.</p> PARAMETER DESCRIPTION <code>min</code> <p>The minimum value allowed for the dimension field. Defaults to None.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>max</code> <p>The maximum value allowed for the dimension field. Defaults to None.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>pyorlib/validators/fields/dimension_field.py</code> <pre><code>def __init__(self, min: int | None = None, max: int | None = None):\n    \"\"\"\n    Initialize a new DimensionField instance.\n    :param min: The minimum value allowed for the dimension field. Defaults to None.\n    :param max: The maximum value allowed for the dimension field. Defaults to None.\n    \"\"\"\n    # Calls the base init method\n    super().__init__()\n\n    # Applies validations\n    if min is not None and not ValueTypeValidator.is_integer(min):\n        raise ValueError(f\"{self._public_name} 'min' value must be an integer number.\")\n\n    if max is not None and not ValueTypeValidator.is_integer(max):\n        raise ValueError(f\"{self._public_name} 'max' value must be an integer number.\")\n\n    if min is not None and min &lt; 0:\n        raise ValueError(f\"{self._public_name} 'min' value must be greater than or equal to 0.\")\n\n    if max is not None and min is not None and min &gt; max:\n        raise ValueError(f\"{self._public_name} 'min' value cannot be greater than maximum.\")\n\n    # Instance attributes\n    self._min: int | None = min\n    self._max: int | None = max\n</code></pre>"},{"location":"api/validators/fields/dimension-field/#pyorlib.validators.DimensionField.validate","title":"validate","text":"<pre><code>validate(value: int | None) -&gt; None\n</code></pre> Source code in <code>pyorlib/validators/fields/dimension_field.py</code> <pre><code>def validate(self, value: int | None) -&gt; None:\n    if value is None:\n        raise ValueError(f\"{self._public_name} value cannot be None.\")\n\n    if not ValueTypeValidator.is_integer(value):\n        raise ValueError(f\"{self._public_name} value must be an integer number.\")\n\n    if self._min is not None and value &lt; self._min:\n        raise ValueError(f\"{self._public_name} value must be greater than or equal to {self._min}.\")\n\n    if self._max is not None and value &gt; self._max:\n        raise ValueError(f\"{self._public_name} value must be less than or equal to {self._max}.\")\n</code></pre>"},{"location":"api/validators/fields/parameter-field/","title":"<code>ParameterField</code> class","text":"<p>               Bases: <code>FieldValidator[Parameter]</code></p> <p>A descriptor used to validate parameters in an optimization model.</p> <p>The <code>ParameterField</code> class is designed specifically for validating parameters in an optimization model. It ensures that the parameter value is of the correct type and format and provides functionality for validating and formatting parameter values based on defined constraints and requirements.</p> <p>This class is a subclass of <code>FieldValidator</code> and inherits its functionality for validating and formatting field values.</p> Source code in <code>pyorlib/validators/fields/parameter_field.py</code> <pre><code>class ParameterField(FieldValidator[Parameter]):\n    \"\"\"\n    A descriptor used to validate parameters in an optimization model.\n\n    The `ParameterField` class is designed specifically for validating parameters in an optimization model. It ensures\n    that the parameter value is of the correct type and format and provides functionality for validating and formatting\n    parameter values based on defined constraints and requirements.\n\n    This class is a subclass of `FieldValidator` and inherits its functionality for validating and formatting field\n    values.\n    \"\"\"\n\n    __slots__ = [\n        \"_required\",\n        \"_parameter_types\",\n        \"_value_types\",\n        \"_min\",\n        \"_max\",\n    ]\n\n    @property\n    def parameter_types(self) -&gt; Set[ParameterType]:\n        \"\"\"\n        Returns the set of supported parameter types.\n        :return: A set containing the supported parameter types.\n        \"\"\"\n        return self._parameter_types\n\n    @property\n    def value_types(self) -&gt; Set[ValueType]:\n        \"\"\"\n        Returns the set of supported value types.\n        :return: A set containing the supported value types.\n        \"\"\"\n        return self._value_types\n\n    @property\n    def min(self) -&gt; float | None:\n        \"\"\"\n        Returns the minimum supported value of the descriptor.\n        :return: The minimum supported value. If there is no minimum value, it is None.\n        \"\"\"\n        return self._min\n\n    @property\n    def max(self) -&gt; float | None:\n        \"\"\"\n        Returns the maximum supported value of the descriptor.\n        :return: The maximum supported value. If there is no maximum value, it is None.\n        \"\"\"\n        return self._max\n\n    @property\n    def required(self) -&gt; bool:\n        \"\"\"\n        Returns a boolean indicating whether the parameter is required.\n        :return: `True` if the parameter is required, `False` otherwise.\n        \"\"\"\n        return self._required\n\n    def __init__(\n        self,\n        parameter_types: Set[ParameterType],\n        value_types: Set[ValueType],\n        min: float | None = None,\n        max: float | None = None,\n        required: bool = True,\n    ):\n        \"\"\"\n        Initialize a new instance of ParameterField.\n        :param parameter_types: A set that contains the supported parameter types.\n        :param value_types: A set that contains the supported value types.\n        :param min: The minimum value supported by the descriptor. If there is no minimum value, it is None.\n        :param max: The maximum value supported by the descriptor. If there is no maximum value, it is None.\n        :param required: A boolean indicating whether the parameter is required or not.\n        \"\"\"\n        # Calls the base init method\n        super().__init__()\n\n        # Applies validations\n        if parameter_types is None or len(parameter_types) == 0:\n            raise ValueError(\"The set of parameter types cannot be empty.\")\n\n        if value_types is None or len(value_types) == 0:\n            raise ValueError(\"The set of value types cannot be empty.\")\n\n        if max is not None and min is not None and min &gt; max:\n            raise ValueError(\"The minimum value for the parameter field cannot be greater than the maximum value.\")\n\n        self._parameter_types: Set[ParameterType] = parameter_types\n        \"\"\" A set of parameter types that are supported by the descriptor. \"\"\"\n\n        self._value_types: Set[ValueType] = value_types\n        \"\"\" A set of value types that are supported by the descriptor. \"\"\"\n\n        self._min: float | None = min\n        \"\"\" The minimum value supported by the descriptor, or None if there is no minimum value. \"\"\"\n\n        self._max: float | None = max\n        \"\"\" The maximum value supported by the descriptor, or None if there is no maximum value. \"\"\"\n\n        self._required: bool = required\n        \"\"\" A boolean indicating whether the parameter is required. \"\"\"\n\n    def validate(self, value: Parameter | None) -&gt; None:\n        # Checks for None value\n        if value is None:\n            if self.required:\n                raise ValueError(f\"{self._public_name} is required\")\n            else:\n                return\n\n        # Checks for supported param types\n        if not value.is_bounded and ParameterType.FIXED not in self.parameter_types:\n            raise ValueError(f\"{self._public_name} does not support {ParameterType.FIXED.name}\")\n        if value.is_bounded and ParameterType.BOUNDED not in self.parameter_types:\n            raise ValueError(f\"{self._public_name} does not support {ParameterType.BOUNDED.name}\")\n\n        # Checks for supported value types\n        if value.value_type not in self.value_types:\n            raise ValueError(f\"{self._public_name} does not support {value.value_type.name}\")\n\n        # Checks for SingleValueParameter and MultiValueParameter types\n        if isinstance(value, MultiValueParameter):\n            if value.is_bounded:\n                if self._min is not None or self._max is not None:\n                    for i in range(0, len(value.lower_bounds)):  # type: ignore[arg-type]\n                        lb = value.lower_bounds[i]  # type: ignore[index]\n                        ub = value.upper_bounds[i]  # type: ignore[index]\n                        self._validate_bounds(lb, ub)\n            else:\n                if self._min is not None or self._max is not None:\n                    for val in value.values:  # type: ignore[union-attr]\n                        self._validate_value(val)\n        elif isinstance(value, SingleValueParameter):\n            if value.is_bounded:\n                if self._min is not None or self._max is not None:\n                    self._validate_bounds(value.lower_bound, value.upper_bound)  # type: ignore[arg-type]\n            else:\n                if self._min is not None or self._max is not None:\n                    self._validate_value(value.value)  # type: ignore[arg-type]\n        else:\n            raise TypeError(f\"{self._public_name} invalid parameter type\")  # pragma: no cover\n\n    def _validate_bounds(self, lower_bound: float, upper_bound: float) -&gt; None:\n        \"\"\"\n        Validates the specified bounds for the parameter value.\n        :param lower_bound: The lower bound of the parameter.\n        :param upper_bound: The upper bound of the parameter.\n        :return: None\n        \"\"\"\n        if self._min is not None and lower_bound &lt; self._min:\n            raise ValueError(f\"{self._public_name} lower bound must be greater than or equal to {self._min}\")\n        if self._max is not None and upper_bound &gt; self._max:\n            raise ValueError(f\"{self._public_name} upper bound must be less than or equal to {self._max}\")\n\n    def _validate_value(self, value: float) -&gt; None:\n        \"\"\"\n        Validates a given parameter value.\n        :param value: The parameter value to be validated.\n        :return: None\n        \"\"\"\n        if self._min is not None and value &lt; self._min:\n            raise ValueError(f\"{self._public_name} value must be greater than or equal to {self._min}\")\n        if self._max is not None and value &gt; self._max:\n            raise ValueError(f\"{self._public_name} value must be less than or equal to {self._max}\")\n</code></pre> <p></p>"},{"location":"api/validators/fields/parameter-field/#pyorlib.validators.ParameterField-attributes","title":"Attributes","text":""},{"location":"api/validators/fields/parameter-field/#pyorlib.validators.ParameterField.parameter_types","title":"parameter_types  <code>property</code>","text":"<pre><code>parameter_types: Set[ParameterType]\n</code></pre> <p>Returns the set of supported parameter types.</p> RETURNS DESCRIPTION <code>Set[ParameterType]</code> <p>A set containing the supported parameter types.</p>"},{"location":"api/validators/fields/parameter-field/#pyorlib.validators.ParameterField.value_types","title":"value_types  <code>property</code>","text":"<pre><code>value_types: Set[ValueType]\n</code></pre> <p>Returns the set of supported value types.</p> RETURNS DESCRIPTION <code>Set[ValueType]</code> <p>A set containing the supported value types.</p>"},{"location":"api/validators/fields/parameter-field/#pyorlib.validators.ParameterField.min","title":"min  <code>property</code>","text":"<pre><code>min: float | None\n</code></pre> <p>Returns the minimum supported value of the descriptor.</p> RETURNS DESCRIPTION <code>float | None</code> <p>The minimum supported value. If there is no minimum value, it is None.</p>"},{"location":"api/validators/fields/parameter-field/#pyorlib.validators.ParameterField.max","title":"max  <code>property</code>","text":"<pre><code>max: float | None\n</code></pre> <p>Returns the maximum supported value of the descriptor.</p> RETURNS DESCRIPTION <code>float | None</code> <p>The maximum supported value. If there is no maximum value, it is None.</p>"},{"location":"api/validators/fields/parameter-field/#pyorlib.validators.ParameterField.required","title":"required  <code>property</code>","text":"<pre><code>required: bool\n</code></pre> <p>Returns a boolean indicating whether the parameter is required.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the parameter is required, <code>False</code> otherwise.</p>"},{"location":"api/validators/fields/parameter-field/#pyorlib.validators.ParameterField-functions","title":"Functions","text":""},{"location":"api/validators/fields/parameter-field/#pyorlib.validators.ParameterField.__init__","title":"__init__","text":"<pre><code>__init__(parameter_types: Set[ParameterType], value_types: Set[ValueType], min: float | None = None, max: float | None = None, required: bool = True)\n</code></pre> <p>Initialize a new instance of ParameterField.</p> PARAMETER DESCRIPTION <code>parameter_types</code> <p>A set that contains the supported parameter types.</p> <p> TYPE: <code>Set[ParameterType]</code> </p> <code>value_types</code> <p>A set that contains the supported value types.</p> <p> TYPE: <code>Set[ValueType]</code> </p> <code>min</code> <p>The minimum value supported by the descriptor. If there is no minimum value, it is None.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>max</code> <p>The maximum value supported by the descriptor. If there is no maximum value, it is None.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>required</code> <p>A boolean indicating whether the parameter is required or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>pyorlib/validators/fields/parameter_field.py</code> <pre><code>def __init__(\n    self,\n    parameter_types: Set[ParameterType],\n    value_types: Set[ValueType],\n    min: float | None = None,\n    max: float | None = None,\n    required: bool = True,\n):\n    \"\"\"\n    Initialize a new instance of ParameterField.\n    :param parameter_types: A set that contains the supported parameter types.\n    :param value_types: A set that contains the supported value types.\n    :param min: The minimum value supported by the descriptor. If there is no minimum value, it is None.\n    :param max: The maximum value supported by the descriptor. If there is no maximum value, it is None.\n    :param required: A boolean indicating whether the parameter is required or not.\n    \"\"\"\n    # Calls the base init method\n    super().__init__()\n\n    # Applies validations\n    if parameter_types is None or len(parameter_types) == 0:\n        raise ValueError(\"The set of parameter types cannot be empty.\")\n\n    if value_types is None or len(value_types) == 0:\n        raise ValueError(\"The set of value types cannot be empty.\")\n\n    if max is not None and min is not None and min &gt; max:\n        raise ValueError(\"The minimum value for the parameter field cannot be greater than the maximum value.\")\n\n    self._parameter_types: Set[ParameterType] = parameter_types\n    \"\"\" A set of parameter types that are supported by the descriptor. \"\"\"\n\n    self._value_types: Set[ValueType] = value_types\n    \"\"\" A set of value types that are supported by the descriptor. \"\"\"\n\n    self._min: float | None = min\n    \"\"\" The minimum value supported by the descriptor, or None if there is no minimum value. \"\"\"\n\n    self._max: float | None = max\n    \"\"\" The maximum value supported by the descriptor, or None if there is no maximum value. \"\"\"\n\n    self._required: bool = required\n    \"\"\" A boolean indicating whether the parameter is required. \"\"\"\n</code></pre>"},{"location":"api/validators/fields/parameter-field/#pyorlib.validators.ParameterField.validate","title":"validate","text":"<pre><code>validate(value: Parameter | None) -&gt; None\n</code></pre> Source code in <code>pyorlib/validators/fields/parameter_field.py</code> <pre><code>def validate(self, value: Parameter | None) -&gt; None:\n    # Checks for None value\n    if value is None:\n        if self.required:\n            raise ValueError(f\"{self._public_name} is required\")\n        else:\n            return\n\n    # Checks for supported param types\n    if not value.is_bounded and ParameterType.FIXED not in self.parameter_types:\n        raise ValueError(f\"{self._public_name} does not support {ParameterType.FIXED.name}\")\n    if value.is_bounded and ParameterType.BOUNDED not in self.parameter_types:\n        raise ValueError(f\"{self._public_name} does not support {ParameterType.BOUNDED.name}\")\n\n    # Checks for supported value types\n    if value.value_type not in self.value_types:\n        raise ValueError(f\"{self._public_name} does not support {value.value_type.name}\")\n\n    # Checks for SingleValueParameter and MultiValueParameter types\n    if isinstance(value, MultiValueParameter):\n        if value.is_bounded:\n            if self._min is not None or self._max is not None:\n                for i in range(0, len(value.lower_bounds)):  # type: ignore[arg-type]\n                    lb = value.lower_bounds[i]  # type: ignore[index]\n                    ub = value.upper_bounds[i]  # type: ignore[index]\n                    self._validate_bounds(lb, ub)\n        else:\n            if self._min is not None or self._max is not None:\n                for val in value.values:  # type: ignore[union-attr]\n                    self._validate_value(val)\n    elif isinstance(value, SingleValueParameter):\n        if value.is_bounded:\n            if self._min is not None or self._max is not None:\n                self._validate_bounds(value.lower_bound, value.upper_bound)  # type: ignore[arg-type]\n        else:\n            if self._min is not None or self._max is not None:\n                self._validate_value(value.value)  # type: ignore[arg-type]\n    else:\n        raise TypeError(f\"{self._public_name} invalid parameter type\")  # pragma: no cover\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>     \u2003\u2003Welcome to the Examples section, where you can learn the key concepts and features of PyORlib     through step-by-step tutorials. These examples are designed to be user-friendly, covering a range of topics     from the basics to more advanced concepts. </p> <p>     \u2003\u2003By following these tutorials, you'll gain a solid understanding of PyORlib's core abstractions and     how to effectively apply them when building optimization models. The examples are organized in a      progressive manner, allowing you to gradually enhance your knowledge and skills. </p> <p> </p> <p> Let's kickstart your PyORlib experience! </p>"},{"location":"examples/a-transportation-problem/","title":"A Transportation Problem","text":"<p>     \u2003\u2003This tutorial is an upgrade of the Practical Example      from the main page. In this case, we are going to re-implement the transportation problem presented in the      GAMS Tutorial by Richard E. Rosenthal      using PyORlin's workflow. The purpose of this example is to provide a quick but complete overview of PyORlib and     its features in a more realistic scenario. </p>"},{"location":"examples/a-transportation-problem/#problem-formulation","title":"Problem Formulation","text":"<p>     \u2003\u2003The transportation problem we will address is a classic instance of linear programming's transportation     problem, which has historically served as a testing ground for the development of optimization technology. This      transportation problem involves determining the optimal flow of a product from multiple sources (plants) to      destinations (markets) to minimize costs while satisfying demands. </p> \\[ \\begin{align} \\text{Minimize:} \\quad &amp; \\sum_{i=1}^{n} \\sum_{j=1}^{m} c_{ij} x_{ij} \\\\ \\\\ \\text{Subject to:} \\quad &amp; \\sum_{j=1}^{m} x_{ij} \\leq a_{i} \\quad \\forall_{i} \\\\ &amp; \\sum_{i=1}^{n} x_{ij} \\geq b_{j} \\quad \\forall_{j} \\\\ &amp; x_{ij} \\geq 0 \\quad \\forall_{ij}, \\thinspace integer \\\\ &amp; i=1,...,n; \\quad j=1,...,m \\\\ \\end{align} \\] <p>     \u2003\u2003Before diving into the implementation, let's take a moment to familiarize ourselves with the key      components of the model. This brief exploration will provide a better understanding of how these components      work together. </p> <ul> <li> <p>Indices:</p> <p> \\(i=\\) plants; \\(\\quad j=\\) markets.</p> </li> <li> <p>Parameters (Given Data):</p> <p> \\(a_{i}=\\) supply of commodity of plant \\(i\\) (in cases).</p> <p> \\(b_{j}=\\) demand for commodity at market \\(j\\) (cases).</p> <p> \\(c_{ij}=\\) cost per unit shipment between plan \\(i\\) and market \\(j\\) ($/case).</p> </li> <li> <p>Decision Variables:</p> <p> \\(x_{ij}=\\) amount of commodity to ship from plant \\(i\\) to market \\(j\\) (cases).</p> </li> <li> <p>Constraints:</p> <p>\u2003Observe supply limit at plant \\(i\\): \\(\\sum_{j=1}^{m} x_{ij} \\leq a_{i} \\quad \\forall_{i}\\)</p> <p>\u2003Satisfy demand at market \\(j\\): \\(\\sum_{i=1}^{n} x_{ij} \\geq b_{j} \\quad \\forall_{j}\\)</p> </li> </ul> <p>     \u2003\u2003The GAMS tutorial describes a scenario with two canning plants and three markets. It provides sample      supply, demand and cost data. We will use this same data to define our model. </p> New York Chicago Topeka Supply Seattle 2.5 1.7 1.8 350 San Diego 2.5 1.8 1.4 600 Demand 325 300 275"},{"location":"examples/a-transportation-problem/#solution-using-pyorlib","title":"Solution Using PyORlib","text":"<p>     \u2003\u2003To model and solve the problem in Python, we will utilize PyORlib and its integration with CPLEX.      However, it's worth noting that you have the flexibility to choose from various supported optimization engine      integrations mentioned in the Optional Dependencies      section, or even use your own custom implementations. </p> <ol> <li>Required Imports and Dependencies: Before proceeding, make sure you have PyORlib installed, along with the CPLEX engine integration. Once everything is  set up, let's import all the necessary components and start building our transportation model:  <pre><code>from dataclasses import dataclass\nfrom math import inf\n\nfrom pyorlib import Model, Engine\nfrom pyorlib.engines.cplex import CplexEngine  # Can be replaced with other integration options.\nfrom pyorlib.enums import ValueType, ParameterType, OptimizationType  # These enums are used for specifying value types, parameter types, and optimization types in PyORlib.\nfrom pyorlib.structures import DimensionDefinition, ParameterDefinition, TermDefinition, MultiValueParameter  # Classes that are used for organizing and defining the structure of the model.\nfrom pyorlib.validators import DimensionField, ParameterField  # Classes that are used for validating the dimensions and parameters of the model.\n</code></pre> </li> <li>Model Definition: In order to keep our code organized, readable, and maintainable over time, we will structure variable, parameter, and  dimension definitions (metadata) in a clean and extensible manner using PyORlib's definition module.  <pre><code>class TransportModelDefinition:\n    \"\"\"Transportation Nomenclature Definitions\"\"\"\n\n    @dataclass(frozen=True)\n    class Dimensions:\n        n = DimensionDefinition(name=\"n\", display_name=\"Total plants\")\n        m = DimensionDefinition(name=\"m\", display_name=\"Total markets\")\n\n    @dataclass(frozen=True)\n    class Parameters:\n        a_i = ParameterDefinition(\n            set_name=\"a_i\",\n            name=lambda i: f\"a_{i}\",\n            display_name=\"Supply of commodity of plant i (in cases)\",\n            parameter_types={ParameterType.FIXED},\n            value_types={ValueType.INTEGER},\n            min=0,\n        )\n        b_j = ParameterDefinition(\n            set_name=\"b_j\",\n            name=lambda j: f\"b_{j}\",\n            display_name=\"Demand for commodity at market j (cases)\",\n            parameter_types={ParameterType.FIXED},\n            value_types={ValueType.INTEGER},\n            min=0,\n        )\n        c_i_j = ParameterDefinition(\n            set_name=\"c_i_j\",\n            name=lambda i, j: f\"c_{i}_{j}\",\n            display_name=\"Cost per unit shipment between plan i and market j ($/case)\",\n            parameter_types={ParameterType.FIXED},\n            value_types={ValueType.CONTINUOUS},\n            min=0,\n        )\n\n    @dataclass(frozen=True)\n    class DecisionVariables:\n        x_i_j = TermDefinition(\n            set_name=\"x_i_j\",\n            name=lambda i, j: f\"x_{i}_{j}\",\n            display_name=\"Amount of commodity to ship from plant i to market j (cases)\",\n        )\n</code></pre> </li> <li>Data Schema and Validations: Now that we have defined the model components, we can focus on handling data entry and validations for parameters and dimensions. For this task, we will use PyORlib's structures and validators.  <pre><code>@dataclass\nclass TransportModelSchema:\n    \"\"\"Data Entry Validations\"\"\"\n\n    n: int = DimensionField(min=TransportModelDefinition.Dimensions.n.min)\n    m: int = DimensionField(min=TransportModelDefinition.Dimensions.m.min)\n\n    a_i: MultiValueParameter = ParameterField(\n        parameter_types=TransportModelDefinition.Parameters.a_i.parameter_types,\n        value_types=TransportModelDefinition.Parameters.a_i.value_types,\n        min=TransportModelDefinition.Parameters.a_i.min,\n    )\n    b_j: MultiValueParameter = ParameterField(\n        parameter_types=TransportModelDefinition.Parameters.b_j.parameter_types,\n        value_types=TransportModelDefinition.Parameters.b_j.value_types,\n        min=TransportModelDefinition.Parameters.b_j.min,\n    )\n    c_i_j: MultiValueParameter = ParameterField(\n        parameter_types=TransportModelDefinition.Parameters.c_i_j.parameter_types,\n        value_types=TransportModelDefinition.Parameters.c_i_j.value_types,\n        min=TransportModelDefinition.Parameters.c_i_j.min,\n    )\n\n    def __post_init__(self):\n        if len(self.a_i.values) != self.n:\n            raise ValueError(f\"'a_i' values must have a length of {self.n}\")\n        if len(self.b_j.values) != self.m:\n            raise ValueError(f\"'b_j' values must have a length of {self.m}\")\n        if len(self.c_i_j.values) != self.n * self.m:\n            raise ValueError(f\"'c_i_j' values must have a length of {self.n * self.m}\")\n</code></pre> </li> <li>Transportation Model: With the data entry schema in place, we can now define the transportation model.  <pre><code>class TransportModel(Model):\n\n    def __init__(self, engine: Engine, data: TransportModelSchema, debug: bool = False):\n        super().__init__(engine=engine, name=\"Transportation Model\", debug=debug)\n\n        if data is None:\n            raise ValueError(\"'data' parameter cannot be None.\")\n\n        # Dimensions\n        n = self.add_dimension(name=TransportModelDefinition.Dimensions.n.name, value=data.n)\n        m = self.add_dimension(name=TransportModelDefinition.Dimensions.m.name, value=data.m)\n\n        n_range = range(1, n + 1)\n        m_range = range(1, m + 1)\n\n        # Parameters\n        for i in n_range:  # Plant's supply values\n            self.add_constant_to_set(\n                set_name=TransportModelDefinition.Parameters.a_i.set_name,\n                set_index=(i,),\n                const_name=TransportModelDefinition.Parameters.a_i.name(i),\n                value_type=data.a_i.value_type,\n                value=data.a_i.values[i - 1],\n            )\n        a_i = self.get_term_set_by_name(name=TransportModelDefinition.Parameters.a_i.set_name)\n\n        for j in m_range:  # Market's demands\n            self.add_constant_to_set(\n                set_name=TransportModelDefinition.Parameters.b_j.set_name,\n                set_index=(j,),\n                const_name=TransportModelDefinition.Parameters.b_j.name(j),\n                value_type=data.b_j.value_type,\n                value=data.b_j.values[j - 1],\n            )\n        b_j = self.get_term_set_by_name(name=TransportModelDefinition.Parameters.b_j.set_name)\n\n        for i in n_range:\n            for j in m_range:  # Costs\n                self.add_constant_to_set(\n                    set_name=TransportModelDefinition.Parameters.c_i_j.set_name,\n                    set_index=(i, j),\n                    const_name=TransportModelDefinition.Parameters.c_i_j.name(i, j),\n                    value_type=data.c_i_j.value_type,\n                    value=data.c_i_j.values[(i - 1) * m + (j - 1)],\n                )\n        c_i_j = self.get_term_set_by_name(name=TransportModelDefinition.Parameters.c_i_j.set_name)\n\n        # Decision variables\n        for i in n_range:\n            for j in m_range:\n                self.add_variable_to_set(\n                    set_name=TransportModelDefinition.DecisionVariables.x_i_j.set_name,\n                    set_index=(i, j),\n                    var_name=TransportModelDefinition.DecisionVariables.x_i_j.name(i, j),\n                    value_type=ValueType.INTEGER,\n                    lower_bound=0,\n                    upper_bound=inf,\n                )\n        x_i_j = self.get_term_set_by_name(name=TransportModelDefinition.DecisionVariables.x_i_j.set_name)\n\n\n        # Supply limit at plants constraints\n        for i in n_range:\n            self.add_constraint(\n                expression=sum(\n                    x_i_j[i, j]\n                    for j in m_range\n                ) &lt;= a_i[(i,)]\n            )\n\n        # Satisfy demand at markets constraints\n        for j in m_range:\n            self.add_constraint(\n                expression=sum(\n                    x_i_j[i, j]\n                    for i in n_range\n                ) &gt;= b_j[(j,)]\n            )\n\n        # Objective function\n        self.set_objective(\n            opt_type=OptimizationType.MINIMIZE,\n            expression=sum(\n                c_i_j[i, j] * x_i_j[i, j]\n                for i in n_range\n                for j in m_range\n            )\n        )\n</code></pre> </li> <li>Model Optimization: Finally, having defined the transportation model class, we can create a new instance of it with our data and  optimize it.  <pre><code># Instantiate the transportation model\nmodel = TransportModel(\n    engine=CplexEngine(),\n    data=TransportModelSchema(\n        n=2,\n        m=3,\n        a_i=MultiValueParameter(\n            parameter_type=ParameterType.FIXED,\n            value_type=ValueType.INTEGER,\n            values=(350, 600),\n        ),\n        b_j=MultiValueParameter(\n            parameter_type=ParameterType.FIXED,\n            value_type=ValueType.INTEGER,\n            values=(325, 300, 275),\n        ),\n        c_i_j=MultiValueParameter(\n            parameter_type=ParameterType.FIXED,\n            value_type=ValueType.CONTINUOUS,\n            values=(2.5, 1.7, 1.8, 2.5, 1.8, 1.4),\n        ),\n    )\n)\n\n# Optimize the model\nmodel.solve()\n\n# Display solution\nmodel.print_solution()\n</code></pre> Click here to view the complete code... <pre><code>from dataclasses import dataclass\nfrom math import inf\n\nfrom pyorlib import Model, Engine\nfrom pyorlib.engines.cplex import CplexEngine  # Can be replaced with other integration options.\nfrom pyorlib.enums import ValueType, ParameterType, OptimizationType  # These enums are used for specifying value types, parameter types, and optimization types in PyORlib.\nfrom pyorlib.structures import DimensionDefinition, ParameterDefinition, TermDefinition, MultiValueParameter  # Classes that are used for organizing and defining the structure of the model.\nfrom pyorlib.validators import DimensionField, ParameterField  # Classes that are used for validating the dimensions and parameters of the model.\n\n\nclass TransportModelDefinition:\n    \"\"\"Transportation Nomenclature Definitions\"\"\"\n\n    @dataclass(frozen=True)\n    class Dimensions:\n        n = DimensionDefinition(name=\"n\", display_name=\"Total plants\")\n        m = DimensionDefinition(name=\"m\", display_name=\"Total markets\")\n\n    @dataclass(frozen=True)\n    class Parameters:\n        a_i = ParameterDefinition(\n            set_name=\"a_i\",\n            name=lambda i: f\"a_{i}\",\n            display_name=\"Supply of commodity of plant i (in cases)\",\n            parameter_types={ParameterType.FIXED},\n            value_types={ValueType.INTEGER},\n            min=0,\n        )\n        b_j = ParameterDefinition(\n            set_name=\"b_j\",\n            name=lambda j: f\"b_{j}\",\n            display_name=\"Demand for commodity at market j (cases)\",\n            parameter_types={ParameterType.FIXED},\n            value_types={ValueType.INTEGER},\n            min=0,\n        )\n        c_i_j = ParameterDefinition(\n            set_name=\"c_i_j\",\n            name=lambda i, j: f\"c_{i}_{j}\",\n            display_name=\"Cost per unit shipment between plan i and market j ($/case)\",\n            parameter_types={ParameterType.FIXED},\n            value_types={ValueType.CONTINUOUS},\n            min=0,\n        )\n\n    @dataclass(frozen=True)\n    class DecisionVariables:\n        x_i_j = TermDefinition(\n            set_name=\"x_i_j\",\n            name=lambda i, j: f\"x_{i}_{j}\",\n            display_name=\"Amount of commodity to ship from plant i to market j (cases)\",\n        )\n\n\n@dataclass\nclass TransportModelSchema:\n    \"\"\"Data Entry Validations\"\"\"\n\n    n: int = DimensionField(min=TransportModelDefinition.Dimensions.n.min)\n    m: int = DimensionField(min=TransportModelDefinition.Dimensions.m.min)\n\n    a_i: MultiValueParameter = ParameterField(\n        parameter_types=TransportModelDefinition.Parameters.a_i.parameter_types,\n        value_types=TransportModelDefinition.Parameters.a_i.value_types,\n        min=TransportModelDefinition.Parameters.a_i.min,\n    )\n    b_j: MultiValueParameter = ParameterField(\n        parameter_types=TransportModelDefinition.Parameters.b_j.parameter_types,\n        value_types=TransportModelDefinition.Parameters.b_j.value_types,\n        min=TransportModelDefinition.Parameters.b_j.min,\n    )\n    c_i_j: MultiValueParameter = ParameterField(\n        parameter_types=TransportModelDefinition.Parameters.c_i_j.parameter_types,\n        value_types=TransportModelDefinition.Parameters.c_i_j.value_types,\n        min=TransportModelDefinition.Parameters.c_i_j.min,\n    )\n\n    def __post_init__(self):\n        if len(self.a_i.values) != self.n:\n            raise ValueError(f\"'a_i' values must have a length of {self.n}\")\n        if len(self.b_j.values) != self.m:\n            raise ValueError(f\"'b_j' values must have a length of {self.m}\")\n        if len(self.c_i_j.values) != self.n * self.m:\n            raise ValueError(f\"'c_i_j' values must have a length of {self.n * self.m}\")\n\n\nclass TransportModel(Model):\n\n    def __init__(self, engine: Engine, data: TransportModelSchema, debug: bool = False):\n        super().__init__(engine=engine, name=\"Transportation Model\", debug=debug)\n\n        if data is None:\n            raise ValueError(\"'data' parameter cannot be None.\")\n\n        # Dimensions\n        n = self.add_dimension(name=TransportModelDefinition.Dimensions.n.name, value=data.n)\n        m = self.add_dimension(name=TransportModelDefinition.Dimensions.m.name, value=data.m)\n\n        n_range = range(1, n + 1)\n        m_range = range(1, m + 1)\n\n        # Parameters\n        for i in n_range:  # Plant's supply values\n            self.add_constant_to_set(\n                set_name=TransportModelDefinition.Parameters.a_i.set_name,\n                set_index=(i,),\n                const_name=TransportModelDefinition.Parameters.a_i.name(i),\n                value_type=data.a_i.value_type,\n                value=data.a_i.values[i - 1],\n            )\n        a_i = self.get_term_set_by_name(name=TransportModelDefinition.Parameters.a_i.set_name)\n\n        for j in m_range:  # Market's demands\n            self.add_constant_to_set(\n                set_name=TransportModelDefinition.Parameters.b_j.set_name,\n                set_index=(j,),\n                const_name=TransportModelDefinition.Parameters.b_j.name(j),\n                value_type=data.b_j.value_type,\n                value=data.b_j.values[j - 1],\n            )\n        b_j = self.get_term_set_by_name(name=TransportModelDefinition.Parameters.b_j.set_name)\n\n        for i in n_range:\n            for j in m_range:  # Costs\n                self.add_constant_to_set(\n                    set_name=TransportModelDefinition.Parameters.c_i_j.set_name,\n                    set_index=(i, j),\n                    const_name=TransportModelDefinition.Parameters.c_i_j.name(i, j),\n                    value_type=data.c_i_j.value_type,\n                    value=data.c_i_j.values[(i - 1) * m + (j - 1)],\n                )\n        c_i_j = self.get_term_set_by_name(name=TransportModelDefinition.Parameters.c_i_j.set_name)\n\n        # Decision variables\n        for i in n_range:\n            for j in m_range:\n                self.add_variable_to_set(\n                    set_name=TransportModelDefinition.DecisionVariables.x_i_j.set_name,\n                    set_index=(i, j),\n                    var_name=TransportModelDefinition.DecisionVariables.x_i_j.name(i, j),\n                    value_type=ValueType.INTEGER,\n                    lower_bound=0,\n                    upper_bound=inf,\n                )\n        x_i_j = self.get_term_set_by_name(name=TransportModelDefinition.DecisionVariables.x_i_j.set_name)\n\n\n        # Supply limit at plants constraints\n        for i in n_range:\n            self.add_constraint(\n                expression=sum(\n                    x_i_j[i, j]\n                    for j in m_range\n                ) &lt;= a_i[(i,)]\n            )\n\n        # Satisfy demand at markets constraints\n        for j in m_range:\n            self.add_constraint(\n                expression=sum(\n                    x_i_j[i, j]\n                    for i in n_range\n                ) &gt;= b_j[(j,)]\n            )\n\n        # Objective function\n        self.set_objective(\n            opt_type=OptimizationType.MINIMIZE,\n            expression=sum(\n                c_i_j[i, j] * x_i_j[i, j]\n                for i in n_range\n                for j in m_range\n            )\n        )\n\n\n# Instantiate the transportation model\nmodel = TransportModel(\n    engine=CplexEngine(),\n    data=TransportModelSchema(\n        n=2,\n        m=3,\n        a_i=MultiValueParameter(\n            parameter_type=ParameterType.FIXED,\n            value_type=ValueType.INTEGER,\n            values=(350, 600),\n        ),\n        b_j=MultiValueParameter(\n            parameter_type=ParameterType.FIXED,\n            value_type=ValueType.INTEGER,\n            values=(325, 300, 275),\n        ),\n        c_i_j=MultiValueParameter(\n            parameter_type=ParameterType.FIXED,\n            value_type=ValueType.CONTINUOUS,\n            values=(2.5, 1.7, 1.8, 2.5, 1.8, 1.4),\n        ),\n    )\n)\n\n# Optimize the model\nmodel.solve()\n\n# Display solution\nmodel.print_solution()\n</code></pre> <p>     \u2003\u2003Once you have implemented and solved the model using PyORlib, you will find the solution outputs      displayed in the console logs as follows: </p> <pre><code>------ MODEL SOLUTION ------\n\nObjective function:\n        Status: OPTIMAL\n        Value:  1707.5\nTerms:\n        Name: x_1_1 | Type: Variable | Value type: Integer | lb: 0 | ub: inf | val: 50  \n        Name: x_1_2 | Type: Variable | Value type: Integer | lb: 0 | ub: inf | val: 300  \n        Name: x_2_1 | Type: Variable | Value type: Integer | lb: 0 | ub: inf | val: 275  \n        Name: x_2_3 | Type: Variable | Value type: Integer | lb: 0 | ub: inf | val: 275  \n</code></pre> </li> </ol>"},{"location":"examples/a-transportation-problem/#recap","title":"Recap","text":"<p>     \u2003\u2003In this tutorial, we explored how to use the PyORlib library to optimize a transportation problem\u2014an      upgrade from the practical example covered earlier. Throughout our journey, we gained hands-on experience applying     PyORlib's powerful features to model and solve a real-world optimization challenge of transporting products between     multiple sources and destinations. </p> <p>     \u2003\u2003Firstly, we introduced the transportation problem and defined the sources, destinations, costs and      demands. By structuring our model with PyORlib's definition module classes, we created an organized and readable      representation of the transportation model. We also handled data entries and ensured valid input using PyORlib's      data structures and validators. </p> <p>     \u2003\u2003With our transportation model built, we then optimized it using PyORlib's techniques to find the      lowest-cost flows that meet all demands. The console outputs displayed the solution, providing valuable insights.     Overall, PyORlib proved to be a flexible and effective tool for tackling this classic optimization problem. </p> <p>     \u2003\u2003In summary, this tutorial equipped us with the skills to leverage PyORlib's full capabilities for a      variety of optimization challenges. Armed with our newfound knowledge of modeling, data processing, and      optimization, we can now unlock the potential for impactful Python projects across many domains. </p>"}]}